-- tables
CREATE TABLE commands (
  id serial PRIMARY KEY NOT NULL,
  command varchar NOT NULL,
  local_time varchar(255) NOT NULL,
  -- exit_status varchar(255) DEFAULT '',
  -- output varchar(10240),
  -- CONSTRAINT order_unique UNIQUE (id),
  -- UNIQUE (command),
  -- UNIQUE (local_time)
  UNIQUE (command, local_time)
);

CREATE TABLE machines (
  id serial PRIMARY KEY NOT NULL,
  ip varchar(255) DEFAULT '',
  ipv6 varchar(255) DEFAULT '',
  mac_adr varchar(255) DEFAULT '',
  local_name varchar(255) DEFAULT '',
  -- name varchar(255) DEFAULT '',
  gateway_to varchar(255) DEFAULT '', -- gateway to this box form the outside world  (useful for machines that require pivoting to get to.)
  -- dns_name_uid int references dns_names(id), -- varchar(255) DEFAULT '',
  command_uid INTEGER references commands(id),
  constraint chk_null check (ip is not null or ipv6 is not null or mac_adr is not null or local_name is not null),
  UNIQUE (ip, ipv6, mac_adr)
  -- UNIQUE (ipv6),
  -- UNIQUE (ip)
  -- UNIQUE()
);

-- CREATE TABLE cnames (
--   id serial PRIMARY KEY NOT NULL,
--   cname int references dns_names(id),
--   points_to int references dns_names(id),
--   UNIQUE (cname, points_to)
-- );

CREATE TABLE dns_names (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  dns_name varchar(255) NOT NULL,
  command_uid INTEGER references commands(id),
  UNIQUE (machine_uid, dns_name)
);

CREATE TABLE ports (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER NOT NULL,
  port int NOT NULL,
  state varchar(255) DEFAULT '',
  TL_protocol varchar(255) DEFAULT '', -- transport layer protocol tcp or udp
  service varchar(255) DEFAULT '',
  version varchar(255) DEFAULT '',
  command_uid INTEGER references commands(id), -- NOT null
  UNIQUE (port, machine_uid, state, service, TL_protocol, version)
  -- UNIQUE (port, host_uid, state)
  -- UNIQUE (port, host_uid),
  -- UNIQUE (port, host_uid, state)
);

CREATE TABLE web_dirs (
  id serial PRIMARY KEY NOT NULL,
  dns_name_uid int references dns_names(id), -- INTEGER NOT NULL,
  -- machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER NOT NULL,
  dir varchar(255) DEFAULT '',
  url varchar(255) DEFAULT '',
  base_url varchar(255) NOT NULL,
  res_code varchar(255) NOT NULL,
  web_protocol varchar(255) NOT NULL,
  method varchar(255) NOT NULL,
  num_chars varchar(255) DEFAULT '',
  redirect_adr varchar(255) DEFAULT '',
  -- wordlist varchar(255),
  command_uid INTEGER references commands(id), -- pointer to id of 'commands' table
  constraint chk_null check (NOT dir = '' OR NOT url = ''),
  UNIQUE (base_url, dir, url, res_code, web_protocol, num_chars, method)
  -- UNIQUE (machine_uid, base_url, dir, url, res_code, web_protocol, num_chars, method)
);

CREATE TABLE creds (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER DEFAULT 0,
  username varchar(255) DEFAULT '',
  password varchar(255) DEFAULT '',
  wordlist varchar(255) DEFAULT '',
  hash_file varchar(255) DEFAULT '',
  domain varchar(255) DEFAULT '', -- where this username and password can be used. (local, ssh, ftp, web, etc), if multiple domains, there will be multiple rows.
  command_uid INTEGER references commands(id), -- pointer to id of 'commands' table
  port_uid INTEGER DEFAULT 0, -- pointer to the id of the 'ports' table
  -- CONSTRAINT order_unique UNIQUE (id),
  UNIQUE (username, password, machine_uid, hash_file) -- don't add wordlist (see, REASON #1 bellow) -- maybe add host?
  -- REASON #1: passwd-username combo will be added again for each passwd cracking atempt with
  --            different wordlists
  -- UNIQUE ()
);

-- functions
-- TODO: test this syntaxt
CREATE FUNCTION get_machine(identifier varchar)
RETURNS integer
AS $$
DECLARE machine_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
  IF EXISTS ( 
    SELECT machines.id FROM machines WHERE ip = identifier OR ipv6 = identifier OR local_name = identifier
    )
  THEN
    SELECT machines.id INTO machine_uid FROM machines WHERE ip = identifier OR ipv6 = identifier OR local_name = identifier;
    RETURN machine_uid;
  ELSE
    RETURN -1;
  END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

CREATE FUNCTION get_port(p_num int, machine int)
RETURNS integer
AS $$
DECLARE port_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
  IF EXISTS (SELECT id FROM ports WHERE port = p_num AND machine_uid = machine)
  THEN
    SELECT id INTO port_uid FROM ports WHERE port = p_num AND machine_uid = machine;
    RETURN port_uid;
  ELSE
    RETURN -1;
  END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

CREATE FUNCTION get_dns_name(name varchar, machine int)
RETURNS integer
AS $$
DECLARE dns_name_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
  IF EXISTS (SELECT id FROM dns_names WHERE dns_name = name AND machine_uid = machine)
  THEN
    SELECT id INTO dns_name_uid FROM dns_names WHERE dns_name = name AND machine_uid = machine;
    RETURN dns_name_uid;
  ELSE
    RETURN -1;
  END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

CREATE FUNCTION get_web_dir(remote_url varchar, web_dir varchar)
RETURNS integer
AS $$
DECLARE web_dir_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
  IF EXISTS (SELECT id FROM web_dirs WHERE url = remote_url AND dir = web_dir)
  THEN
    SELECT id INTO web_dir_uid FROM web_dirs WHERE url = remote_url AND dir = web_dir;
    RETURN web_dir_uid;
  ELSE
    RETURN -1;
  END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

-- CREATE FUNCTION get_web_dir(remote_url varchar, machine int)
-- RETURNS integer
-- AS $$
-- DECLARE web_dir_uid integer;
-- BEGIN
--     -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
--     -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
--   IF EXISTS (SELECT id FROM web_dir WHERE url = remote_url AND machine_uid = machine)
--   THEN
--     SELECT id INTO web_dir_uid FROM web_dir WHERE url = remote_url AND machine_uid = machine;
--     RETURN web_dir_uid;
--   ELSE
--     RETURN -1;
--   END IF;

--     -- RETURN tmp_dns_name;
-- END; $$
-- LANGUAGE plpgsql;

CREATE FUNCTION get_cred(uname varchar, pwd varchar, machine int)
RETURNS integer
AS $$
DECLARE cred_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
  IF EXISTS (SELECT id FROM creds WHERE username = uname AND password = pwd AND machine_uid = machine)
  THEN
    SELECT id INTO cred_uid FROM creds WHERE username = uname AND password = pwd AND machine_uid = machine;
    RETURN cred_uid;
  ELSE
    RETURN -1;
  END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

-- CREATE FUNCTION recurse_cname(dns_name_uid integer) 
-- RETURNS integer
-- AS $$
-- DECLARE next_uid int;
-- BEGIN
--     IF EXISTS ( SELECT cname FROM cnames WHERE points_to = dns_name_uid )
--     THEN
--         SELECT cname INTO next_uid FROM cnames WHERE points_to = dns_name_uid;
--         return recurse_cname(next_uid);
--     ELSE
--         RETURN dns_name_uid;
--     END if;
-- END; $$
-- LANGUAGE plpgsql IMMUTABLE;

-- CREATE FUNCTION get_dns_name(dns_name_uid integer)
-- RETURNS varchar(255)
-- AS $$
-- DECLARE tmp_dns_name varchar(255);
-- BEGIN
--     SELECT dns_name INTO tmp_dns_name FROM dns_names WHERE id = recurse_cname(dns_name_uid);

--     RETURN tmp_dns_name;
-- END; $$
-- LANGUAGE plpgsql IMMUTABLE;

-- CREATE FUNCTION add_cname(arg_dns_name_uid integer, machine_uid integer) 
-- RETURNS integer
-- AS $$
-- DECLARE next_uid int;
-- BEGIN
--     INSERT INTO all_names (dns_name_uid, machine_uid) SELECT arg_dns_name_uid, machines.id FROM machines WHERE id = machine_uid; -- ON CONFLICT DO NOTHING;
--     IF EXISTS ( SELECT cname FROM cnames WHERE points_to = arg_dns_name_uid )
--     THEN
--         SELECT cname INTO next_uid FROM cnames WHERE points_to = arg_dns_name_uid;
--         RETURN add_cname(next_uid, machine_uid);
--     ELSE
--         RETURN arg_dns_name_uid;
--     END if;
-- END; $$
-- LANGUAGE plpgsql;

-- CREATE FUNCTION get_machine(identifier varchar)
-- RETURNS integer
-- AS $$
-- DECLARE machine_uid integer;
-- BEGIN
--     -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
--     -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
--     IF EXISTS ( SELECT id FROM machines WHERE ip = identifier OR ipv6 = identifier )
--     THEN
--         SELECT id INTO machine_uid FROM machines WHERE ip = identifier OR ipv6 = identifier;
--         RETURN machine_uid;
--     ELSE
--         DELETE FROM all_names;
--         PERFORM add_cname(machines.dns_name_uid, machines.id) FROM machines;
--         SELECT all_names.machine_uid INTO machine_uid FROM all_names JOIN dns_names ON all_names.dns_name_uid = dns_names.id WHERE dns_names.dns_name = identifier;
--         RETURN machine_uid;
--     END IF;

--     -- RETURN tmp_dns_name;
-- END; $$
-- LANGUAGE plpgsql;

-- CREATE FUNCTION add_name_col() 
-- RETURNS integer
-- AS $$
-- DECLARE next_uid int;
-- BEGIN
--     ALTER TABLE machines ADD name varchar; 
--     UPDATE machines SET name = get_dns_name(dns_names_uid);
--     -- INSERT INTO all_names (dns_name_uid, machine_uid) SELECT arg_dns_name_uid, machines.id FROM machines WHERE id = machine_uid; -- ON CONFLICT DO NOTHING;
--     -- IF EXISTS ( SELECT cname FROM cnames WHERE points_to = arg_dns_name_uid )
--     -- THEN
--     --     SELECT cname INTO next_uid FROM cnames WHERE points_to = arg_dns_name_uid;
--     --     RETURN add_cname(next_uid, machine_uid);
--     -- ELSE
--     --     RETURN arg_dns_name_uid;
--     -- END if;
-- END; $$
-- LANGUAGE plpgsql;