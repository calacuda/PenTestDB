-- tables
CREATE TABLE dns_names (
  id serial PRIMARY KEY NOT NULL,
  dns_name varchar(255) DEFAULT '',
  UNIQUE (dns_name)
);

CREATE TABLE machines (
  id serial PRIMARY KEY NOT NULL,
  ip varchar(255) DEFAULT '',
  ipv6 varchar(255) DEFAULT '',
  mac_adr varchar(255) DEFAULT '',
  local_name varchar(255) DEFAULT '',
  -- name varchar(255) DEFAULT '',
  gateway_to varchar(255) DEFAULT '', -- gateway to this box form the outside world  (useful for machines that require pivoting to get to.)
  dns_name_uid int references dns_names(id), -- varchar(255) DEFAULT '',
  constraint chk_null check (ip is not null or ipv6 is not null or mac_adr is not null or local_name is not null),
  UNIQUE (ip, ipv6, mac_adr)
  -- UNIQUE (ipv6),
  -- UNIQUE (ip)
  -- UNIQUE()
);

CREATE TABLE cnames (
  id serial PRIMARY KEY NOT NULL,
  cname int references dns_names(id),
  points_to int references dns_names(id),
  UNIQUE (cname, points_to)
);

CREATE TABLE all_names (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  dns_name_uid int references dns_names(id),
  UNIQUE (machine_uid, dns_name_uid)
);

CREATE TABLE ports (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER NOT NULL,
  port varchar(255) NOT NULL,
  state varchar(255) DEFAULT '',
  TL_protocol varchar(255) DEFAULT '', -- transport layer protocol tcp or udp
  service varchar(255) DEFAULT '',
  version varchar(255) DEFAULT '',
  command_uid INTEGER NOT NULL, -- NOT null
  UNIQUE (port, machine_uid, state, service, TL_protocol, version)
  -- UNIQUE (port, host_uid, state)
  -- UNIQUE (port, host_uid),
  -- UNIQUE (port, host_uid, state)
);

CREATE TABLE web_dirs (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER NOT NULL,
  dir varchar(255) DEFAULT '',
  url varchar(255) DEFAULT '',
  base_url varchar(255) NOT NULL,
  res_code varchar(255) NOT NULL,
  web_protocol varchar(255) NOT NULL,
  method varchar(255) NOT NULL,
  num_chars varchar(255) DEFAULT '',
  redirect_adr varchar(255) DEFAULT '',
  -- wordlist varchar(255),
  command_uid INTEGER NOT NULL, -- pointer to id of 'commands' table
  constraint chk_null check (NOT dir = '' OR NOT url = ''),
  UNIQUE (machine_uid, base_url, dir, url, res_code, web_protocol, num_chars, method)
);

CREATE TABLE creds (
  id serial PRIMARY KEY NOT NULL,
  machine_uid int references machines(id), -- INTEGER NOT NULL,
  -- host_uid INTEGER DEFAULT 0,
  username varchar(255) DEFAULT '',
  password varchar(255) DEFAULT '',
  wordlist varchar(255) DEFAULT '',
  hash_file varchar(255) DEFAULT '',
  domain varchar(255) DEFAULT '', -- where this username and password can be used. (local, ssh, ftp, web, etc), if multiple domains, there will be multiple rows.
  command_uid INTEGER NOT NULL, -- pointer to id of 'commands' table
  port_uid INTEGER DEFAULT 0, -- pointer to the id of the 'ports' table
  -- CONSTRAINT order_unique UNIQUE (id),
  UNIQUE (username, password, machine_uid, hash_file) -- don't add wordlist (see, REASON #1 bellow) -- maybe add host?
  -- REASON #1: passwd-username combo will be added again for each passwd cracking atempt with
  --            different wordlists
  -- UNIQUE ()
);

CREATE TABLE commands (
  id serial PRIMARY KEY NOT NULL,
  command varchar NOT NULL,
  local_time varchar(255) NOT NULL,
  -- exit_status varchar(255) DEFAULT '',
  -- output varchar(10240),
  -- CONSTRAINT order_unique UNIQUE (id),
  -- UNIQUE (command),
  -- UNIQUE (local_time)
  UNIQUE (command, local_time)
);

-- functions
CREATE FUNCTION recurse_cname(dns_name_uid integer) 
RETURNS integer
AS $$
DECLARE next_uid int;
BEGIN
    IF EXISTS ( SELECT cname FROM cnames WHERE points_to = dns_name_uid )
    THEN
        SELECT cname INTO next_uid FROM cnames WHERE points_to = dns_name_uid;
        return recurse_cname(next_uid);
    ELSE
        RETURN dns_name_uid;
    END if;
END; $$
LANGUAGE plpgsql IMMUTABLE;

CREATE FUNCTION get_dns_name(dns_name_uid integer)
RETURNS varchar(255)
AS $$
DECLARE tmp_dns_name varchar(255);
BEGIN
    SELECT dns_name INTO tmp_dns_name FROM dns_names WHERE id = recurse_cname(dns_name_uid);

    RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql IMMUTABLE;

CREATE FUNCTION add_cname(arg_dns_name_uid integer, machine_uid integer) 
RETURNS integer
AS $$
DECLARE next_uid int;
BEGIN
    INSERT INTO all_names (dns_name_uid, machine_uid) SELECT arg_dns_name_uid, machines.id FROM machines WHERE id = machine_uid; -- ON CONFLICT DO NOTHING;
    IF EXISTS ( SELECT cname FROM cnames WHERE points_to = arg_dns_name_uid )
    THEN
        SELECT cname INTO next_uid FROM cnames WHERE points_to = arg_dns_name_uid;
        RETURN add_cname(next_uid, machine_uid);
    ELSE
        RETURN arg_dns_name_uid;
    END if;
END; $$
LANGUAGE plpgsql;

CREATE FUNCTION get_machine(identifier varchar)
RETURNS integer
AS $$
DECLARE machine_uid integer;
BEGIN
    -- SELECT dns_name_uid FROM machines WHERE id = recurse_cname(dns_name_uid);
    -- INSERT INTO all_names (dns_name, machine_uid) SELECT dns_names.id, machines.id FROM machines JOIN dns_names ON machines.dns_name_uid = dns_names.id;
    
    IF EXISTS ( SELECT id FROM machines WHERE ip = identifier OR ipv6 = identifier )
    THEN
        SELECT id INTO machine_uid FROM machines WHERE ip = identifier OR ipv6 = identifier;
        RETURN machine_uid;
    ELSE
        DELETE FROM all_names;
        PERFORM add_cname(machines.dns_name_uid, machines.id) FROM machines;
        SELECT all_names.machine_uid INTO machine_uid FROM all_names JOIN dns_names ON all_names.dns_name_uid = dns_names.id WHERE dns_names.dns_name = identifier;
        RETURN machine_uid;
    END IF;

    -- RETURN tmp_dns_name;
END; $$
LANGUAGE plpgsql;

CREATE FUNCTION add_name_col() 
RETURNS integer
AS $$
DECLARE next_uid int;
BEGIN
    ALTER TABLE machines ADD name varchar; 
    UPDATE machines SET name = get_dns_name(dns_names_uid);
    -- INSERT INTO all_names (dns_name_uid, machine_uid) SELECT arg_dns_name_uid, machines.id FROM machines WHERE id = machine_uid; -- ON CONFLICT DO NOTHING;
    -- IF EXISTS ( SELECT cname FROM cnames WHERE points_to = arg_dns_name_uid )
    -- THEN
    --     SELECT cname INTO next_uid FROM cnames WHERE points_to = arg_dns_name_uid;
    --     RETURN add_cname(next_uid, machine_uid);
    -- ELSE
    --     RETURN arg_dns_name_uid;
    -- END if;
END; $$
LANGUAGE plpgsql;