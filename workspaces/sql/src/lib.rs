use std::process::exit;
use std::collections::{HashSet, hash_set::IntoIter};
use prettytable::{Table, Row, format};
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use shellexpand::tilde;
use postgres::Row as PgrsRow;

use config;
use db_com;

pub fn merge_to_db(output: &String,
    cmd: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> Result<u64, String> {
    Ok(0)
}

// pub fn query(
//     payload: &str,
//     configs: &config::Config,
// ) -> Result<Table, String> {
//     Ok(Table::new())
// }

/// this should really be renamed bc its NOT ONLY for usr defined sql queries. its for making
/// any sql query that it a full query defined in a string. (provided you know the engagement that is. 
/// but the template database can be used as a default.) 
pub fn send_query(
    // prepare: &Option<String>,
    query: &str, 
    // cleanup: &Option<String>,
    engage_conf: config::EngageConf, 
    configs: &config::Config
) -> Result<Table, String> {
    let (res, titles) = sql_query(query, Some(engage_conf.name), configs)?;

    if !res.is_empty() && !titles.is_empty() {
        Ok(make_table(res))
    } else if !res.is_empty() && titles.is_empty() {
        Ok(Table::new())
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

pub fn generic_query(
    get_arg: Vec<String>, 
    // engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: config::Config,
    engage_conf: config::EngageConf
)  -> Result<Table, String> {
    let select_clause = format!("SELECT DISTINCT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    // let engagement = match engagement_arg {
    //     Some(engagement) if engagement.is_empty() => None,
    //     Some(engagement) => Some(engagement),
    //     None => Some(engage_conf.name.clone()),
    // };
    let query = match configs.targets.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, query, where_clause); 
    // target.query.replace("QUERY", &get_arg.join(", ")).replace("WHERE", &where_clause); // SELECT {select_clause}
    // println!("{}", cmd);
    send_query(&cmd, engage_conf, &configs)
}

pub fn make_sql_db(name: &str, configs: config::Config) -> Result<(), String> {
    let mut client = connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &None,
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    )?;

    let create_db = format!("CREATE DATABASE \"{}\";", name);
    match client.execute(&create_db, &[]) {
        Ok(_) => {}
        Err(mesg) => return Err(format!("could not create an sql database called \"{}\". got error:\n{}", name, mesg)),
    }
    let _ = client.close();

    let mut client = connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &Some(String::from(name)),
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    )?;
    let format_db = match std::fs::read_to_string(db_com::MAKE_SQL_DB) {
        Ok(contents) => contents,
        Err(mesg) => return Err(format!("could not read the sql database, template file. got error:\n{}", mesg)),
    };

    let res = client.batch_execute(&format_db);
    let _ = client.close();
    
    match res {
        Ok(_) => {
            println!("db created!");
            Ok(())
        }
        Err(mesg) => Err(format!("could not set up the sql database with the required tables. got error:\n{}", mesg))
    }
}

fn sql_query(
    query: &str, 
    engagement: Option<String>, 
    configs: &config::Config
) -> Result<(Vec<PgrsRow>, Vec<String>), String> {
    // println!("{:?}", engagement);
    let mut client = match connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &engagement,
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            db_com::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    let tmp_query = query.clone();
    let mut tokens = tmp_query.split(' ').into_iter();
    while let Some(token) = tokens.next() {
        if token.to_lowercase() == "select" || token.to_lowercase() == "distinct" {
            continue;
        } else if token.to_lowercase() == "from" {
            break;
        } else if token.to_lowercase() == "top"{
            tokens.next();
            continue;
        } else {
            titles.push(String::from(token));
        }
    }

    match &configs.targets.prepare {
        Some(cmds) => {let _ = client.batch_execute(cmds);},
        None => {},
    };

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    // match &configs.targets.cleanup {
    //     Some(cmds) => {let _ = client.batch_execute(cmds);},
    //     None => {},
    // };

    let _ = client.close();

    Ok((res, titles))
}

fn make_table(sql_rows: Vec<PgrsRow>) -> Table {
    let mut table = Table::new();
    table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
    // table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    // let mut titles = input_titles;
    let n_rows = sql_rows.len();
    let titles = make_title(&sql_rows[0]);
    table.set_titles(Row::from(titles));

    for sql_row in sql_rows {
        // let r= make;
        table.add_row(Row::from(make_printable_row(sql_row)));
    }
    // println!("titles : {:?}", titles);
    table

    // Print the table to stdout
    // table.printstd();
    // println!("({} rows of data)", n_rows);

    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

fn make_printable_row(sql_row: PgrsRow) -> Vec<String> {
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            format!("{}", sql_row.get::<usize, i32>(i))
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

fn make_title(sql_row: &PgrsRow) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}

pub fn connect(
    host: &String,
    user: &String,
    pass: &Option<String>,
    port: &str,
    db_name: &Option<String>,
    ssl_cert: &Option<String>,
    require_ssl: bool,
) -> Result<Client, String> {
    let mut con_config = format!("host={} user={}", host, user);
    
    if !host.starts_with("/") && !host.starts_with("~") {
        con_config = format!("{} port={}", con_config, port);
    }

    for (name, opt) in [("password", pass), ("dbname", db_name)] {
        match add_param(&con_config, name, opt) {
            Some(new_con_config) => con_config = new_con_config,
            None => {}

        }
    }

    if require_ssl {
        // this means that the connection will not be made unless ssl can be verified. 
        con_config = format!("{} sslmode=require", con_config);
    } else {
        // "sslmode" is set to "prefer" by default but this makes it explicit in my code.  
        con_config = format!("{} sslmode=prefer", con_config); 
    }

    let con = match ssl_cert {
        Some(cert_f) if !cert_f.is_empty() =>  Client::connect(&con_config, get_ssl(&tilde(cert_f))),
        _ => Client::connect(&con_config, NoTls),
    };

    match con {
        Ok(conection) => Ok(conection),
        Err(e) => {
            Err(
                format!(
                    "server connection error could not connect to sql database. got error:\n{}", e
                )
            )
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create sslconnector builder");
    builder
        .set_ca_file(ca_file)
        .expect(&format!("unable to load {}", ca_file));
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn add_param(base: &String, p_name: &str, p_opt: &Option<String>) -> Option<String> {
    match p_opt {
        Some(opt) => Some(format!("{} {}={}", base, p_name, opt)),
        None => None,
    }
}

fn get_column_names(target_name: &str, engagement_arg: Option<String>, configs: &config::Config, engage_conf: config::EngageConf) {
    let engagement = match engagement_arg {
        Some(engage) => Some(engage),
        // None => &configs.db_server.template_db,
        None => Some(engage_conf.name.clone()),
    };
    let target = match configs.targets.targets.get(target_name) {
        Some(target) => target,
        None => {
            println!("target \"{}\" is not in the config file.", target_name);
            return
        }
    };
    
    let columns = get_tables(&target);
    // println!("columns : {:?}", &columns);
    let where_clause = columns
                            .map(|x| format!("table_name = '{}'", x))
                            .collect::<Vec<String>>()
                            .join(" OR ");

    // println!("where_clause: {}", where_clause);

    let query = format!(
        "SELECT table_name, column_name FROM information_schema.columns WHERE {} ORDER BY table_name;",
        where_clause
    );
    // println!("sql query: {}", query);

    match send_query(&query, engage_conf, configs) {
        Ok(_) => {},
        Err(e) => {
            eprintln!("get_column_names() | could not get the columns for the tables from in the target: {}. got error:\n{}", query, e);
            exit(1);
        }
    };
}

fn get_tables(target: &str) -> IntoIter<&str> {
    let mut table_names: HashSet<&str> = HashSet::new();
    let tokens = target.split(' ');
    let mut last_token = "";

    for token in tokens {
        if last_token == "FROM" || last_token == "JOIN" {
            let _ = table_names.insert(token.clone());
        }
        last_token = token;
    }

    table_names.into_iter()
}