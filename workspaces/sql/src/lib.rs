use std::process::exit;
use std::collections::{HashSet, hash_set::IntoIter};
use std::collections::HashMap;
use tabled::builder::Builder;
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use shellexpand::tilde;
use postgres::Row as PgrsRow;
use chrono::prelude::*;
use clap::ArgMatches;
use config;
use db_com;

type TableRowData = HashMap<String, String>;
type PsgrsID = i32;


#[derive(Debug, Clone)]
enum TableRowType {
    Machine(TableRowData),
    DnsName(TableRowData),
    Port(TableRowData),
    WebDir(TableRowData),
    Credential(TableRowData),
}

#[derive(Debug, Clone)]
struct DBData {
    parser_uids: HashMap<String, TableRowType>,  // HashMap<parser_name, HashMap<column_name, column_value>>
    host_uids: HashMap<String, TableRowType>,  // HashMap<parser_name, HashMap<column_name, column_value>>
    table_uids: HashMap<String, String>,  // HashMap<parser_name, sql_uid>
}

impl DBData {
    fn new() -> DBData {
        DBData {
            parser_uids: HashMap::new(),
            host_uids: HashMap::new(),
            table_uids: HashMap::new()
        }
    }

    fn parse_line(&mut self, line: String) -> Result<(String, TableRowType), String> {
        let mut tokens = line.split(0 as char);
        let mut data: TableRowData = HashMap::new();
        let mut uid = String::new();
        let mut d_type = String::new();
        
        loop { 
            let col_name = match tokens.next() {
                Some(name) => name,
                None => { break }
            };
            let col_val = match tokens.next() {
                Some(val) => val,
                None => return Err(format!("parser output a key without a value from parser line {:?}", line)),
            };

            if col_name == "uid" {
                uid = col_val.to_string();
            } else if col_name == "dgraph.type" {
                d_type = col_val.to_lowercase();
            } else if !col_val.starts_with("_:") || (col_val.starts_with("_:") && col_name == "machine") { //might need tweaking
                data.insert(col_name.to_string(), col_val.to_string());
            }
        }

        if uid.is_empty() && d_type.is_empty() {
            return Err("could not find uid and data type in parser output.".to_string());
        } else if d_type.is_empty() {
            return Err("could not find data type in parser output.".to_string());
        } else if uid.is_empty() {
            return Err("could not find uid type in parser output.".to_string());
        }

        let row_type = match d_type.as_str() {
            "machine" => TableRowType::Machine(data),
            "dnsname" => TableRowType::DnsName(data),
            "port" => TableRowType::Port(data),
            "webdir" => TableRowType::WebDir(data),
            "credential" => TableRowType::Credential(data),
            _ => return Err("unknown data type found from parser.".to_string())
        };
        
        Ok((uid, row_type))
    }

    fn add_row(&mut self, line: String) -> Result<(), String> {
        if !line.is_empty() {
            let (uid, table_row) = self.parse_line(line)?; 
            match table_row {
                TableRowType::Machine(_) => self.host_uids.insert(uid, table_row),
                // TableRowType::DnsName(_) => self.host_uids.insert(uid, table_row),
                _ => self.parser_uids.insert(uid, table_row),
            };
        }
        Ok(())
    }   
}

pub fn gen_query(
    matches: &ArgMatches, 
    configs: config::Config, 
    engage_conf: config::EngageConf
) -> Result<String, String> {
    let get_args = match matches.get_many::<String>("get") {
        Some(columns) => columns.cloned().map(|x| x.replace(",", "")).collect::<Vec<String>>(),
        None => vec!["*".to_string()],
    };
    
    let res = generic_query(
        get_args,
        db_com::get_as_str(&matches, "condition", Some("")),
        db_com::get_as_str(&matches, "target", None),
        //   get_as_opt(matches, "engagement"),
        configs,
        engage_conf
        );

    match res {
        Ok(table) => Ok(table),
        Err(message) => Err(format!("[PTDB ERROR] could not query database. got error:\n{}", message)),
    }
}

/// standard entry point to use when adding data to the database.
pub fn merge_to_db(
    parser_data: &String,
    cmd: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> Result<u16, String> {
    let mut client = connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &Some(engage_conf.name.clone()),
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    )?;
    // ensure_db(&mut client, engage_conf.name);
    let cmd_uid = sync_command(&cmd, &mut client)?;
    let mut db_data = make_db_data(parser_data)?;
    let res = sync_data(&mut db_data, cmd_uid, &mut client); //, &configs, &engage_conf);

    let _ = client.close();

    match res { 
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("merge_to_db() | storing data failed with error:\n{}", mesg)),
    }
}

/// sends the SQL query stored in query to the server.
/// query should be a properly formatted SQL query.
/// returns a printable table of the servers response
pub fn send_query(
    query: &str, 
    engage_conf: &config::EngageConf, 
    configs: &config::Config
) -> Result<String, String> {
    let (res, titles) = sql_query(query, Some(engage_conf.name.clone()), configs)?;

    if !res.is_empty() && !titles.is_empty() {
        Ok(make_table(res))
    // } else if res.is_empty() && !titles.is_empty() {
        // TODO: add a linne to make a table with titles but not a rows.
    //     Ok(Table::new(res).with(Style::psql()))
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

pub fn generic_query(
    get_arg: Vec<String>, 
    // engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: config::Config,
    engage_conf: config::EngageConf
)  -> Result<String, String> {
    let select_clause = format!("SELECT DISTINCT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    // let engagement = match engagement_arg {
    //     Some(engagement) if engagement.is_empty() => None,
    //     Some(engagement) => Some(engagement),
    //     None => Some(engage_conf.name.clone()),
    // };
    let query = match configs.targets.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, query, where_clause); 
    // target.query.replace("QUERY", &get_arg.join(", ")).replace("WHERE", &where_clause); // SELECT {select_clause}
    println!("{}", cmd);
    send_query(&cmd, &engage_conf, &configs)
}

pub fn make_new_sql_db(name: &str, configs: config::Config) -> Result<(), String> {
    let mut client = connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &None,
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    )?;

    let create_db = format!("CREATE DATABASE \"{}\";", name);
    match client.execute(&create_db, &[]) {
        Ok(_) => {}
        Err(mesg) => return Err(format!("could not create an sql database called \"{}\". got error:\n{}", name, mesg)),
    }
    let _ = client.close();

    let mut client = connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &Some(String::from(name)),
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    )?;
    let format_db = match std::fs::read_to_string(db_com::MAKE_SQL_DB) {
        Ok(contents) => contents,
        Err(mesg) => return Err(format!("could not read the sql database, template file. got error:\n{}", mesg)),
    };

    let res = client.batch_execute(&format_db);
    let _ = client.close();
    
    match res {
        Ok(_) => {
            println!("db created!");
            Ok(())
        }
        Err(mesg) => Err(format!("could not set up the sql database with the required tables. got error:\n{}", mesg))
    }
}

pub fn get_column_names(
    target_name: &str, 
    configs: &config::Config, 
    engage_conf: config::EngageConf
) -> Result<String, String> {
    let target = match configs.targets.targets.get(target_name) {
        Some(target) => target,
        None => {
            println!("target \"{}\" is not in the config file.", target_name);
            exit(0);
        }
    };
    
    let columns = get_tables(&target);
    // println!("columns : {:?}", &columns);
    let where_clause = columns
                            .map(|x| format!("table_name = '{}'", x))
                            .collect::<Vec<String>>()
                            .join(" OR ");

    // println!("where_clause: {}", where_clause); // debug

    let query = format!(
        "SELECT table_name, column_name FROM information_schema.columns WHERE {} ORDER BY table_name;",
        where_clause
    );
    // println!("sql query: {}", query); // debug 

    send_query(&query, &engage_conf, configs)
}



/* 
 * UTILITY FUNCTIONS
 */

/// used to generate a connection to the sql server. returns an Client object.
pub fn connect(
    host: &String,
    user: &String,
    pass: &Option<String>,
    port: &str,
    db_name: &Option<String>,
    ssl_cert: &Option<String>,
    require_ssl: bool,
) -> Result<Client, String> {
    // println!("host = {}", host); // debug 
    let mut con_config = format!("host={} user={}", host, user);
    
    if !host.starts_with("/") && !host.starts_with("~") {
        con_config = format!("{} port={}", con_config, port);
    }

    for (name, opt) in [("password", pass), ("dbname", db_name)] {
        match add_param(&con_config, name, opt) {
            Some(new_con_config) => con_config = new_con_config,
            None => {}

        }
    }

    if require_ssl {
        // this means that the connection will not be made unless ssl can be verified. 
        con_config = format!("{} sslmode=require", con_config);
    } else {
        // "sslmode" is set to "prefer" by default but this makes it explicit in my code.  
        con_config = format!("{} sslmode=prefer", con_config); 
    }

    let con = match ssl_cert {
        Some(cert_f) if !cert_f.is_empty() =>  Client::connect(
            &con_config, 
            get_ssl(&tilde(cert_f))
        ),
        _ => Client::connect(&con_config, NoTls),
    };

    match con {
        Ok(conection) => Ok(conection),
        Err(e) => {
            Err(
                format!(
                    "server connection error could not connect to sql database. got error:\n{}", e
                )
            )
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

/// helper function for connect(). used to add a parameter-value pair to the connection.
/// eg, "sslmode=required". it is encoded the same way that it would be when calling psql 
/// from the command line.
fn add_param(base: &String, p_name: &str, p_opt: &Option<String>) -> Option<String> {
    match p_opt {
        Some(opt) => Some(format!("{} {}={}", base, p_name, opt)),
        None => None,
    }
}

/// helper function for connect(). used to make the need ssl cert if ssl is enabled.
fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create SslConnector builder");
    builder
        .set_ca_file(ca_file)
        .expect(&format!("unable to load {}", ca_file));
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn get_tables(target: &str) -> IntoIter<&str> {
    let mut table_names: HashSet<&str> = HashSet::new();
    let tokens = target.split(' ');
    let mut last_token = "";

    for token in tokens {
        if last_token == "FROM" || last_token == "JOIN" {
            let _ = table_names.insert(token.clone());
        }
        last_token = token;
    }

    table_names.into_iter()
}

/// used to generate a printable table out of sql rows.
fn make_table(sql_rows: Vec<PgrsRow>) -> String {
    let mut builder = Builder::default();

    let titles = make_title(&sql_rows[0]);
    builder.set_columns(titles);
    
    for row in &sql_rows {
        builder.add_record(make_printable_row(row));
    }

    db_com::print_table(builder)

    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

// /// used to generate a printable table out of sql rows.
// fn make_table(sql_rows: Vec<PgrsRow>) -> Table {
//     let mut table = Table::new();
//     table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
//     // table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
//     // let mut titles = input_titles;
//     // let n_rows = sql_rows.len();
//     let titles = make_title(&sql_rows[0]);
//     table.set_titles(Row::from(titles));

//     for sql_row in sql_rows {
//         // let r= make;
//         table.add_row(Row::from(make_printable_row(sql_row)));
//     }
//     // println!("titles : {:?}", titles);
//     table

//     // or print in csv format if being piped or redirected into something else.
//     /*
//     let writer = /* create a writer */;
//     table.to_csv_writer(writer)?; 
//     */
// }

/// helper function for make_table(). is used to get a list of the names of each 
/// column. to use to create the title line. 
fn make_title(sql_row: &PgrsRow) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}

/// helper function for make_table(). used to make a row in the printable table out of 
/// a postgres row form the server response. 
fn make_printable_row(sql_row: &PgrsRow) -> Vec<String> {
    // println!("{:?}", sql_row);
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name().to_lowercase();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            // println!("varchar");
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            match sql_row.get::<usize, Option<i32>>(i) {
                Some(n) => format!("{n}"),
                None => String::new(),
            }
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            // println!("default");
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

/// sends an sql query (from the "query" param) to the server described in the "configs" 
/// and "engagement" params.
fn sql_query(
    query: &str, 
    engagement: Option<String>, 
    configs: &config::Config
) -> Result<(Vec<PgrsRow>, Vec<String>), String> {
    // println!("{:?}", engagement);
    let mut client = match connect(
        &configs.db_server.host,
        &configs.db_server.user,
        &configs.db_server.passwd,
        &configs.db_server.port,
        &engagement,
        &configs.db_server.ssl_cert,
        configs.db_server.require_ssl,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            db_com::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    let tmp_query = query.clone();
    let mut tokens = tmp_query.split(' ').into_iter();
    while let Some(token) = tokens.next() {
        if token.to_lowercase() == "select" || token.to_lowercase() == "distinct" {
            continue;
        } else if token.to_lowercase() == "from" {
            break;
        } else if token.to_lowercase() == "top"{
            tokens.next();
            continue;
        } else {
            titles.push(String::from(token));
        }
    }

    match &configs.targets.prepare {
        Some(cmds) => {let _ = client.batch_execute(cmds);},
        None => {},
    };

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    let _ = client.close();

    Ok((res, titles))
}

/// formats an insert command for the SQL table to insert cnames and cval data into table. 
/// cnames must be a list of the columns names, and cvals must be the vales to insert into 
/// the corresponding column.
fn make_insert(table: &str, cnames: &[&str], cvals: &[&str]) -> String {
    format!("INSERT INTO {table} ({}) VALUES ({});", cnames.join(", "), cvals.join(", "))
}

/// loads the command that was run into the database. returning the commands uid in the database. 
fn sync_command(
    cmd: &str,
    client: &mut Client,
    // configs: &config::Config,
    // engage_conf: &config::EngageConf,
) -> Result<PsgrsID, String> {
    let time: DateTime<Local> = Local::now();
    let cmd = format!("'{}'", cmd);
    let cmd_insert = make_insert(
        "commands", 
        &vec!["command", "local_time"],
        &vec![cmd.as_str(), format!("'{}'", time).as_str()],
    );
    // println!("(sync_command) insert cmd :  {cmd_insert}");
    let query = format!("SELECT id FROM commands WHERE local_time = '{time}';");
    
    match client.execute(&cmd_insert, &[]) {
        Ok(_) => {
            match client.query_one(&query, &[]) {
                Ok(row) => Ok(row.get("id")),
                Err(e) => Err(format!("failed to query for command in database, got error: {e}"))
            }
        }
        Err(e) => Err(format!("could not insert command to database, got error: {e}"))
    }
}

/// used to generate a rust struct that represents the data from the parser output.
fn make_db_data(
    parsed_cmd: &str,
    // cmd_uid: PsgrsID,
) -> Result<DBData, String> {
    let mut uids = DBData::new();

    for line in parsed_cmd.split("\n") {
        uids.add_row(line.to_string())?;
    } 

    Ok(uids)
}

fn machine_id(data: &TableRowData) -> Result<String, String> {
    match data.get("ip") {
        Some(id) => Ok(id.clone()),
        None => {
            match data.get("ipv6") {
                Some(id) => Ok(id.clone()),
                None => {
                    match data.get("local_name") {
                        Some(id) => Ok(id.clone()),
                        None => {
                            println!("{:#?}", data);
                            Err("the parser output a line defining a machine with no ip, ipv6, or dns_name. ptdb can't locate the host in the database.".to_string())
                        }
                    }
                }
            }
        }
    }
}

/// used to send data to the SQL server. if successful it returns the number of rows modified/added.
// TODO: add cmd_uid to all table_row.
fn sync_data(
    db_data: &mut DBData,
    cmd_uid: PsgrsID,
    client: &mut Client,
    // configs: &config::Config,
    // engage_conf: &config::EngageConf,
) -> Result<u16, String> {
    let mut n_rows: u16 = 0;
    // add to machine table and get table uids for machines
    for (parser_id, table_row) in db_data.host_uids.clone() {
        // check if i need to add the machine.
        // if machine exists, modify row.
        // if machine not exist, add.
        // add sql_uid to db_data
        match table_row {
            TableRowType::Machine(data) => {
                let id = machine_id(&data)?;
                let identifiers = vec![id];
                let (sql_uid, n) = add_row("machines", "get_machine", &data, cmd_uid,&db_data.table_uids, identifiers, client)?;
                n_rows += n;
                db_data.table_uids.insert(parser_id, format!("{sql_uid}"));
            }
            _ => {}
        };
    }

    for (parser_id, table_row) in db_data.host_uids.clone() {
        match table_row {
            TableRowType::DnsName(data) => {
                // let id = match data.get("dns_name") {
                //     Some(id) => id,
                //     None => {
                //         return Err("the parser output a dns name definition with no name. ptdb can't locate the host in the database.".to_string());
                //     }
                // }.clone();
                // let machine = machine_id(&data)?;
                // let identifiers = vec![id, machine];
                let identifiers = get_ids(&["dns_name", "machine"], &data, &db_data.table_uids)?;
                let (sql_uid, n) = add_row("dns_names", "get_dns_name", &data, cmd_uid,&db_data.table_uids, identifiers, client)?;
                n_rows += n;
                db_data.table_uids.insert(parser_id, format!("{sql_uid}"));
            }
            _ => {}
        }
    }

    // add other tables and point to machine (if needed)
    for (_parser_id, table_row) in db_data.parser_uids.clone() {
        let (ids, table, func, row_data) = match table_row {
            TableRowType::Machine(_) => continue,
            // TableRowType::DnsName(data) => {
            //     let ids = get_ids(&["dns_name", "machine"], &data, &db_data.table_uids)?;
            //     (ids, "dns_names", "get_dns_name", data)
            // },
            TableRowType::DnsName(_) => continue, 
            TableRowType::Port(data) => {
                let ids = get_ids(&["port", "machine"], &data, &db_data.table_uids)?;
                (ids, "ports", "get_port", data)
            },
            TableRowType::WebDir(data) => {
                let ids = get_ids(&["url"], &data, &db_data.table_uids)?;
                (ids, "web_dirs", "get_web_dir", data)
            },
            TableRowType::Credential(data) => {
                let ids = get_ids(&["username", "password", "machine"], &data, &db_data.table_uids)?;
                (ids, "creds", "get_cred", data)
            },
        };
        let (_, n) = add_row(table, func, &row_data, cmd_uid, &db_data.table_uids, ids, client)?;
        n_rows += n;
    }
    
    Ok(n_rows)
}

fn get_ids(
    id_names: &[&str],
    row: &TableRowData,
    machines: &HashMap<String, String>,
) -> Result<Vec<String>, String> {
    let mut identifiers = Vec::new();
    // id_names.iter().map(|name| identifiers.push(row.get(&name.to_string())));
    for name in id_names {
        // println!("{name}");  // debug
        // println!("{:#?}", row);  // debug
        match row.get(&name.to_string()) {
            Some(row_id) => {
                let id = if row_id.starts_with("_:machine") {
                    // println!("machines => {:?}", machines);  // debug
                    match machines.get(row_id) {
                        Some(m_sql_id) => m_sql_id,
                        None => return Err(format!("machine \"{row_id}\" not added to database yet.")) 
                    }
                } else {
                    row_id
                };
                identifiers.push(id.clone());
            },
            None => return Err(format!("could not find id {name} value in parser output.")) 
        }
    }

    Ok(identifiers)
}

/// used to add a row to the sql database. returns the sql id of the added line and the number of lines modified if successful.
fn add_row(
    table: &str,
    func: &str,
    row: &TableRowData,
    cmd_uid: PsgrsID,
    sql_ids: &HashMap<String, String>,
    identifiers: Vec<String>,
    client: &mut Client
) -> Result<(PsgrsID, u16), String> {
        let mut n_rows = 0;
        // check if i need to add the machine.
        // let identifiers = get_ids(id_names, row,sql_ids)?;

        let cmd = format!("{cmd_uid}");
        let mut c_names: Vec<&str> = Vec::new();
        let mut c_vals: Vec<&str> = Vec::new();
    
        for (name, val) in row {
            if !val.starts_with("_:machine") {
                c_names.push(name);
                c_vals.push(val);
            } else {
                c_names.push("machine_uid");
                match sql_ids.get(val) {
                    Some(sql_id) => c_vals.push(sql_id),
                    None => return Err("that machine is not known, yet.".to_string()),
                }
            }
        }
    
        let mut eq = Vec::new();
        for (key, value) in std::iter::zip(c_names.clone(), c_vals.clone()) {
            eq.push(format!("{} = {}", key, value));
        }

        // does entry exist?
        let query = format!("SELECT {func}({});", identifiers.join(", "));
        // println!("query => {}", query);  // debug

        match client.query(&query, &[]) {
            Ok(res) => {
                match res.last() {
                    Some(sql_row) if sql_row.get::<usize, i32>(0) != -1 => {
                        // if machine exists, modify row.
                        let sql_uid: PsgrsID = sql_row.get(0);
                        let _ = client.execute(&format!("UPDATE {table} SET {} WHERE id = {sql_uid};", eq.join(", ")), &[]);
                        // n_rows += 1;
                        Ok((sql_uid, n_rows))
                    }
                    // None | Some(sql_row) if sql_row.get(0) = 0 => {
                    _ => {
                        // if machine not exist, add.
                        c_names.push("command_uid");
                        c_vals.push(cmd.as_str());
                        let insert_cmd = make_insert(table, &c_names, &c_vals);
                        // println!("insert_cmd => {}", insert_cmd);  // debug
                        match client.execute(&insert_cmd, &[]) {
                            Ok(_) => {
                                n_rows += 1;
                                let uid_query = format!("SELECT id FROM {table} WHERE {};", eq.join(" AND "));
                                // println!("uid_query => {uid_query}");  // debug
                                match client.query(&uid_query, &[]) {
                                    Ok(res) => Ok((res[0].get(0), n_rows)),
                                    Err(e) => Err(format!("could not query for the added data database. got error: {e}."))
                                }
                            }
                            Err(e) => Err(format!("could not insert new data into the database. got error: {e}.")),
                        }
                    }
                }
            }
            Err(e) => Err(format!("could not communicate with the database. got error: {e}.")),
        }
}