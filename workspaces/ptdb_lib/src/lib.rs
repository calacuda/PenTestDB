use std::thread;
use std::process::{exit, Command, Stdio};
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use shellexpand::tilde;
use clap::ArgMatches;
// use prettytable::Table;
use db_com;

use sql;
use graphql;

/// this assumes that the lines in log are formatted as follows:
/// 1: <exit status>
/// 2: <first version of the command>
/// 3: <second version of the command>
/// 4: <third version of the command>
/// 5: <1st line of program output>
/// 6. <2nd line of program output>
/// 7. ...
pub fn process_raw_input(
    input_log: String,
    quiet: bool, 
    cmd: Option<&String>, 
    configs: config::Config, 
    engage_conf: config::EngageConf,
) -> Result<String, String> {
    // if log.lines().count() < 3 && log.lines().count() > 1 {
    //     return Ok(format!("only {} versions of the command were provided. program expects all three verisons that are passed to preexec.", log.lines().count()));
    // } else 
    if input_log.lines().count() < 4 {
        return Ok(String::new());
    }

    let (exit_status, log) = match input_log.split_once('\n') {
        Some((es, log)) => (es.parse::<i32>().unwrap(), log.to_string()),
        None => return Err("could not extract exit status".to_string()), 
    };

    let (commands, log_data) = match cmd {
        Some(cmd) => {
            match get_cmd(&format!("{}\n{}\n{}\n", cmd, cmd, cmd)) {
                Ok((cmds, _)) => (cmds, log),
                Err(_e) => {
                    println!("got error while parsing ");
                    exit(1)
                }                
            }
        }
        None => {
            match get_cmd(&log) {
                Ok(res) => res,
                Err(_e) => {
                    println!("could not figure out what command was run.");
                    exit(1);
                }
            }
        }
    };
    
    return if !engage_conf.complete {  // needed for when running in server mode.
        // add date-time check and turnning off of "complete flag" here as a conditional
        // println!("before run_parser");  //debug
        match run_parsers(commands, exit_status, log_data, configs, engage_conf, quiet) {
            Ok((entities, rows)) => {
                let encouragement = if rows > 0 {
                    "great job, keep it up! ðŸŽ‰"
                } else {
                    "nothing new. ðŸ˜”"
                };

                let message = if entities > 0 {
                    format!("parsed {} entities from output", entities)
                } else {
                    String::from("no info from parser")
                };

                Ok(format!("*** {}. added/modded ~{} db rows. {} ***", message, rows, encouragement))
            },
            Err(mesg) => Err(mesg),
        }
    } else {
        Ok("the engagement is complete. not parsing.".to_string())
    };
    // println!("done");
}


/// entry point to parsing when runnign as a server.
pub fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

pub fn get_data_names(
    matches: &ArgMatches,
    configs: config::Config, 
    engage_conf: config::EngageConf
) -> String {
    let col_names = match configs.db_server.db_type {
        config::DBType::SQL => {
            sql::get_column_names(
                &db_com::get_as_str(matches, "", None), 
                &configs, 
                engage_conf
            )
        },
        config::DBType::GraphQL => Ok("under construction".to_string()),
    };

    match col_names {
        Ok(names) => names,
        Err(mesg) => format!("could not get the columns for that target. got error:\n{mesg}"),
    }
}

pub fn send_query(query: &str, configs: &config::Config, engage_conf: &config::EngageConf) -> String {
    // println!("db_type {:?}", configs.db_server.db_type);  // debug
    let res = match configs.db_server.db_type {
        config::DBType::GraphQL => {
            // TODO: add: graphql::send_query(query, configs);  (but make it work).
            Err("under construction".to_string())
        },
        config::DBType::SQL => sql::send_query(query, &engage_conf, configs)
    };

    match res {
        Ok(table) => table,
        Err(mesg) => mesg, 
    }
}

pub fn gen_query(
    matches: &ArgMatches, 
    _engagement: &str, 
    configs: config::Config, 
    engage_conf: config::EngageConf
) -> String{
    let res = match configs.db_server.db_type {
        config::DBType::SQL => sql::gen_query(matches, configs, engage_conf),
        config::DBType::GraphQL => {
            // TODO: add: graphql::send_query(query, configs);  (but make it work).
            Err("under construction".to_string())
        },
    };

    match res {
        Ok(table) => table,
        Err(mesg) => mesg, 
    }
}

///
fn handle_client(mut stream: UnixStream) {
    let configs = config::get_config();
    let engage_conf = config::get_engagement(config::ENGAGEMENT_ADR);
    // let (commands, log_data) = get_cmd(&read_log(&mut stream));
    match process_raw_input(read_log(&mut stream), configs.server_mode.quiet_logs, None, configs, engage_conf) {
        Ok(mesg) => {
            if !mesg.is_empty() {
                println!("{}", mesg);
            }
        }
        Err(mesg) => println!("[PTDB ERROR] could not add to database. got error:\n{}", mesg),
    };
    drop(stream);
}

/// 
fn run_parsers(
    commands: Vec<String>,
    exit_status: i32,
    log_data: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
    quiet: bool
) -> Result<(usize, u16), String> {
    let parsers = &configs.parsers;
    let (command, parser, poe) = match get_parser(&commands, parsers) {
        Some((command, parser, poe)) => (command, parser, poe),
        None => {
            // println!("could not find parser");
            exit(1);
        }
    }; // poe means Parse On Error

    if !poe && exit_status != 0 {
        exit(0)
    }
    
    // println!("parsers {:?}", configs.parsers);
    let parser_adr = 
        Path::new(&tilde(db_com::PARSERS_DIR).to_string())
        .to_owned()
        .join(parser);
        db_com::console_log(&format!("using parser at adr => {:#?}", parser_adr), quiet);

    return if parser_adr.exists() {
        parse(&parser_adr, log_data, command.clone(), configs, engage_conf)
        // println!("parsed output or command: {:?}", command);
    } else {
        Err(format!(
            "run_parsers() | parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        ))
    }
}

///
fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config::ParserConf>>,
) -> Option<(String, String, bool)> {
    // println!("get_parser");
    // let mut message = String::new();

    for i in 0..3 {
        // println!("command => {}", commands[2 - i]); // debug
        let cmd: String = commands[2 - i].clone();
        let mut tmp_cmd: Vec<String> = cmd.split(' ').map(|x| x.to_string()).collect();
        tmp_cmd.reverse();
        let mut exec: String;
        let given_args: Vec<String>;

        loop {
            // let (exec, given_args): (String, Vec<String>) = match cmd {
            //     Some((exec, args)) => (
            //         exec.to_string(),
            //         args.split(' ').map(|x| x.to_string()).collect(),
            //     ),
            //     None => (cmd.clone(), Vec::new()),
            // };
            // let (exec, given_args) = (String::from(cmd[0]), cmd[1..].collect());
            exec = match tmp_cmd.pop() {
                Some(exec) => exec,
                None => {return None}
            };

            if !exec.starts_with("-") {
                tmp_cmd.reverse();
                given_args = tmp_cmd;
                break;
            }
        }

        // println!("exec = {}", exec); // debug
        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Some((cmd.clone(), parser.parser.clone(), parser.parse_on_error));
                        }
                    }
                }
            }

            match default {
                Some(parser) if !help_args(&given_args, &parser.help) => return Some((cmd.clone(), parser.parser.clone(), parser.parse_on_error)),
                _ => {}
            }
        }
        // message = format!("a parser for {} is not in config file.", exec)
    }
    // Err(message)
    None
}


/// 
fn get_default_parser(parsers: &Vec<config::ParserConf>) -> Option<&config::ParserConf> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser),
        }
    }
    None
}

fn help_args(
    given_args: &[String],
    arg_set: &[String], // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if given_args.contains(arg) {
            // println!("arg not contained {}", arg.to_string());
            return true;
        }
    }
    false
}

/// 
fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
    }
    true
}

/// 
fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config::Config,
    engage_conf: config::EngageConf,
) -> Result<(usize, u16), String> {
    // println!("parser => {} => {}", parser.display(), parser.exists());
    let mut child = match Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn() {
            Ok(proc) => proc,
            Err(e) => return Err(format!("parse() | Spawning child process failed with error:\n{}", e))
        };
        // .expect("Failed to spawn child process");
    // println!("log_data: {}\n{log_data}", log_data.split("\n").collect::<Vec<&str>>().len());  // debug
    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let std_out = child
    .wait_with_output()
    .expect("Failed to read output of parser")
    .stdout;

    let output = String::from_utf8(
        std_out  // .clone(),
    ).unwrap();
    // output = &output.stdout;
    // println!("{}", std_out.into_iter().filter(|x| x.to_owned() == 10 as u8).collect::<Vec<u8>>().len());  // debug
    // println!("output len: {}", output.split("\n").collect::<Vec<&str>>().len());  // debug
    // println!("output: \n{:#?}", output.split("\n").collect::<Vec<&str>>());  // debug

    return if !output.is_empty() {
        //do SQL stuff with output.
        match config.db_server.db_type {
            config::DBType::GraphQL => {
                match graphql::merge_to_db(&output, cmd.clone(), config, engage_conf) {
                    Ok(n) => Ok((output.lines().count(), n)),
                    Err(e) => Err(format!("parse() | merging data from command '{}', failed with error:\n{}", cmd, e)),
                }
            }
            config::DBType::SQL => {
                match sql::merge_to_db(&output, cmd.clone(), config, engage_conf) {
                    Ok(n) => Ok((output.lines().count(), n)),
                    Err(e) => Err(format!("parse() | merging data from command '{}', failed with error:\n{}", cmd, e)),
                }
            }
        }
    } else {
        Ok((output.lines().count(), 0))
    }
}

/// used to read the log data when in server mode.
fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

/// handles figuring out what command the output belongs to.
fn get_cmd(log_data: &String) -> Result<(Vec<String>, String), String> {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(
                    dat.0
                        .replace("sudo ", "")
                        .replace("doas ", "")
                        .replace("time ", "")
                        .replace("proxychains ", "")
                        .trim()
                        .to_string(),
                );
                dat.1.to_owned()
            }
            None => return Err(String::new()),
            // None => return Err(format!("not enough lines found. {:?}", log_data)),
        }
    }

    // cmd_names.map(|s| s.replace("sudo" "").replace("doas", "").replace("time", "").trim());
    Ok((cmd_names, tmp_log))
}