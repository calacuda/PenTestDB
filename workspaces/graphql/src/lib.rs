#![warn(clippy::all)]
use chrono::prelude::*;
use config;
use prettytable::Table;
// use prettytable::{Table, Row, format};

type GraphNames = Vec<String>;
type GraphValues = Vec<String>;
type GraphAssociaions = (GraphNames, GraphValues);

#[derive(Debug)]

enum DGType {
    Machine(GraphAssociaions),
    WebDir(GraphAssociaions),
    Credential(GraphAssociaions),
    DSNName(GraphAssociaions),
    // Command(GraphAssociaions),
    Port(GraphAssociaions),
}

pub fn send_query(
    payload: &str,
    configs: &config::Config,
) -> Result<Table, String> {
    let server_res = com_with_db(payload, "/query", "application/dql", configs)?;
    Ok(Table::new())
}

/// entry point. used to merge data to the dgraph server.
pub fn merge_to_db(
    output: &String,
    cmd: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> Result<u64, String> {
    let res = store_data(output, cmd, &configs, engage_conf);

    return match res { 
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("merge_to_db() | storing data failed with error:\n{}", mesg)),
    }
}

fn parse_output(line: String, engage_name: &str) -> Result<DGType, String> {
    // let tmp_line = line.clone();
    let mut params: GraphAssociaions = (Vec::new(), Vec::new());
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    let mut dg_type = "";
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        // println!("tokens {:?}", &tokens);
        return Err("[PTDB ERROR] every key needs a value!".to_string());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.0.push(key.to_string());
        params.1.push(value.to_string());
        if key == "dgraph.type" {
            dg_type = value;
        }
    }
    
    params.0.push("command".to_string());
    params.1.push("_:command_0".to_string());
    params.0.push("engagement".to_string());
    params.1.push(engage_name.to_string());

    Ok(match dg_type {
        "Machine" => DGType::Machine(params),
        "Port" => DGType::Port(params),
        "WebDir" => DGType::WebDir(params),
        "DNSName" => DGType::DSNName(params),
        "Credential" => DGType::Credential(params),
        _ => return Err(String::from("no type was specified byt the parser.")),
    })
}

fn add_command_engagement(
    cmd: &str, 
    _queries: &mut Vec<String>,
    mutations: &mut Vec<String>,
    engage_conf: config::EngageConf
) {
    let time: DateTime<Local> = Local::now();

    let command_add = "\tmutation {
        set {
            _:command_0 <Command.command> \"<CMD>\" . 
            _:command_0 <Command.local_time> \"<TIME>\" . 
            _:command_0 <dgraph.type> \"Command\" .  
            _:command_0 <Command.engagement> \"<ENGAGEMENT>\" .  
        }
    }
    "
    .replace("<ENGAGEMENT>", &engage_conf.name)
    .replace("<CMD>", &cmd)
    .replace("<TIME>", 
        &format!("{}", time)
        .replacen(" ", "T", 1)
        .replace(" ", "")
    )
    .to_string();
    mutations.push(command_add);
}

fn store_data(
    output: &String, 
    cmd: String, 
    configs: &config::Config, 
    engage_conf: config::EngageConf
) -> Result<u64, String> { 
    
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    let engage_name = engage_conf.name.clone();
    // println!("line => ^{:?}?", tmp_output);
    let mut predicates: Vec<DGType> = Vec::new();
    let mut queries: Vec<String> = Vec::new();
    let mut mutations: Vec<String> = Vec::new();

    add_command_engagement(&cmd, &mut queries, &mut mutations, engage_conf);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        // let mut predicate: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string(), &engage_name) {
            Ok(types) => types,
            Err(e) => return Err(format!("store_data() | could not understand the output of the parser. error on key: '{}'. got error:\n{}",
            line, e))
        };
        // let mut data = HashMap::new();
        predicates.push(params);
        // predicates.push(data);
    }
    // println!("predicates => {:?}", predicates);

    make_query_mut(&engage_name, predicates, &mut queries, &mut mutations, configs);

    let mut update_text = String::from("\nquery {");
    for line in queries {
        update_text = format!("{}\n{}", update_text, line);
    }
    update_text = format!("{}\n}}", update_text);
    for line in mutations {
        update_text = format!("{}\n{}", update_text, line);
    }
    // println!("UPDATE TEXT:\n{}\n\n", update_text);
    update_text = format!("upsert {{{}}}", update_text);
    
    return match send_to_db(&update_text, configs) {
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("store_data() | sending data to db failed with error:\n{}", mesg)),
    };
}

fn get_machine_id(data: &GraphAssociaions) -> Option<String> {
    for id_name in ["ip", "ipv6", "local_name"] {
        match get_item(id_name, &data) {
            Some(id) => return Some(id),
            None => {},
        }
    }
    return None;
}

fn get_item(name: &str, data: &GraphAssociaions) -> Option<String> {
    let id_i = data.0.iter().position(|x| x == &name)?;
    return Some(data.1[id_i].clone());
}

fn add_query_mutations(
    d_type: &str,
    engage_name: &str,
    data: &GraphAssociaions,
    compare_value: Option<String>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>, 
    configs: &config::Config,
) -> Option<()> {
    let machine_name = match get_item("machine", data) {
        Some(dat) => dat.replace("_:", ""),
        None => "".to_string(),
    };
    let host_name = match get_item("host", data) {
        Some(dat) => dat,
        None => "".to_string(),
    };
    let add_name = get_item("uid", data)?.replace("_:", "");
    
    // if d_type == "Port" {
    //     println!("port uid => {}", add_name);
    // } // debug
    
    let templates = configs.templates.mutations.get(d_type)?;
    
    let mut query = templates.query
                        .replace("<MACHINE_NAME>", &machine_name)
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ENGAGEMENT>", &format!("\"{}\"", engage_name))
                        .replace("<ADD_NAME>", &add_name);
    query = match compare_value {
        Some(comp_val) => query.replace("<COMP_VAL>", &if d_type != "Port" {comp_val} else {format!("\"{}\"", comp_val)}),
        None => query, 
    };
    query = format!("q{}{}", queries.len(), query);
    // println!("query: {:?}\n", query); // debug
    queries.push(query);
    // println!("queries: {:?}\n", queries); // debug


    let rdf_add = configs.templates.rdf_add_line.clone();
    let rdf_update = configs.templates.rdf_update_line.clone();
    let rdf_types = configs.templates.rdf_types.clone();
    let mut rdf_lines_add = String::new();
    let mut rdf_lines_update = String::new();

    for i in 0..data.0.len() {
        let (name, value) = (data.0[i].clone(), data.1[i].clone());
        if name == "uid" {
            continue
        }
        let var_name = if !name.starts_with("dgraph") { format!("{}.{}", d_type, name) } else { name };
        let var_type = if vec!["is_cname"].contains(&var_name.as_str()) {
            rdf_types.boolean.clone()
        } else if vec!["res_code", "port"].contains(&var_name.as_str()) {
            rdf_types.integer.clone()
        } else {
            "".to_string()
        };

        let tmp_value = if value.starts_with("_:") {
            value
        } else {
            format!("\"{}\"", value)
        };

        let add_line = rdf_add
                    .replace("<ADD_NAME>", &add_name)
                    .replace("<VAR_NAME>", &var_name)
                    .replace("<VALUE>", &tmp_value)
                    .replace("<VAR_TYPE>", &var_type);
        
        let update_line = rdf_update
                    .replace("<ADD_NAME>", &add_name)
                    .replace("<VAR_NAME>", &var_name)
                    .replace("<VALUE>", &tmp_value)
                    .replace("<VAR_TYPE>", &var_type);

        rdf_lines_update = format!("{}\n\t{}", rdf_lines_update, update_line);

        rdf_lines_add = format!("{}\n\t{}", rdf_lines_add, add_line);
    } 

    let add_mutate = templates.add_mutate
                        .replace("<MACHINE_NAME>", &machine_name)
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ADD_NAME>", &add_name)
                        .replace("<ADD_RDF>", &rdf_lines_add)
                        .replace("<UPDATE_RDF>", &rdf_lines_update);
    let mod_mutate = templates.mod_mutate
                        .replace("<MACHINE_NAME>", &machine_name)   
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ADD_NAME>", &add_name);
    mutations.push(add_mutate);
    mutations.push(mod_mutate);

    Some(())
}

fn make_query_mut(
    engage_name: &str,
    predicates: Vec<DGType>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>, 
    configs: &config::Config,
) {
    // println!("{:?}", predicates);
    for graph_data in &predicates {
        
        match &graph_data {
            &DGType::Machine(dat) =>  {
                add_query_mutations("Machine", engage_name, &dat, get_machine_id(dat), queries, mutations, configs);
            },
            &DGType::Port(dat) => {
                add_query_mutations("Port", engage_name, &dat, get_item("port", dat), queries, mutations, configs);
            },
            &DGType::WebDir(dat) => {
                add_query_mutations("WebDir", engage_name, &dat, get_item("dir", dat), queries, mutations, configs);
            },
            &DGType::DSNName(dat) => {
                add_query_mutations("DNSName", engage_name, &dat, get_item("name", dat), queries, mutations, configs);
            }
            &DGType::Credential(dat) => {
                // TODO: make a custom way to query for credentials. 
                add_query_mutations("Credential", engage_name, &dat, get_item("", dat), queries, mutations, configs);
            }
        };
    }
    // println!("query => {:?}", queries);
}

fn com_with_db(
    payload: &str,
    folder: &str,
    content_type: &str,
    configs: &config::Config,
) -> Result<serde_json::Value, String> {
    // eprintln!("update_text => {}", update_text);

    let client = reqwest::blocking::Client::new();
    let url = format!("{}{}", configs.db_server.host, folder);
    // println!("url => {}", url);
    let raw_res = client.post(url)
        .header(reqwest::header::CONTENT_TYPE, content_type)
        .body(payload.to_owned())
        .send()
        .expect("could not communicate with the servers")
        .text();
    // println!("raw_res => {}", raw_res);
    // println!("{}", raw_res);
    match raw_res {
        Ok(res) => {
            println!("{}", res);
            match serde_json::from_str(&res) {
                Ok(res) => Ok(res),
                Err(m) => Err(format!("could not parse json from the server. got error\n{}", m)),
            }
        }
        Err(m) => Err(format!("could not comunicate with the server. got error\n{}", m))
    }
}

fn send_to_db(
    update_text: &str,
    configs: &config::Config,
) -> Result<u64, String> {
    let mut n_changes = 0;
    let res = com_with_db(update_text, "/mutate?commitNow=true", "application/rdf", configs)?;
    // println!("{}", res);
    match res.get("data").expect("no data").get("uids").expect("no uids") {
        serde_json::Value::Object(dat) => {n_changes += dat.len() - 1},
        _ => {},
    };
    // println!("number of changes :  {:?}", n_changes);
    Ok(n_changes as u64)
}