#![warn(clippy::all)]
use figment::{
    providers::{Format, Toml},
    Figment,
};
// use openssl::conf::Conf;
use serde::Deserialize;
use serde::Serialize;
use shellexpand::tilde;
use std::{collections::HashMap};
use std::process::exit;

// use crate::server_mode;

// #[derive(Deserialize, Serialize, Debug)]
// pub struct SQLConf {
//     pub user: String,
//     pub host: String,
//     pub passwd: Option<String>,
//     pub port: Option<String>,
//     pub ssl_cert: Option<String>,
//     pub null_val: String,
//     // pub template_db: String,
//     pub require_ssl: Option<bool>,
// }

// #[derive(Deserialize, Serialize, Debug)]
// pub struct ServerConf {
//     pub socket: String,
//     // pub ssh_mode: bool,
//     // pub ftp_mode: bool,
//     pub parser_dir: Option<String>,
// }

// #[derive(Deserialize, Serialize, Debug)]
// pub struct ParserConf {
//     pub args: Option<Vec<Vec<String>>>,
//     pub parser: String,
// }

// #[derive(Deserialize, Serialize, Debug)]
// pub struct Config {
//     pub host_id: Vec<String>,
//     pub port_id: Vec<String>,
//     pub sql_tables: HashMap<String, String>,
//     // pub engagement_conf: String,
//     pub active: bool,
//     pub sql: SQLConf,
//     pub server: ServerConf,
//     pub parsers: HashMap<String, Vec<ParserConf>>,
//     pub overlap: HashMap<String, String>,
//     pub targets: HashMap<String, String>,
// }

#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub enum DBType {
    GraphQL,
    SQL
}


#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct EngageConfRaw {
    pub name: String,
    pub complete: bool,
    pub db_conf: Option<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct EngageConf {
    pub name: String,
    pub complete: bool,
    pub db_conf: String,
}

/// user configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct UsrConfRaw {
    pub active: bool,
    pub server_mode: Option<ServerModeConfRaw>,
    pub targets_prepare: Option<String>,
    pub targets_cleanup: Option<String>,
    pub targets: HashMap<String, String>,
    pub parsers: HashMap<String, Vec<ParserConfRaw>>,
}

/// user server mode configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ServerModeConfRaw {
    pub socket_adr: Option<String>,
    pub quiet_logs: Option<bool>,
}

/// user parser configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ParserConfRaw {
    pub args: Option<Vec<Vec<String>>>,
    pub parser: String,
    pub help: Option<Vec<String>>,
    pub parse_on_error: Option<bool>,
}

/// user database server configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct DBServerRaw {
    pub host: String,
    pub user: String,
    pub passwd: Option<String>,
    pub port: Option<String>,
    pub ssl_cert: Option<String>,
    pub require_ssl: Option<bool>, 
    pub db_type: DBType, 
}

/// global program configurations.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct GlobalConfRaw {
    pub host_id: Vec<String>,
    pub port_id: Vec<String>,
    pub sql_nul_val: Option<String>,
    pub sql_tables: HashMap<String, String>,
    pub overlap: HashMap<String, String>,
}

/// user database server configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct UsrConf {
    pub active: bool,
    pub server_mode: ServerModeConf,
    pub targets_prepare: Option<String>,
    pub targets_cleanup: Option<String>,
    pub targets: HashMap<String, String>,
    pub parsers: HashMap<String, Vec<ParserConf>>,
}

/// user server mode configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ServerModeConf {
    pub socket_adr: String,
    pub quiet_logs: bool,
}

/// user parser configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ParserConf {
    pub args: Option<Vec<Vec<String>>>,
    pub parser: String,
    pub help: Vec<String>,
    pub parse_on_error: bool,
}

/// user database server configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct DBServer {
    pub host: String,
    pub user: String,
    pub passwd: Option<String>,
    pub port: String,
    pub ssl_cert: Option<String>,
    pub require_ssl: bool,
    pub db_type: DBType, 
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct GlobalConf {
    pub host_id: Vec<String>,
    pub port_id: Vec<String>,
    pub sql_nul_val: String,
    pub sql_tables: HashMap<String, String>,
    pub overlap: HashMap<String, String>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TargetsConf {
    pub targets: HashMap<String, String>,
    pub prepare: Option<String>,
    pub cleanup: Option<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct RDFTypes {
    pub integer: String,
    pub boolean: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TemplateConf {
    pub query: String,
    pub add_mutate: String,
    pub mod_mutate: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TemplatesConf {
    pub rdf_add_line: String,
    pub rdf_update_line: String,
    pub rdf_types: RDFTypes,
    pub queries: HashMap<String, Vec<String>>,
    pub mutations: HashMap<String, TemplateConf>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Config {
    pub host_id: Vec<String>,
    pub port_id: Vec<String>,
    pub sql_tables: HashMap<String, String>,
    pub active: bool,
    pub db_server: DBServer,
    pub server_mode: ServerModeConf,
    pub parsers: HashMap<String, Vec<ParserConf>>,
    pub overlap: HashMap<String, String>,
    pub targets: TargetsConf, // HashMap<String, String>,
    pub sql_nul_val: String,
    pub templates: TemplatesConf,
}

// #[derive(Deserialize, Serialize, Debug)]
// pub struct ConfigRaw {
//     pub host_id: Vec<String>,
//     pub port_id: Vec<String>,
//     pub sql_tables: HashMap<String, String>,
//     pub active: bool,
//     pub sql: DBServer,
//     pub server: ServerModeConfRaw,
//     pub parsers: HashMap<String, Vec<ParserConfRaw>>,
//     pub overlap: HashMap<String, String>,
//     pub targets: HashMap<String, String>,
// }

impl EngageConfRaw {
    pub fn defaultify(&self) -> EngageConf {
        let sql_server = match &self.db_conf {
            Some(server) => server.clone(),
            None => String::from("default"),
        };

        EngageConf {
            name: self.name.clone(),
            complete: self.complete,
            db_conf: sql_server,
        }
    }
}

impl ServerModeConfRaw {
    fn defaultify(&self) -> ServerModeConf {
        let default = ServerModeConf::new();  // this way i only need to change the defaults in one place.

        ServerModeConf {
            socket_adr: match &self.socket_adr {
                Some(adr) => adr.clone(),
                None => default.socket_adr,
            },
            quiet_logs: match self.quiet_logs {
                Some(suppress_logs) => suppress_logs,
                None => default.quiet_logs,
            },
        }
    }
}

impl ServerModeConf {
    /// default for ServerModeConf.
    fn new() -> ServerModeConf {
        ServerModeConf {
            socket_adr: String::from("/tmp/ptdb/server"),
            quiet_logs: false,
        }
    }
}

impl ParserConfRaw {
    fn defaultify(&self) -> ParserConf {
        ParserConf {
            args: self.args.clone(),
            parser: self.parser.clone(),
            help: match &self.help {
                Some(flags) => flags.clone(),
                None => vec![String::from("-h"), String::from("--help")],
            },
            parse_on_error: match self.parse_on_error {
                Some(opt) => opt,
                None => true,
            },
        }
    }
}

impl UsrConfRaw {
    fn defaultify(&self) -> UsrConf {
        let server_mode = match &self.server_mode {
            Some(mode) => mode.defaultify(),
            None => ServerModeConf::new(),
        };

        UsrConf {
            active: self.active,
            server_mode: server_mode,
            targets_prepare: self.targets_prepare.clone(),
            targets_cleanup: self.targets_cleanup.clone(), 
            targets: self.targets.clone(),
            parsers: self.defaultify_parsers(),
        }
    }

    fn defaultify_parsers(&self) -> HashMap<String, Vec<ParserConf>> {
        let mut parsers = HashMap::new();

        for (exec, confs) in &self.parsers {
            let mut new_confs = Vec::new();
            for conf in confs {
                new_confs.push(conf.defaultify());
            }
            parsers.insert(exec.clone(), new_confs);
        }

        parsers
    }
}

impl DBServerRaw {
    fn defaultify(&self) -> DBServer {
        DBServer { 
            host: self.host.clone(), 
            user: self.user.clone(), 
            passwd: self.passwd.clone(), 
            port: if let Some(port) = &self.port {port.clone()} else {String::from("5432")}, 
            ssl_cert: self.ssl_cert.clone(), 
            require_ssl: if let Some(b) = self.require_ssl {b} else {false},
            db_type: self.db_type,
        }
    }
}

impl GlobalConfRaw {
    /// default for GloablConf.
    fn defaultify(&self) -> GlobalConf {
        GlobalConf { 
            host_id: self.host_id.clone(), 
            port_id: self.port_id.clone(), 
            sql_nul_val: if let Some(val) = &self.sql_nul_val {val.clone()} else {String::from("''")}, 
            sql_tables: self.sql_tables.clone(), 
            overlap: self.overlap.clone(), 
        }
    }
}

impl Config {
    fn new(usr_raw: UsrConfRaw, db_server_raw: DBServerRaw, global_raw: GlobalConfRaw, template: TemplatesConf) -> Config {
        let user = usr_raw.defaultify();
        let db = db_server_raw.defaultify();
        let global = global_raw.defaultify();
        
        Config {
            host_id: global.host_id,
            port_id: global.port_id,
            sql_tables: global.sql_tables,
            active: user.active,
            db_server: db,
            server_mode: user.server_mode,
            parsers: user.parsers,
            overlap: global.overlap,
            targets: TargetsConf { 
                targets: user.targets, 
                prepare: user.targets_prepare, 
                cleanup: user.targets_cleanup, 
            },
            sql_nul_val: global.sql_nul_val,
            templates: template,
        }
    }    
}

pub const GLOB_CONFIG_ADR: &str = "/etc/ptdb/config.toml";
pub const TEMPLATE_CONF: &str = "/etc/ptdb/templates.toml";
pub const USR_CONFIG_ADR: &str = "~/.config/ptdb/config.toml";
// pub const DB_SERVER_ADR: &str = "~/.config/ptdb/db-server.toml";
pub const DB_CONF_DIR: &str = "~/.config/ptdb/db-servers/";
pub const ENGAGEMENT_ADR: &str = "~/.config/ptdb/engagement.toml";

pub fn make_toml(fname: &str) -> String {
    if fname.ends_with(".toml") || fname.ends_with(".tml") {
        String::from(fname)
    } else {
        format!("{}.toml", fname)
    }
}

fn gen_db_conf(server_name: &str) -> String {
    let name_toml = make_toml(server_name);
    format!("{}{}", DB_CONF_DIR, name_toml)
}

/// gathers global and user configs.
pub fn get_config() -> Config {
    let usr_raw = match Figment::new()
        .merge(Toml::file(tilde(USR_CONFIG_ADR).to_string()))
        .extract() {
            Ok(conf) => conf,
            Err(e) =>  {
                eprintln!("[PTDB ERROR] could not load user config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?", USR_CONFIG_ADR);
                eprintln!("got error:\n{}", e);
                exit(1);
            }
        };

    let db_conf_f = &gen_db_conf(&get_engagement(ENGAGEMENT_ADR).db_conf);
    let db_server_raw = match Figment::new()
        .merge(Toml::file(tilde(db_conf_f).to_string()))
        .extract() {
            Ok(conf) => conf,
            Err(e) =>  {
                eprintln!("[PTDB ERROR] could not load database config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?", db_conf_f);
                eprintln!("got error:\n{}", e);
                exit(1);
            }
        };

    let global = match Figment::new()
        .merge(Toml::file(tilde(GLOB_CONFIG_ADR).to_string()))
        .extract() {
            Ok(conf) => conf,
            Err(e) =>  {
                eprintln!("[PTDB ERROR] could not load global config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?", GLOB_CONFIG_ADR);
                eprintln!("got error:\n{}", e);
                exit(1);
            }
        };

    let template = match Figment::new()
        .merge(Toml::file(tilde(TEMPLATE_CONF).to_string()))
        .extract() {
            Ok(conf) => conf,
            Err(e) =>  {
                eprintln!("[PTDB ERROR] could not load template config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?", TEMPLATE_CONF);
                eprintln!("got error:\n{}", e);
                exit(1);
            }
        };

    Config::new(usr_raw, db_server_raw, global, template)
}

// /// gathers global and user configs.
// pub fn get_config() -> ConfigRaw {
//     // this will fail if optional values are missing. and not give me my default values
//     match Figment::new()
//         .merge(Toml::file(tilde(GLOB_CONFIG_ADR).to_string()))
//         .merge(Toml::file(tilde(USR_CONFIG_ADR).to_string()))
//         .merge(Toml::file(tilde(DB_SERVER_ADR).to_string()))
//         .extract() {
//             Ok(conf) => conf,
//             Err(e) =>  {
//                 eprintln!("[PTDB ERROR] could not load one or more of the necessary config files.\n - do all the files exist?\n - are they formatted correctly?");
//                 eprintln!("got error:\n{}", e);
//                 exit(1);
//             }
//         }
// }

pub fn get_engagement(engage_conf: &str) -> EngageConf {
    let raw_engagement: EngageConfRaw = match Figment::new()
        .merge(Toml::file(tilde(engage_conf).to_string()))
        .extract() {
            Ok(conf) => conf,
            Err(e) => {
                eprintln!("[PTDB ERROR] could not load engagement config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?", engage_conf);
                eprintln!("got error:\n{}", e);
                exit(1);
            }
        };

    raw_engagement.defaultify()
}
