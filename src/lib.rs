use anyhow::{bail, Result};
use clap::ArgMatches;
use log::{debug, error, info};
use shellexpand::tilde;
use std::collections::HashMap;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::{exit, Command, Stdio};
use std::thread;
use std::todo;

pub mod config;
pub mod db_com;
pub mod graphql;
pub mod sql;

/// this assumes that the lines in input_log are formatted as follows:
/// 1: <first version of the command>
/// 2: <second version of the command>
/// 3: <third version of the command>
/// 4: <1st line of program output>
/// 5. <2nd line of program output>
/// 6. ...
pub fn process_raw_input(
    log: String,
    exit_status: i32,
    quiet: bool,
    cmd: Option<&String>,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> Result<String> {
    // if log.lines().count() < 3 && log.lines().count() > 1 {
    //     return Ok(format!("only {} versions of the command were provided. program expects all three versions that are passed to preexec.", log.lines().count()));
    // } else
    if log.lines().count() < 4 {
        return Ok(String::new());
    }

    let (commands, log_data) = match cmd {
        Some(cmd) => match get_cmd(&format!("{}\n{}\n{}\n", cmd, cmd, cmd)) {
            Ok((cmds, _)) => (cmds, log),
            Err(_e) => {
                error!("got error while parsing ");
                exit(1)
            }
        },
        None => match get_cmd(&log) {
            Ok(res) => res,
            Err(_e) => {
                error!("could not figure out what command was run.");
                exit(1);
            }
        },
    };

    return if !engage_conf.complete {
        // needed for when running in server mode.
        // add date-time check and turnning off of "complete flag" here as a conditional
        debug!("before run_parser");
        match run_parsers(commands, exit_status, log_data, configs, engage_conf, quiet) {
            Ok((entities, rows)) => {
                let encouragement = if rows > 0 {
                    "great job, keep it up! ðŸŽ‰"
                } else {
                    "nothing new. ðŸ˜”"
                };

                let message = if entities > 0 {
                    format!("parsed {} entities from output", entities)
                } else {
                    String::from("no info from parser")
                };

                Ok(format!(
                    "*** {}. added ~{} db rows. {} ***",
                    message, rows, encouragement
                ))
            }
            Err(mesg) => bail!(mesg),
        }
    } else {
        Ok("the engagement is complete. not parsing.".to_string())
    };
    // println!("done");
}

/// entry point to parsing when runnign as a server.
pub fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                error!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    info!("killing listener");
    drop(listener);
    Ok(())
}

pub fn get_data_names(
    matches: &ArgMatches,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> String {
    debug!("engage_conf: {engage_conf:?}");
    debug!("configs: {configs:?}");
    let col_names = match configs.db_server.db_type {
        config::DBType::SQL => sql::get_column_names(
            &db_com::get_as_str(matches, "target", None),
            &configs,
            engage_conf,
        ),
        config::DBType::GraphQL => Ok("under construction".to_string()),
    };

    match col_names {
        Ok(names) => names,
        Err(mesg) => format!("could not get the columns for that target. got error:\n{mesg}"),
    }
}

pub fn send_query(
    query: &str,
    configs: &config::Config,
    engage_conf: &config::EngageConf,
) -> String {
    info!("db_type {:?}", configs.db_server.db_type);
    let res = match configs.db_server.db_type {
        config::DBType::GraphQL => {
            // TODO: add: graphql::send_query(query, configs);  (but make it work).
            // Err("under construction".to_string())
            todo!("under construction")
        }
        config::DBType::SQL => sql::send_query(query, &engage_conf, configs),
    };

    match res {
        Ok(table) => table,
        Err(mesg) => {
            error!("{mesg}");
            // mesg.to_string()
            String::new()
        }
    }
}

pub fn gen_query(
    matches: &ArgMatches,
    _engagement: &str,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> String {
    let res = match configs.db_server.db_type {
        config::DBType::SQL => sql::gen_query(matches, configs, engage_conf),
        config::DBType::GraphQL => {
            // TODO: add: graphql::send_query(query, configs);  (but make it work).
            // Err("under construction".to_string())
            todo!("GraphQL querying is under construction.");
        }
    };

    match res {
        Ok(table) => table,
        Err(mesg) => {
            error!("{mesg}");
            // mesg.to_string()
            String::new()
        }
    }
}

/// handles a client connection when running in server client mode. it calls `process_raw_input`
/// internally.
fn handle_client(mut stream: UnixStream) {
    let configs = config::get_config();
    let engage_conf = config::get_engagement(&config::ENGAGEMENT_ADR);
    // let (commands, log_data) = get_cmd(&read_log(&mut stream));
    let tmp_log = read_log(&mut stream);
    let (exit_status, log) = match tmp_log.split_once('\n') {
        Some((es, log)) => (es.parse::<i32>().unwrap(), log.to_string()),
        None => {
            error!("could not extract exit status. assuming it was 0");
            (0, tmp_log)
        }
    };

    match process_raw_input(
        log,
        exit_status,
        configs.server_mode.quiet_logs,
        None,
        configs,
        engage_conf,
    ) {
        Ok(mesg) => {
            if !mesg.is_empty() {
                println!("{}", mesg);
            }
        }
        Err(mesg) => error!("could not add to database. got error:\n{mesg}"),
    };
    drop(stream);
}

///
fn run_parsers(
    commands: Vec<String>,
    exit_status: i32,
    log_data: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
    quiet: bool,
) -> Result<(usize, u16)> {
    let parsers = &configs.parsers;
    let (command, parser, poe) = match get_parser(&commands, parsers) {
        Some((command, parser, poe)) => (command, parser, poe),
        None => {
            debug!("could not find parser");
            exit(1);
        }
    }; // poe means Parse On Error

    if !poe && exit_status != 0 {
        info!("parse on error was false and program exited with an error. not parsing.");
        debug!("{poe} | {exit_status}");
        exit(0)
    }

    // debug!("parsers {:?}", configs.parsers);  // debug
    let parser_adr = Path::new(&tilde(db_com::PARSERS_DIR).to_string())
        .to_owned()
        .join(parser);

    if !quiet {
        info!("using parser at adr => {:#?}", parser_adr);
    }

    return if parser_adr.exists() {
        parse(&parser_adr, log_data, command.clone(), configs, engage_conf)
        // println!("parsed output or command: {:?}", command);
    } else {
        bail!(
            "run_parsers() | parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        )
    };
}

///
fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config::ParserConf>>,
) -> Option<(String, String, bool)> {
    for i in 0..3 {
        debug!("command => {}", commands[2 - i]);
        let cmd: String = commands[2 - i].clone();
        let mut tmp_cmd: Vec<String> = cmd.split(' ').map(|x| x.to_string()).collect();
        tmp_cmd.reverse();
        let mut exec: String;
        let given_args: Vec<String>;

        loop {
            exec = match tmp_cmd.pop() {
                Some(exec) => exec,
                None => return None,
            };

            if !exec.starts_with("-") {
                tmp_cmd.reverse();
                given_args = tmp_cmd;
                break;
            }
        }

        debug!("exec = {}", exec);
        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Some((
                                cmd.clone(),
                                parser.parser.clone(),
                                parser.parse_on_error,
                            ));
                        }
                    }
                }
            }

            match default {
                Some(parser) if !help_args(&given_args, &parser.help) => {
                    return Some((cmd.clone(), parser.parser.clone(), parser.parse_on_error))
                }
                _ => {}
            }
        }
        // message = format!("a parser for {} is not in config file.", exec)
    }
    // Err(message)
    None
}

///
fn get_default_parser(parsers: &Vec<config::ParserConf>) -> Option<&config::ParserConf> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser),
        }
    }
    None
}

fn help_args(
    given_args: &[String],
    arg_set: &[String], // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if given_args.contains(arg) {
            // println!("arg not contained {}", arg.to_string());
            return true;
        }
    }
    false
}

///
fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
    }
    true
}

///
fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config::Config,
    engage_conf: config::EngageConf,
) -> Result<(usize, u16)> {
    debug!(
        "using parser = {} | this parser exists = {}",
        parser.display(),
        parser.exists()
    );

    let mut child = match Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
    {
        Ok(proc) => proc,
        Err(e) => {
            // error!("failed to run parser {parser:?}");
            bail!(
                "Spawning parser sub process for {parser:?}, failed with error:\n{}",
                e
            );
        }
    };
    // .expect("Failed to spawn child process");

    // prints the whole input.
    // debug!("log_data: {}\n{log_data}", log_data.split("\n").collect::<Vec<&str>>().len());
    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let std_out = child
        .wait_with_output()
        .expect("Failed to read output of parser")
        .stdout;

    debug!(
        "n_lines {}",
        std_out
            .clone()
            .into_iter()
            .filter(|x| x.to_owned() == 10 as u8)
            .collect::<Vec<u8>>()
            .len()
    );

    let output = String::from_utf8(
        std_out, // .clone(),
    )
    .unwrap();

    debug!(
        "length of parser output: {}",
        output.split("\n").collect::<Vec<&str>>().len()
    );
    debug!(
        "parser output: \n{:#?}",
        output.split("\n").collect::<Vec<&str>>()
    );

    return if !output.is_empty() {
        //do SQL stuff with output.
        match config.db_server.db_type {
            config::DBType::GraphQL => {
                match graphql::merge_to_db(&output, cmd.clone(), config, engage_conf) {
                    Ok(n) => Ok((output.lines().count(), n)),
                    Err(e) => bail!(
                        "parse() | merging data from command '{cmd}', failed with error:\n{e}"
                    ),
                }
            }
            config::DBType::SQL => {
                match sql::merge_to_db(&output, cmd.clone(), config, engage_conf) {
                    Ok(n) => Ok((output.lines().count(), n)),
                    Err(e) => bail!(
                        "parse() | merging data from command '{cmd}', failed with error:\n{e}"
                    ),
                }
            }
        }
    } else {
        Ok((output.lines().count(), 0))
    };
}

/// used to read the log data when in server mode.
fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

/// figures out what command the output belongs to. it will ignore common prefix commands like `sudo`, `doas`, `time`, and `proxychains`
fn get_cmd(log_data: &String) -> Result<(Vec<String>, String)> {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        // TODO: add a way to ignore env that where set before the command.
        // i.e `$ foo="bar" nmap -p- baz.com
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(
                    dat.0
                        .replace("sudo ", "")
                        .replace("doas ", "")
                        .replace("time ", "")
                        .replace("proxychains ", "")
                        .trim()
                        .to_string(),
                );
                dat.1.to_owned()
            }
            None => bail!(""),
            // None => return Err(format!("not enough lines found. {:?}", log_data)),
        }
    }

    // cmd_names.map(|s| s.replace("sudo" "").replace("doas", "").replace("time", "").trim());
    Ok((cmd_names, tmp_log))
}

/// used to determine if the current terminal session is paused.
/// returns true only if the paused file exists and contains the
/// contents "true" (case insensitive).
pub fn paused_locally() -> bool {
    match config::get_pause_f() {
        Ok(path) => match fs::read_to_string(path) {
            Ok(data) => data.to_lowercase().starts_with("true"),
            Err(_e) => false,
        },
        Err(_e) => {
            info!("local pause file does not exist or \"log_dir\" was not found in the environment variables. assuming that the session is active.");
            false
        }
    }
}
