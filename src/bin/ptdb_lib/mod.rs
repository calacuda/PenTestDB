#![warn(clippy::all)]
use chrono::prelude::*;
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::thread;
use std::process::exit;
use shellexpand::tilde;

pub mod config_loading; 

type GraphNames = Vec<String>;
type GraphValues = Vec<String>;
type GraphAssociaions = (GraphNames, GraphValues);

#[derive(Debug)]

enum DGType {
    Machine(GraphAssociaions),
    WebDir(GraphAssociaions),
    Credential(GraphAssociaions),
    DSNName(GraphAssociaions),
    // Command(GraphAssociaions),
    Port(GraphAssociaions),
}

// pub mod config_loading;
pub const CONFIG_DIR: &str = "~/.config/ptdb/";
pub const ENGAGEMENTS_DIR: &str = "~/.config/ptdb/engagements";
pub const ENGAGEMENT_ADR: &str = "~/.config/ptdb/engagement.toml";
// "~/.local/share/ptdb/parsers/"
// pub const PARSERS_DIR: &str = "/etc/ptdb/parsers/";
pub const PARSERS_DIR: &str = "~/Code/misc/PenTestDB/configs/etc/ptdb/parsers/";
pub const MAKE_SQL_DB: &str = "/etc/ptdb/make-db.sql";
// pub const DB_DIR: &str = "~/.config/ptdb/db-servers";
// pub const DB_ADR: &str = config_loading::DB_SERVER_ADR;  // "~/.config/ptdb/db-server.toml";


/// entry point to parsing when runnign as a server.
pub fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

fn handle_client(mut stream: UnixStream) {
    let configs = config_loading::get_config();
    let engage_conf = config_loading::get_engagement(config_loading::ENGAGEMENT_ADR);
    // let (commands, log_data) = get_cmd(&read_log(&mut stream));
    match process_raw_input(read_log(&mut stream), configs.server_mode.quiet_logs, None, configs, engage_conf) {
        Ok(mesg) => {
            if !mesg.is_empty() {
                println!("{}", mesg);
            }
        }
        Err(mesg) => println!("[PTDB ERROR] could not add to database. got error:\n{}", mesg),
    };
    drop(stream);
}

/// this assumes that the lines in log are formatted as follows:
/// 1: <exit status>
/// 2: <first version of the command>
/// 3: <second version of the command>
/// 4: <third version of the command>
/// 5: <the programs output>
/// ...
pub fn process_raw_input(
    input_log: String,
    quiet: bool, 
    cmd: Option<&String>, 
    configs: config_loading::Config, 
    engage_conf: config_loading::EngageConf,
) -> Result<String, String> {
    // if log.lines().count() < 3 && log.lines().count() > 1 {
    //     return Ok(format!("only {} versions of the command were provided. program expects all three verisons that are passed to preexec.", log.lines().count()));
    // } else 
    if input_log.lines().count() < 4 {
        return Ok(String::new());
    }

    let (exit_status, log) = match input_log.split_once('\n') {
        Some((es, log)) => (es.parse::<i32>().unwrap(), log.to_string()),
        None => return Err("could not extract exit status".to_string()), 
    };

    let (commands, log_data) = match cmd {
        Some(cmd) => {
            match get_cmd(&format!("{}\n{}\n{}\n", cmd, cmd, cmd)) {
                Ok((cmds, _)) => (cmds, log),
                Err(_e) => {
                    println!("got error while parsing ");
                    exit(1)
                }                
            }
        }
        None => {
            match get_cmd(&log) {
                Ok(res) => res,
                Err(_e) => exit(1)
            }
        }
    };

    // let configs = config_loading::get_config();
    // let engage_conf = config_loading::get_engagement(ENGAGEMENT_ADR);
    
    return if !engage_conf.complete {  // needed for when running in server mode.
        // add date-time check and turnning off of "complete flag" here as a conditional
        // println!("before run_parser");  //debug
        match run_parsers(commands, exit_status, log_data, configs, engage_conf, quiet) {
            Ok((entities, rows)) => {
                let encouragement = if rows > 0 {
                    "great job, keep it up! ðŸŽ‰"
                } else {
                    "nothing new. ðŸ˜”"
                };

                let message = if entities > 0 {
                    format!("parsed {} entities from output", entities)
                } else {
                    String::from("no info from parser")
                };

                Ok(format!("*** {}. added/modded ~{} db rows. {} ***", message, rows, encouragement))
            },
            Err(mesg) => Err(mesg),
        }
    } else {
        Ok("the engagement is complete. not parsing.".to_string())
    };
    // println!("done");
}

pub fn console_log(mesg: &str, quiet: bool) {
    if !mesg.is_empty() && !quiet {
        println!("{}", mesg);
        // eprintln!("{}", mesg);
    };
}

fn run_parsers(
    commands: Vec<String>,
    exit_status: i32,
    log_data: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
    quiet: bool
) -> Result<(usize, u64), String> {
    let parsers = &configs.parsers;
    let (command, parser, poe) = match get_parser(&commands, parsers) {
        Some((command, parser, poe)) => (command, parser, poe),
        None => {
            exit(1);
        }
    };

    if !poe && exit_status != 0 {
        exit(0)
    }
    
    // println!("parsers {:?}", configs.parsers);
    let parser_adr = 
        Path::new(&tilde(PARSERS_DIR).to_string())
        .to_owned()
        .join(parser);
    console_log(&format!("using parser at adr => {:#?}", parser_adr), quiet);

    return if parser_adr.exists() {
        parse(&parser_adr, log_data, command.clone(), configs, engage_conf)
        // println!("parsed output or command: {:?}", command);
    } else {
        Err(format!(
            "run_parsers() | parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        ))
    }
}

fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config_loading::ParserConf>>,
) -> Option<(String, String, bool)> {
    // println!("get_parser");
    // let mut message = String::new();

    for i in 0..3 {
        // println!("command => {}", commands[2 - i]);
        let cmd: String = commands[2 - i].clone();
        let mut tmp_cmd: Vec<String> = cmd.split(' ').map(|x| x.to_string()).collect();
        tmp_cmd.reverse();
        let mut exec: String;
        let given_args: Vec<String>;

        loop {
            // let (exec, given_args): (String, Vec<String>) = match cmd {
            //     Some((exec, args)) => (
            //         exec.to_string(),
            //         args.split(' ').map(|x| x.to_string()).collect(),
            //     ),
            //     None => (cmd.clone(), Vec::new()),
            // };
            // let (exec, given_args) = (String::from(cmd[0]), cmd[1..].collect());
            exec = match tmp_cmd.pop() {
                Some(exec) => exec,
                None => {return None}
            };

            if !exec.starts_with("-") {
                tmp_cmd.reverse();
                given_args = tmp_cmd;
                break;
            }
        }

        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Some((cmd.clone(), parser.parser.clone(), parser.parse_on_error));
                        }
                    }
                }
            }

            match default {
                Some(parser) if !help_args(&given_args, &parser.help) => return Some((cmd.clone(), parser.parser.clone(), parser.parse_on_error)),
                _ => {}
            }
        }
        // message = format!("a parser for {} is not in config file.", exec)
    }
    // Err(message)
    None
}

fn get_default_parser(parsers: &Vec<config_loading::ParserConf>) -> Option<&config_loading::ParserConf> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser),
        }
    }
    None
}

fn help_args(
    given_args: &[String],
    arg_set: &[String], // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if given_args.contains(arg) {
            // println!("arg not contained {}", arg.to_string());
            return true;
        }
    }
    false
}

fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
    }
    true
}

fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<(usize, u64), String> {
    let mut child = match Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn() {
            Ok(proc) => proc,
            Err(e) => return Err(format!("parse() | Spawning child process failed with error:\n{}", e))
        };
        // .expect("Failed to spawn child process");

    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let output = String::from_utf8_lossy(
        &child
            .wait_with_output()
            .expect("Failed to read stdout")
            .stdout,
    )
    .to_string();
    // output = &output.stdout;
    // println!("output: \n{}", output);

    return if !output.is_empty() {
        //do SQL stuff with output.
        match merge_to_db(&output, cmd.clone(), config, engage_conf) {
            Ok(n) => Ok((output.lines().count(), n)),
            Err(e) => Err(format!("parse() | merging data from command '{}', failed with error:\n{}", cmd, e)),
        }
    } else {
        Ok((output.lines().count(), 0))
    }
}

fn merge_to_db(
    output: &String,
    cmd: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<u64, String> {
    // let mut client = connect(
    //     &configs.sql.host,
    //     &configs.sql.user,
    //     &configs.sql.passwd,
    //     &configs.sql.port,
    //     &Some(engage_conf.name),
    //     &configs.sql.ssl_cert,
    //     configs.sql.require_ssl,
    // )?;
    let res = store_data(output, cmd, &configs, engage_conf);

    // let _ = client.close();

    return match res { 
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("merge_to_db() | storing data failed with error:\n{}", mesg)),
    }
}

fn parse_output(line: String, engage_name: &str) -> Result<DGType, String> {
    // let tmp_line = line.clone();
    let mut params: GraphAssociaions = (Vec::new(), Vec::new());
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    let mut dg_type = "";
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        // println!("tokens {:?}", &tokens);
        return Err("[PTDB ERROR] every key needs a value!".to_string());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.0.push(key.to_string());
        params.1.push(value.to_string());
        if key == "dgraph.type" {
            dg_type = value;
        }
    }
    
    params.0.push("command".to_string());
    params.1.push("_:command_0".to_string());
    params.0.push("engagement".to_string());
    params.1.push(engage_name.to_string());

    Ok(match dg_type {
        "Machine" => DGType::Machine(params),
        "Port" => DGType::Port(params),
        "WebDir" => DGType::WebDir(params),
        "DNSName" => DGType::DSNName(params),
        "Credential" => DGType::Credential(params),
        _ => return Err(String::from("no type was specified byt the parser.")),
    })
}

fn add_command_engagement(
    cmd: &str, 
    _queries: &mut Vec<String>,
    mutations: &mut Vec<String>,
    engage_conf: config_loading::EngageConf
) {
    let time: DateTime<Local> = Local::now();

    let command_add = "\tmutation {
        set {
            _:command_0 <Command.command> \"<CMD>\" . 
            _:command_0 <Command.local_time> \"<TIME>\" . 
            _:command_0 <dgraph.type> \"Command\" .  
            _:command_0 <Command.engagement> \"<ENGAGEMENT>\" .  
        }
    }
    "
    .replace("<ENGAGEMENT>", &engage_conf.name)
    .replace("<CMD>", &cmd)
    .replace("<TIME>", 
        &format!("{}", time)
        .replacen(" ", "T", 1)
        .replace(" ", "")
    )
    .to_string();
    mutations.push(command_add);
}

fn store_data(
    output: &String, 
    cmd: String, 
    configs: &config_loading::Config, 
    engage_conf: config_loading::EngageConf
) -> Result<u64, String> { 
    
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    let engage_name = engage_conf.name.clone();
    // println!("line => ^{:?}?", tmp_output);
    let mut predicates: Vec<DGType> = Vec::new();
    let mut queries: Vec<String> = Vec::new();
    let mut mutations: Vec<String> = Vec::new();

    add_command_engagement(&cmd, &mut queries, &mut mutations, engage_conf);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        // let mut predicate: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string(), &engage_name) {
            Ok(types) => types,
            Err(e) => return Err(format!("store_data() | could not understand the output of the parser. error on key: '{}'. got error:\n{}",
            line, e))
        };
        // let mut data = HashMap::new();
        predicates.push(params);
        // predicates.push(data);
    }
    // println!("predicates => {:?}", predicates);

    make_query_mut(&engage_name, predicates, &mut queries, &mut mutations, configs);

    let mut update_text = String::from("\nquery {");
    for line in queries {
        update_text = format!("{}\n{}", update_text, line);
    }
    update_text = format!("{}\n}}", update_text);
    for line in mutations {
        update_text = format!("{}\n{}", update_text, line);
    }
    // println!("UPDATE TEXT:\n{}\n\n", update_text);
    update_text = format!("upsert {{{}}}", update_text);
    
    return match send_to_db(&update_text, configs) {
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("store_data() | sending data to db failed with error:\n{}", mesg)),
    };
}

fn get_machine_id(data: &GraphAssociaions) -> Option<String> {
    for id_name in ["ip", "ipv6", "local_name"] {
        match get_item(id_name, &data) {
            Some(id) => return Some(id),
            None => {},
        }
    }
    return None;
}

fn get_item(name: &str, data: &GraphAssociaions) -> Option<String> {
    let id_i = data.0.iter().position(|x| x == &name)?;
    return Some(data.1[id_i].clone());
}

fn add_query_mutations(
    d_type: &str,
    engage_name: &str,
    data: &GraphAssociaions,
    compare_value: Option<String>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>, 
    configs: &config_loading::Config,
) -> Option<()> {
    let machine_name = match get_item("machine", data) {
        Some(dat) => dat.replace("_:", ""),
        None => "".to_string(),
    };
    let host_name = match get_item("host", data) {
        Some(dat) => dat,
        None => "".to_string(),
    };
    let add_name = get_item("uid", data)?.replace("_:", "");
    
    // if d_type == "Port" {
    //     println!("port uid => {}", add_name);
    // }
    let templates = configs.templates.mutations.get(d_type)?;
    
    let mut query = templates.query
                        .replace("<MACHINE_NAME>", &machine_name)
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ENGAGEMENT>", &format!("\"{}\"", engage_name))
                        .replace("<ADD_NAME>", &add_name);
    query = match compare_value {
        Some(comp_val) => query.replace("<COMP_VAL>", &if d_type != "Port" {comp_val} else {format!("\"{}\"", comp_val)}),
        None => query, 
    };
    query = format!("q{}{}", queries.len(), query);
    // println!("query: {:?}\n", query); // debug
    queries.push(query);
    // println!("queries: {:?}\n", queries); // debug


    let rdf_add = configs.templates.rdf_add_line.clone();
    let rdf_update = configs.templates.rdf_update_line.clone();
    let rdf_types = configs.templates.rdf_types.clone();
    let mut rdf_lines_add = String::new();
    let mut rdf_lines_update = String::new();

    for i in 0..data.0.len() {
        let (name, value) = (data.0[i].clone(), data.1[i].clone());
        if name == "uid" {
            continue
        }
        let var_name = if !name.starts_with("dgraph") { format!("{}.{}", d_type, name) } else { name };
        let var_type = if vec!["is_cname"].contains(&var_name.as_str()) {
            rdf_types.boolean.clone()
        } else if vec!["res_code", "port"].contains(&var_name.as_str()) {
            rdf_types.integer.clone()
        } else {
            "".to_string()
        };

        let tmp_value = if value.starts_with("_:") {
            value
        } else {
            format!("\"{}\"", value)
        };

        let add_line = rdf_add
                    .replace("<ADD_NAME>", &add_name)
                    .replace("<VAR_NAME>", &var_name)
                    .replace("<VALUE>", &tmp_value)
                    .replace("<VAR_TYPE>", &var_type);
        
        let update_line = rdf_update
                    .replace("<ADD_NAME>", &add_name)
                    .replace("<VAR_NAME>", &var_name)
                    .replace("<VALUE>", &tmp_value)
                    .replace("<VAR_TYPE>", &var_type);

        rdf_lines_update = format!("{}\n\t{}", rdf_lines_update, update_line);

        rdf_lines_add = format!("{}\n\t{}", rdf_lines_add, add_line);
    } 

    let add_mutate = templates.add_mutate
                        .replace("<MACHINE_NAME>", &machine_name)
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ADD_NAME>", &add_name)
                        .replace("<ADD_RDF>", &rdf_lines_add)
                        .replace("<UPDATE_RDF>", &rdf_lines_update);
    let mod_mutate = templates.mod_mutate
                        .replace("<MACHINE_NAME>", &machine_name)   
                        .replace("<HOST_NAME>", &host_name)
                        .replace("<ADD_NAME>", &add_name);
    mutations.push(add_mutate);
    mutations.push(mod_mutate);

    Some(())
}

fn make_query_mut(
    engage_name: &str,
    predicates: Vec<DGType>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>, 
    configs: &config_loading::Config,
) {
    // println!("{:?}", predicates);
    for graph_data in &predicates {
        
        match &graph_data {
            &DGType::Machine(dat) =>  {
                add_query_mutations("Machine", engage_name, &dat, get_machine_id(dat), queries, mutations, configs);
            },
            &DGType::Port(dat) => {
                add_query_mutations("Port", engage_name, &dat, get_item("port", dat), queries, mutations, configs);
            },
            &DGType::WebDir(dat) => {
                add_query_mutations("WebDir", engage_name, &dat, get_item("dir", dat), queries, mutations, configs);
            },
            &DGType::DSNName(dat) => {
                add_query_mutations("DNSName", engage_name, &dat, get_item("name", dat), queries, mutations, configs);
            }
            &DGType::Credential(dat) => {
                // TODO: make a custom way to query for credentials. 
                add_query_mutations("Credential", engage_name, &dat, get_item("", dat), queries, mutations, configs);
            }
        };
    }
    // println!("query => {:?}", queries);
}

pub fn com_with_db(
    payload: &str,
    folder: &str,
    content_type: &str,
    configs: &config_loading::Config,
) -> Result<serde_json::Value, String> {
    // eprintln!("update_text => {}", update_text);

    let client = reqwest::blocking::Client::new();
    let url = format!("{}{}", configs.sql.host, folder);
    // println!("url => {}", url);
    let raw_res = client.post(url)
        .header(reqwest::header::CONTENT_TYPE, content_type)
        .body(payload.to_owned())
        .send()
        .expect("could not communicate with the servers")
        .text();
    // println!("raw_res => {}", raw_res);
    // println!("{}", raw_res);
    match raw_res {
        Ok(res) => {
            println!("{}", res);
            match serde_json::from_str(&res) {
                Ok(res) => Ok(res),
                Err(m) => Err(format!("could not parse json from the server. got error\n{}", m)),
            }
        }
        Err(m) => Err(format!("could not comunicate with the server. got error\n{}", m))
    }
}

fn send_to_db(
    update_text: &str,
    configs: &config_loading::Config,
) -> Result<u64, String> {
    let mut n_changes = 0;
    let res = com_with_db(update_text, "/mutate?commitNow=true", "application/rdf", configs)?;
    // println!("{}", res);
    match res.get("data").expect("no data").get("uids").expect("no uids") {
        serde_json::Value::Object(dat) => {n_changes += dat.len() - 1},
        _ => {},
    };
    // println!("number of changes :  {:?}", n_changes);
    Ok(n_changes as u64)
}

fn add_param(base: &String, p_name: &str, p_opt: &Option<String>) -> Option<String> {
    match p_opt {
        Some(opt) => Some(format!("{} {}={}", base, p_name, opt)),
        None => None,
    }
}

pub fn connect(
    host: &String,
    user: &String,
    pass: &Option<String>,
    port: &str,
    db_name: &Option<String>,
    ssl_cert: &Option<String>,
    require_ssl: bool,
) -> Result<Client, String> {
    let mut con_config = format!("host={} user={}", host, user);
    
    if !host.starts_with("/") && !host.starts_with("~") {
        con_config = format!("{} port={}", con_config, port);
    }

    for (name, opt) in [("password", pass), ("dbname", db_name)] {
        match add_param(&con_config, name, opt) {
            Some(new_con_config) => con_config = new_con_config,
            None => {}

        }
    }

    if require_ssl {
        // this means that the connection will not be made unless ssl can be verified. 
        con_config = format!("{} sslmode=require", con_config);
    } else {
        // "sslmode" is set to "prefer" by default but this makes it explicit in my code.  
        con_config = format!("{} sslmode=prefer", con_config); 
    }

    let con = match ssl_cert {
        Some(cert_f) if !cert_f.is_empty() =>  Client::connect(&con_config, get_ssl(&tilde(cert_f))),
        _ => Client::connect(&con_config, NoTls),
    };

    match con {
        Ok(conection) => Ok(conection),
        Err(e) => {
            Err(
                format!(
                    "server connection error could not connect to sql database. got error:\n{}", e
                )
            )
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create sslconnector builder");
    builder
        .set_ca_file(ca_file)
        .expect(&format!("unable to load {}", ca_file));
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

fn get_cmd(log_data: &String) -> Result<(Vec<String>, String), String> {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(
                    dat.0
                        .replace("sudo", "")
                        .replace("doas", "")
                        .replace("time", "")
                        .replace("proxychains", "")
                        // .replace("proxychains", "")
                        .trim()
                        .to_string(),
                );
                dat.1.to_owned()
            }
            None => return Err(String::new()),
            // None => return Err(format!("not enough lines found. {:?}", log_data)),
        }
    }

    // cmd_names.map(|s| s.replace("sudo" "").replace("doas", "").replace("time", "").trim());
    Ok((cmd_names, tmp_log))
}