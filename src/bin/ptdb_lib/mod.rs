#![warn(clippy::all)]
use chrono::prelude::*;
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::thread;
use std::process::exit;
use dns_lookup::lookup_host;
use std::net::IpAddr;
use shellexpand::tilde;

pub mod config_loading; 

type SQLColumnNames = Vec<String>;
type SQLColumnValues = Vec<String>;
type SQLColumnAssociaions = (SQLColumnNames, SQLColumnValues);
type SQLTableData = HashMap<String, SQLColumnAssociaions>;
type SQLTableDatas = Vec<SQLTableData>;

// pub mod config_loading;
pub const CONFIG_DIR: &str = "~/.config/ptdb/";
pub const ENGAGEMENTS_DIR: &str = "~/.config/ptdb/engagements";
pub const ENGAGEMENT_ADR: &str = "~/.config/ptdb/engagement.toml";
// "~/.local/share/ptdb/parsers/"
pub const PARSERS_DIR: &str = "/etc/ptdb/parsers/";
pub const MAKE_SQL_DB: &str = "/etc/ptdb/make-db.sql";
pub const DB_DIR: &str = "~/.config/ptdb/db-servers";
pub const DB_ADR: &str = "~/.config/ptdb/db-server.toml";


/// entry point to parsing when runnign as a server.
pub fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

fn handle_client(mut stream: UnixStream) {
    let configs = config_loading::get_config();
    let engage_conf = config_loading::get_engagement(ENGAGEMENT_ADR);
    // let (commands, log_data) = get_cmd(&read_log(&mut stream));
    match process_raw_input(read_log(&mut stream), configs.server_mode.quiet_logs, None, configs, engage_conf) {
        Ok(mesg) => {
            if !mesg.is_empty() {
                println!("{}", mesg);
            }
        }
        Err(mesg) => println!("[PTDB ERROR] could not add to database. got error:\n{}", mesg),
    };
    drop(stream);
}

pub fn process_raw_input(
    log: String, 
    quiet: bool, 
    cmd: Option<&String>, 
    configs: config_loading::Config, 
    engage_conf: config_loading::EngageConf,
) -> Result<String, String> {
    // if log.lines().count() < 3 && log.lines().count() > 1 {
    //     return Ok(format!("only {} versions of the command were provided. program expects all three verisons that are passed to preexec.", log.lines().count()));
    // } else 
    if log.lines().count() < 3 {
        return Ok(String::new());
    }

    let (commands, log_data) = match cmd {
        Some(cmd) => {
            match get_cmd(&format!("{}\n{}\n{}\n", cmd, cmd, cmd)) {
                Ok((cmds, _)) => (cmds, log),
                Err(_e) => {
                    println!("got error while parsing ");
                    exit(1)
                }                
            }
        }
        None => {
            match get_cmd(&log) {
                Ok(res) => res,
                Err(_e) => exit(1)
            }
        }
    };

    // let configs = config_loading::get_config();
    // let engage_conf = config_loading::get_engagement(ENGAGEMENT_ADR);
    
    return if !engage_conf.complete {  // needed for when running in server mode.
        // add date-time check and turnning off of "complete flag" here as a conditional
        // println!("before run_parser");  //debug
        match run_parsers(commands, log_data, configs, engage_conf, quiet) {
            Ok((entities, rows)) => {
                let encouragement = if rows > 0 {
                    "ðŸŽ‰ great job, keep it up! ðŸŽ‰"
                } else {
                    "nothing new found. ðŸ˜”"
                };

                let message = if entities > 0 {
                    format!("parsed {} entities from output", entities)
                } else {
                    String::from("no info from parser")
                };

                Ok(format!("*** {}. added/modded {} db rows. {} ***", message, rows, encouragement))
            },
            Err(mesg) => Err(mesg),
        }
    } else {
        Ok("the engagement is complete. not parsing.".to_string())
    };
    // println!("done");
}

pub fn console_log(mesg: &str, quiet: bool) {
    if !mesg.is_empty() && !quiet {
        println!("{}", mesg);
    };
}

fn run_parsers(
    commands: Vec<String>,
    log_data: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
    quiet: bool
) -> Result<(usize, u64), String> {
    let parsers = &configs.parsers;
    let (command, parser) = match get_parser(&commands, parsers) {
        Some((command, parser)) => (command, parser),
        None => {
            exit(1);
        }
    };
    // println!("parsers {:?}", configs.parsers);
    let parser_adr = 
        Path::new(&tilde(PARSERS_DIR).to_string())
        .to_owned()
        .join(parser);
    console_log(&format!("using parser at adr => {:#?}", parser_adr), quiet);

    return if parser_adr.exists() {
        parse(&parser_adr, log_data, command.clone(), configs, engage_conf)
        // println!("parsed output or command: {:?}", command);
    } else {
        Err(format!(
            "run_parsers() | parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        ))
    }
}

fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config_loading::ParserConf>>,
) -> Option<(String, String)> {
    // println!("get_parser");
    // let mut message = String::new();

    for i in 0..3 {
        // println!("command => {}", commands[2 - i]);
        let cmd = &commands[2 - i];
        // let exec = cmd.split_once(' ').into_iter().nth(0).expect(&cmd);
        let (exec, given_args): (String, Vec<String>) = match cmd.split_once(' ') {
            Some((exec, args)) => (
                exec.to_string(),
                args.split(' ').map(|x| x.to_string()).collect(),
            ),
            None => (cmd.clone(), Vec::new()),
        };

        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Some((cmd.clone(), parser.parser.clone()));
                        }
                    }
                }
            }
            match default {
                Some(parser) => return Some((cmd.clone(), parser)),
                None => {}
            }
        }
        // message = format!("a parser for {} is not in config file.", exec)
    }
    // Err(message)
    None
}

fn get_default_parser(parsers: &Vec<config_loading::ParserConf>) -> Option<String> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser.parser.clone()),
        }
    }
    None
}

fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg.to_string()) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
    }
    true
}

fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<(usize, u64), String> {
    let mut child = match Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn() {
            Ok(proc) => proc,
            Err(e) => return Err(format!("parse() | Spawning child process failed with error:\n{}", e))
        };
        // .expect("Failed to spawn child process");

    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let output = String::from_utf8_lossy(
        &child
            .wait_with_output()
            .expect("Failed to read stdout")
            .stdout,
    )
    .to_string();
    // output = &output.stdout;
    // println!("output: \n{}", output);

    return if !output.is_empty() {
        //do SQL stuff with output.
        match merge_to_db(&output, cmd.clone(), config, engage_conf) {
            Ok(n) => Ok((output.lines().count(), n)),
            Err(e) => Err(format!("parse() | merging data from command '{}', failed with error:\n{}", cmd, e)),
        }
    } else {
        Ok((output.lines().count(), 0))
    }
}

fn merge_to_db(
    output: &String,
    cmd: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<u64, String> {
    let mut client = connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &Some(engage_conf.name),
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    )?;
    // ensure_db(&mut client, engage_conf.name);
    let res = store_data(output, cmd, &mut client, &configs);

    let _ = client.close();

    return match res { 
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("merge_to_db() | storing data failed with error:\n{}", mesg)),
    }
}

fn parse_output(line: String) -> Result<HashMap<String, String>, String> {
    // let tmp_line = line.clone();
    let mut params: HashMap<String, String> = HashMap::new();
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        // println!("tokens {:?}", &tokens);
        return Err("[PTDB ERROR] every key needs a value!".to_string());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.insert(key.to_string(), value.to_string());
    }

    Ok(params)
}

fn add_params(
    params: HashMap<String, String>,
    cmd: &String,
    table_data: &mut HashMap<String, (Vec<String>, Vec<String>)>,
    configs: &config_loading::Config,
    // _client: &mut Client,
) {
    // println!("add_params");
    let mut host_ip = "".to_string();
    let mut port_num = String::from("0");
    let mut tables = Vec::new();

    for (key, value) in params {
        let table = match configs.sql_tables.get(&key) {
            Some(table) => table,
            None => {
                // println!("unknown column. what is\"{}\"?", key);
                continue;
            }
        };

        if configs.host_id.contains(&key) {
            host_ip = value.clone();
        }

        if configs.port_id.contains(&key) {
            port_num = value.clone();
        }

        // println!("table: <{}>, port: <{}>", table, port_num); //debug

        tables.push(table);

        // if table_data.contains_key(&table.to_string()) {
        match table_data.get_mut(&table.to_string()) {
            Some(data) => {
                data.0.push(key.clone());
                data.1.push(value.clone());
            }
            None => {
                table_data.insert(table.to_string(), (vec![key.clone()], vec![value.clone()]));
            }
        }
    }

    // add cmd and host
    for table in ["ports", "web_dirs", "creds"] {
        // for (c_name, id) in [("command_uid", cmd.to_string()), ("host_uid", host_ip.to_string()), ("port_uid", port_id.to_string())] {
        //     if table_data.contains_key(&table.to_string()) {
        //         // println!("adding {}:{} to table: {}", c_name, id, table);
        //         table_data
        //             .get_mut(&table.to_string())
        //             .unwrap()
        //             .0
        //             .push(c_name.to_string());
        //         table_data.get_mut(&table.to_string()).unwrap().1.push(id);

        //     }
        // }
        insert_uid_param(
            table,
            table_data,
            &[("command_uid", cmd.to_string()), ("host_uid", host_ip.to_string())],
        )
    }
    insert_uid_param(
        "creds",
        table_data,
        &[("port_uid", port_num.to_string())]
    );
}

fn insert_uid_param(
    table: &str, 
    table_data: &mut HashMap<String, (Vec<String>, Vec<String>)>,
    uid_params: &[(&str, String)],
) {
    for (c_name, id) in uid_params {
        if table_data.contains_key(&table.to_string()) {
            // println!("adding {}:{} to table: {}", c_name, id, table);
            table_data
                .get_mut(&table.to_string())
                .unwrap()
                .0
                .push(c_name.to_string());
            table_data.get_mut(&table.to_string()).unwrap().1.push(String::from(id));

        }
    };
}

fn resolve_dnsnames(table_datas: &mut Vec<HashMap<String, (Vec<String>, Vec<String>)>>) {
    for mut table in table_datas {
        resolve_dnsname(&mut table)
    }
}

fn resolve_dnsname(table_data: &mut HashMap<String, (Vec<String>, Vec<String>)>) {
    match table_data.get_mut("hosts") {
        Some(mut data) => add_dns_data(&mut data),
        None => {}
    }
}

fn add_dns_data(data: &mut SQLColumnAssociaions) {
    match (data.0.iter().position(|r| r == "ip"), data.0.iter().position(|r| r == "dns_name")) {
        (Some(_), Some(_)) => {},
        (None, Some(dns_i)) => {
            // let adr: IpAddr = lookup_host(&data.1[dns_i]).unwrap()[0];
            let ip = match lookup_host(&data.1[dns_i]) {
                Ok(ips) => ips[0],
                Err(_) => {return},
            };
            match ip {
                IpAddr::V4(ip) => {data.0.push(String::from("ip")); data.1.push(format!("{}", ip));}
                IpAddr::V6(ip) => {data.0.push(String::from("ipv6")); data.1.push(format!("{}", ip));}
            }
            // println!("added ip adr");
        },
        (Some(_ip_i), None) => {},
        (None, None) => {},
    }
}

fn store_data(output: &String, cmd: String, client: &mut Client, configs: &config_loading::Config) -> Result<u64, String> { 
    
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    // println!("line => ^{:?}?", tmp_output);
    let mut table_datas: SQLTableDatas = Vec::new();

    let mut tmp_table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();
    let time: DateTime<Local> = Local::now();
    let cmd = format!("'{}'", cmd);
    tmp_table_data.insert(
        "commands".to_string(),
        (
            vec!["command".to_string(), "local_time".to_string()],
            vec![cmd.clone(), format!("'{}'", time)],
        ),
    );
    table_datas.push(tmp_table_data);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        let mut table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string()) {
            Ok(data) => data,
            Err(e) => return Err(format!("store_data() | could not understand the output of the parser. error on key: '{}'. got error:\n{}",
            line, e))
        };
        add_params(params, &cmd, &mut table_data, configs);
        table_datas.push(table_data);
    }

    resolve_dnsnames(&mut table_datas);

    return match send_to_db(table_datas, cmd, client, configs) {
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!("store_data() | sending data to db failed with error:\n{}", mesg)),
    };
}

fn send_to_db(
    table_datas: SQLTableDatas,
    cmd: String,
    client: &mut Client,
    configs: &config_loading::Config,
) -> Result<u64, String> {
    let mut n_changes = 0;

    let pre_add_tables = ["commands", "hosts"];
    for table_data in &table_datas {
        for table_name in pre_add_tables {
            // println!("table name => {}", table_name);  // debug
            if let Some(data) = table_data.get(table_name) {
                // println!("inserting into => {}", table_name);  // debug
                n_changes += match insert_to(&table_name.to_string(), data, client, configs) {
                    Ok(n) => n,
                    Err(_mesg) => {
                        // println!("could not send data: '{:?}' to table '{}'. got error:\n{}\n", data, table_name, _mesg);
                        0
                        // return Err(format!("send_to_db() | could not send data to table '{}' no data will be sent. got error:\n{}", table_name, mesg)),
                    }
                };
                // table_data.remove(table_name);
            }
        }
    }

    // println!("table_datas :  {:?}", &table_datas);  // debug

    // add function call to change host and command values to their database IDs.
    let cmd_id = get_id("commands".to_string(), format!("command = {}", cmd), client)?
        .last()
        .unwrap()
        .to_owned();

    let mut new_table_datas: SQLTableDatas = Vec::new();
    for table_data in table_datas {
        let mut new_table_data = table_data.clone();
        // println!("table_data => {:#?}", table_data);
        for (key, value) in table_data {
            if pre_add_tables.contains(&key.as_str()) {
                continue;
            }
            let host_i = new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "host_uid");
            let cmd_i = &mut new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "command_uid");
            let port_i = new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "port_uid");

            if let Some(i) = host_i {
                let old_val = value.1[i].clone();
                // println!("old_val => {}", old_val);
                let host_uids = get_id(
                    "hosts".to_string(),
                    format!(
                        "ip = {} OR dns_name = {} OR local_name = {} OR ipv6 = {}",
                        old_val, old_val, old_val, old_val
                    ),
                    client,
                )?;
                new_table_data.get_mut(&key).unwrap().1[i] = host_uids
                .last()
                .unwrap()
                .to_owned();
                if let Some(j) = port_i {
                    match get_id("ports".to_string(), format!("port = {} AND host_uid = {}", value.1[j].clone(), host_uids.last().unwrap().to_owned()), client)?.last() {
                        Some(id) => new_table_data.get_mut(&key).unwrap().1[j] = String::from(id),
                        None => {},
                    }
                }
            };
            match cmd_i {
                Some(i) => {
                    new_table_data.get_mut(&key).unwrap().1[*i] = cmd_id.clone();
                }
                None => {
                    // println!("command_uid index not found adding manually");
                    new_table_data
                        .get_mut(&key)
                        .unwrap()
                        .0
                        .push("command_uid".to_string());
                    new_table_data.get_mut(&key).unwrap().1.push(cmd_id.clone());
                }
            }
        }
        new_table_datas.push(new_table_data);
    }

    for table_data in new_table_datas {
        for (table, value) in &table_data {
            if !pre_add_tables.contains(&table.as_str()) {
                n_changes += match insert_to(table, value, client, configs) {
                    Ok(n) => n,
                    Err(mesg) => return Err(format!("send_to_db() | could not send data to table '{}'. got error:\n{}", table, mesg)),
                };
            }
        }
        // println!("table_data {:#?}", table_data); // debug
    }
    Ok(n_changes)
}

fn get_id(table: String, condition: String, client: &mut Client) -> Result<Vec<String>, String> {
    get_id_safe(&table, condition, client)
}

fn get_id_safe(
    table: &String,
    condition: String,
    client: &mut Client,
) -> Result<Vec<String>, String> {
    // let select = "SELECT $2 FROM $1 WHERE ($2) = ($3)";
    let query = format!("SELECT id FROM {} WHERE {}", table, condition);
    // println!("query => {}", query); // debug
    let res = match client.query(&query, &[]) {
        Ok(response) => response,
        Err(e) => return Err(format!("get_id_safe() | querying server for row ids returned error:\n{}", e)),
    };

    // println!("from function get_id_safe, res: {:#?}", res); // debug

    if res.is_empty() {
        let entity_name = if table == "hosts" {
            "host"
        } else if table == "commands" {
            "command"
        } else {
            table
        };

        Err(format!("get_id_safe() | database returned no ids. the desired {} is not in the db yet.", entity_name))
    } else {
        let mut ns: Vec<String> = Vec::new();
        for row in res {
            ns.push(format!("{}", row.get::<usize, i32>(0)))
        }
        Ok(ns)
    }
}

fn row_exists(
    table: &String,
    overlap: &String,
    values: &SQLColumnAssociaions,
    sql_nul_val: &String,
    client: &mut Client,
) -> Result<Option<Vec<String>>, String> {
    
    let map_values = mapify_values(values);
    let mut condition = "".to_string();
    let mut operator = "";

    for token in overlap.split(' ') {
        if token == "AND" || token == "OR" {
            operator = token;
        } else if let Some(val) = map_values.get(token) {
            if val != sql_nul_val {
                condition = format!("{} {} {} = {}", condition, operator, token, val);
            }
        } else if let None = map_values.get(token) {
            // condition = format!("{}{} {} like '{}' ", condition, operator, token, "%");
            // panic!(
            //     "table '{}' does not have a column called '{}'",
            //     table, token
            // );
            // } else if operator == "=" {
            //     condition = format!("{}{} {} = '' ", condition, operator, token,);
        } else {
            return Err(format!("row_exists() | config error for overlap config for table: \"{}\"", table));
        }
    }
    condition = format!("{};", condition);
    // println!("condition: {:?}", condition);  // debug

    match get_id_safe(table, condition, client) {
        Ok(ids) => Ok(Some(ids)),
        Err(message) => Err(format!("row_exists() | failed to get id. got error:\n{}", message))
    }
}

fn mapify_values(values: &SQLColumnAssociaions) -> HashMap<&str, String> {
    let mut values_map: HashMap<&str, String> = HashMap::new();

    for (key, val) in values.0.iter().zip(values.1.clone()) {
        values_map.insert(key.as_str(), val);
    }

    values_map
}

/// modifies an exsition row to include new info.
fn mod_row(
    // n_changes: &mut i32,
    id: String,
    table: &String,
    values: &SQLColumnAssociaions,
    client: &mut Client,
) -> Result<u64, String> {
    let mut update_values: Vec<String> = Vec::new();
    let values_map: HashMap<&str, String> = mapify_values(values);

    // println!("map => {:?}", values_map); // map
    let cmd = format!(
        "SELECT {} FROM {} WHERE id = {}",
        values.0.join(", "),
        table,
        id
    );

    // println!("mod_row :  {}", &cmd); // debug
    let row_data: HashMap<&str, String> = match client.query(
        &cmd,
        &[],
    ) {
        Ok(res) => {
            let mut map: HashMap<&str, String> = HashMap::new();
            for (i, c_name) in values.0.iter().enumerate() {
                if c_name == "host_uid" || c_name == "command_uid" {
                    continue;
                }
                map.insert(c_name, res[0].get(i));
            }
            map
        }
        Err(message) => return Err(message.to_string()),
    };

    // let data_names: = Vec::new();

    for key in row_data.keys() {
        if let Some(output_data) = values_map.get(key) {
            update_values.push(format!("{} = {}", key, output_data));
        }
    }

    let update = &format!(
        "UPDATE {} SET {} WHERE id = {}",
        table,
        update_values.join(", "),
        id
    );

    // println!("UPDATE => {}", update); // debug

    // don't mod the row if the it already is what it should be.
    if get_n_rows(table,  &format!("{}", update_values.join(" AND ")), client)? == 0 {
        let res = client.execute(update, &[]);
        // println!("mod_row() | making row: {:?}", res);
        match res {
            Ok(_) => Ok(1),
            Err(e) => Err(format!("mod_row() | got sql error on update:\n{}", e)),
        }
    } else {
        Ok(0)
    }
}

fn get_n_rows(table: &String, condition: &str, client: &mut Client) -> Result<u64, String> {
    match client.query(&format!("SELECT id FROM {} WHERE {};", table, condition), &[]) {
        Ok(rows) => Ok(if table != "commands" {rows.len() as u64} else {0}),
        Err(mesg) => Err(format!("get_table_size() | could not query database for size of table '{}'. got error => {}", table, mesg))
    }
}

fn insert_to(
    table: &String,
    values: &SQLColumnAssociaions,
    client: &mut Client,
    configs: &config_loading::Config,
) -> Result<u64, String> {
    // println!("values => {:?}", values); // debug
    // let start_len = get_table_size(table, client)?;

    match configs.overlap.get(table) {
        Some(overlap) => {
            match row_exists(table, overlap, values, &configs.sql_nul_val, client) {
                Ok(Some(ids)) => {
                    let n = mod_rows(ids, table, values, client)?;
                    return if table != "commands" {
                        Ok(n)
                    } else {
                        Ok(0)
                    };
                    // return Ok(get_table_size(table, client)? - start_len)
                },
                Ok(None) => {},
                Err(_mesg) => {}
            }
        },
        None => {}
    }

    // let mut n_changes = 0;

    // println!("not moding row.");  // debug
    // println!("query: {}", &format!(
    //     "INSERT INTO {} ({}) VALUES ({})",
    //     &table,
    //     &values.0.join(", "),
    //     &values.1.join(", ")
    // ));  // debug
    let res = client.execute(
        &format!(
            "INSERT INTO {} ({}) VALUES ({})",
            &table,
            &values.0.join(", "),
            &values.1.join(", ")
        ),
        &[],
    );
    
    match res {
        Ok(_) => Ok(if table != "commands" {1} else {0}),
        Err(e) => Err(format!("insert_to() | got the following sql error when inserting new data into table '{}':\n{}", table, e)),
    }
}

fn mod_rows(ids: Vec<String>, table: &String, values: &SQLColumnAssociaions, client: &mut Client) -> Result<u64, String> {
    let mut n_changes = 0;
    
    for id in ids {
        match mod_row(id, table, values, client) {
            Ok(n_rows) => n_changes += n_rows,
            // Err(message) if message == "unknown overlap" => {}
            Err(message) => return Err(message),
        };
    }
    return Ok(n_changes)
}

fn add_param(base: &String, p_name: &str, p_opt: &Option<String>) -> Option<String> {
    match p_opt {
        Some(opt) => Some(format!("{} {}={}", base, p_name, opt)),
        None => None,
    }
}

pub fn connect(
    host: &String,
    user: &String,
    pass: &Option<String>,
    port: &str,
    db_name: &Option<String>,
    ssl_cert: &Option<String>,
    require_ssl: bool,
) -> Result<Client, String> {
    let mut con_config = format!("host={} user={}", host, user);
    
    if !host.starts_with("/") && !host.starts_with("~") {
        con_config = format!("{} port={}", con_config, port);
    }

    for (name, opt) in [("password", pass), ("dbname", db_name)] {
        match add_param(&con_config, name, opt) {
            Some(new_con_config) => con_config = new_con_config,
            None => {}

        }
    }

    if require_ssl {
        // this means that the connection will not be made unless ssl can be verified. 
        con_config = format!("{} sslmode=require", con_config);
    } else {
        // "sslmode" is set to "prefer" by default but this makes it explicit in my code.  
        con_config = format!("{} sslmode=prefer", con_config); 
    }

    let con = match ssl_cert {
        Some(cert_f) if !cert_f.is_empty() =>  Client::connect(&con_config, get_ssl(&tilde(cert_f))),
        _ => Client::connect(&con_config, NoTls),
    };

    match con {
        Ok(conection) => Ok(conection),
        Err(e) => {
            Err(
                format!(
                    "server connection error could not connect to sql database. got error:\n{}", e
                )
            )
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create sslconnector builder");
    builder
        .set_ca_file(ca_file)
        .expect(&format!("unable to load {}", ca_file));
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

fn get_cmd(log_data: &String) -> Result<(Vec<String>, String), String> {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(
                    dat.0
                        .replace("sudo", "")
                        .replace("doas", "")
                        .replace("time", "")
                        .trim()
                        .to_string(),
                );
                dat.1.to_owned()
            }
            None => return Err(String::new()),
            // None => return Err(format!("not enough lines found. {:?}", log_data)),
        }
    }

    // cmd_names.map(|s| s.replace("sudo" "").replace("doas", "").replace("time", "").trim());
    Ok((cmd_names, tmp_log))
}