#![warn(clippy::all)]
use chrono::prelude::*;
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::thread;
use std::process::exit;

pub mod config_loading; 

type SQLColumnNames = Vec<String>;
type SQLColumnValues = Vec<String>;
type SQLColumnAssociaions = (SQLColumnNames, SQLColumnValues);
type SQLTableData = HashMap<String, SQLColumnAssociaions>;
type SQLTableDatas = Vec<SQLTableData>;

// pub mod config_loading;

pub const CONFIG_ADR: &str = "~/.config/ptdb/config.toml";
// "/etc/ptdb/parsers" // "~/.local/share/ptdb/parsers/"
pub const PARSERS_DIR: &str = "~/Code/misc/PenTestDB/configs/etc/ptdb/parsers/";


pub fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

fn handle_client(mut stream: UnixStream) {
    // let (commands, log_data) = get_cmd(&read_log(&mut stream));
    process_raw_input(read_log(&mut stream));
    drop(stream);
}

pub fn process_raw_input(log: String) {
    if log.lines().count() < 3 {
        return
    }

    let (commands, log_data) = match get_cmd(&log) {
        Ok(res) => res,
        Err(e) => {
            eprintln!("{}", e);
            exit(1);
        }
    };
    let configs = config_loading::get_config(CONFIG_ADR);
    let engage_conf = config_loading::get_engagement(
        Path::new(CONFIG_ADR)
            .parent()
            .unwrap()
            .join(&configs.engagement_conf),
    );
    // let command = get_cmd(&log_data);
    // println!("commands {:#?}", commands);
    // print!("{}", log_data);
    // println!("============");
    if !engage_conf.complete {
        // add date check and turnning off of "complete flag" here as a conditional
        run_parsers(commands, log_data, configs, engage_conf);
    }
    // println!("done");
} 

fn run_parsers(
    commands: Vec<String>,
    log_data: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) {
    let parsers = &configs.parsers;
    let (command, parser) = match get_parser(&commands, parsers) {
        Ok((command, parser)) => (command, parser),
        Err(_) => return,
    };
    // println!("parsers {:?}", configs.parsers);
    let parser_adr = match &configs.server.parser_dir {
        Some(path) => Path::new(&shellexpand::tilde(&path).to_string()).to_owned(),
        None => Path::new(&shellexpand::tilde(PARSERS_DIR).to_string()).to_owned(),
    }
    .join(parser);
    // println!("parser adr => {:#?}", parser_adr);
    if parser_adr.exists() {
        parse(&parser_adr, log_data, command.clone(), configs, engage_conf);
        // println!("parsed output or command: {:?}", command);
    } else {
        println!(
            "parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        );
    }
}

fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config_loading::ParserConf>>,
) -> Result<(String, String), ()> {
    // println!("get_parser");
    for i in 0..3 {
        // println!("command => {}", commands[2 - i]);
        let cmd = &commands[2 - i];
        // let exec = cmd.split_once(' ').into_iter().nth(0).expect(&cmd);
        let (exec, given_args): (String, Vec<String>) = match cmd.split_once(' ') {
            Some((exec, args)) => (
                exec.to_string(),
                args.split(' ').map(|x| x.to_string()).collect(),
            ),
            None => (cmd.clone(), Vec::new()),
        };

        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Ok((cmd.clone(), parser.parser.clone()));
                        }
                    }
                }
            }
            match default {
                Some(parser) => return Ok((cmd.clone(), parser)),
                None => {
                    println!("a parser for {} is not in config file.", exec)
                }
            }
        }
    }
    Err(())
}

fn get_default_parser(parsers: &Vec<config_loading::ParserConf>) -> Option<String> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser.parser.clone()),
        }
    }
    None
}

fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg.to_string()) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
    }
    true
}

fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) {
    let mut child = Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn child process");

    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let output = String::from_utf8_lossy(
        &child
            .wait_with_output()
            .expect("Failed to read stdout")
            .stdout,
    )
    .to_string();
    // output = &output.stdout;
    // println!("output: \n{}", output);

    if !output.is_empty() {
        //do SQL stuff with output.
        match merge_to_db(output, cmd.clone(), config, engage_conf) {
            Ok(_) => {}
            Err(e) => eprintln!("[ERROR] Failed to merge data from command '{}'. got error:\n{}", cmd, e),
        }
    }
}

fn merge_to_db(
    output: String,
    cmd: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<(), String> {
    let mut client = connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.port,
        &engage_conf.name,
        configs.sql.ssl,
    )?;
    // ensure_db(&mut client, engage_conf.name);
    store_data(output, cmd, &mut client, &configs)?;
    let _ = client.close();
    Ok(())
}

fn parse_output(line: String) -> Result<HashMap<String, String>, String> {
    // let tmp_line = line.clone();
    let mut params: HashMap<String, String> = HashMap::new();
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    // println!("tokens len => {}", tokens.len());
    // println!(
    //     "tokens last 2 => {} {}",
    //     tokens[tokens.len() - 2],
    //     tokens[tokens.len() - 1]
    // );
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        println!();
        return Err("[ERROR] every key needs a value!".to_string());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.insert(key.to_string(), value.to_string());
    }

    Ok(params)
}

fn add_params(
    params: HashMap<String, String>,
    cmd: &String,
    table_data: &mut HashMap<String, (Vec<String>, Vec<String>)>,
    configs: &config_loading::Config,
    // _client: &mut Client,
) {
    // println!("add_params");
    let mut host_ip = "".to_string();
    // let _host_id: i32 = -1;
    // let cmd = format!("{}", cmd);
    // let _cmd_id: i32 = -1;
    let mut tables = Vec::new();
    // let params = params.clone();
    // params.insert("cmd".to_string(), cmd.clone());

    for (key, value) in params {
        let table = match configs.sql_tables.get(&key) {
            Some(table) => table,
            None => {
                // println!("unknown column. what is\"{}\"?", key);
                continue;
            }
        };

        if configs.common_id.contains(&key) {
            host_ip = value.clone();
        }

        // println!("{}", table);

        tables.push(table);

        // if table_data.contains_key(&table.to_string()) {
        match table_data.get_mut(&table.to_string()) {
            Some(data) => {
                data.0.push(key.clone());
                data.1.push(value.clone());
            }
            None => {
                table_data.insert(table.to_string(), (vec![key.clone()], vec![value.clone()]));
            }
        }
    }

    // add cmd and host
    for table in ["ports", "web_dirs", "passwds"] {
        // for (c_name, id) in [("command", cmd.to_string())] {
        for (c_name, id) in [("command", cmd.to_string()), ("host", host_ip.to_string())] {
            // for (c_name, id) in [("host", host_ip.to_string())] {
            if table_data.contains_key(&table.to_string()) {
                // println!("adding {}:{} to table: {}", c_name, id, table);
                table_data
                    .get_mut(&table.to_string())
                    .unwrap()
                    .0
                    .push(c_name.to_string());
                table_data.get_mut(&table.to_string()).unwrap().1.push(id);
            }
            // }
        }
    }
}

fn store_data(output: String, cmd: String, client: &mut Client, configs: &config_loading::Config) -> Result<(), String> {
    // let insert = "INSERT INTO $1($2) VALUES($3)";
    // let select = "SELECT $2 FROM $1 WHERE ($2) = ($3)";
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    // println!("line => ^{:?}?", tmp_output);
    let mut table_datas: SQLTableDatas = Vec::new();

    let mut tmp_table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();
    let time: DateTime<Local> = Local::now();
    let cmd = format!("'{}'", cmd);
    tmp_table_data.insert(
        "commands".to_string(),
        (
            vec!["cmd".to_string(), "local_time".to_string()],
            vec![cmd.clone(), format!("'{}'", time)],
        ),
    );
    table_datas.push(tmp_table_data);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        let mut table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string()) {
            Ok(data) => data,
            Err(_e) => return Err(format!("[Error] could not understand the output of the parser. next. error on key: ^{}?",
            line))
        };
        add_params(params, &cmd, &mut table_data, configs);
        table_datas.push(table_data);
    }

    send_to_db(table_datas, cmd, client, configs)?;
    Ok(())
}

fn send_to_db(
    table_datas: SQLTableDatas,
    cmd: String,
    client: &mut Client,
    configs: &config_loading::Config,
) -> Result<(), String> {
    let pre_add_tables = ["commands", "hosts"];
    for table_data in &table_datas {
        for table_name in pre_add_tables {
            // println!("table name => {}", table_name);
            if let Some(table) = table_data.get(table_name) {
                // println!("inserting into => {}", table_name);
                insert_to(&table_name.to_string(), table, client, configs)?;
                // table_data.remove(table_name);
            }
        }
    }

    // println!("table_datas :  {:?}", &table_datas);

    // add function call to change host and command values to their database IDs.
    let cmd_id = get_id("commands".to_string(), format!("cmd = {}", cmd), client)?
        .last()
        .unwrap()
        .to_owned();
    let mut new_table_datas: SQLTableDatas = Vec::new();
    for table_data in table_datas {
        let mut new_table_data = table_data.clone();
        // println!("table_data => {:#?}", table_data);
        for (key, value) in table_data {
            if pre_add_tables.contains(&key.as_str()) {
                continue;
            }
            let host_i = new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "host");
            let cmd_i = &mut new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "command");
            if let Some(i) = host_i {
                let old_val = value.1[i].clone();
                // println!("old_val => {}", old_val);
                new_table_data.get_mut(&key).unwrap().1[i] = get_id(
                    "hosts".to_string(),
                    format!(
                        "ip = {} OR dns_name = {} OR local_name = {} OR ipv6 = {}",
                        old_val, old_val, old_val, old_val
                    ),
                    client,
                )?
                .last()
                .unwrap()
                .to_owned();
            }
            match cmd_i {
                Some(i) => {
                    new_table_data.get_mut(&key).unwrap().1[*i] = cmd_id.clone();
                }
                None => {
                    // printlnmap_values.get(token)!("cmd index not found adding manually");
                    new_table_data
                        .get_mut(&key)
                        .unwrap()
                        .0
                        .push("command".to_string());
                    new_table_data.get_mut(&key).unwrap().1.push(cmd_id.clone());
                }
            }
        }
        new_table_datas.push(new_table_data);
    }

    for table_data in new_table_datas {
        for (table, value) in &table_data {
            if !pre_add_tables.contains(&table.as_str()) {
                insert_to(table, value, client, configs)?;
            }
        }
        // println!("{:#?}", table_data);
    }
    Ok(())
}

fn get_id(table: String, condition: String, client: &mut Client) -> Result<Vec<String>, String> {
    get_id_safe(&table, condition, client)
}

fn get_id_safe(
    table: &String,
    condition: String,
    client: &mut Client,
) -> Result<Vec<String>, String> {
    // let select = "SELECT $2 FROM $1 WHERE ($2) = ($3)";
    let query = format!("SELECT id FROM {} WHERE {}", table, condition);
    // println!("query => {}", query); // debug
    let res = match client.query(&query, &[]) {
        Ok(responce) => responce,
        Err(e) => return Err(format!("could not query server. got error => {}", e)),
    };

    // println!("{:#?}", res);

    if res.is_empty() {
        Err("database returned no id line".to_string())
    } else {
        let mut ns: Vec<String> = Vec::new();
        for row in res {
            ns.push(format!("{}", row.get::<usize, i32>(0)))
        }
        Ok(ns)
    }
}

fn row_exists(
    table: &String,
    overlap: &String,
    values: &SQLColumnAssociaions,
    // sql_nul_val: &String,
    client: &mut Client,
) -> Result<Option<Vec<String>>, String> {
    
    let map_values = mapify_values(values);
    let mut condition = "".to_string();
    let mut operator = "";

    for token in overlap.split(' ') {
        if token == "AND" || token == "OR" {
            // condition = format!("{} {}", condition, token);
            operator = token;
        } else if let Some(val) = map_values.get(token) {
            condition = format!("{}{} {} = {} ", condition, operator, token, val);
        } else if let None = map_values.get(token) {
            // condition = format!("{}{} {} like '{}' ", condition, operator, token, "%");
            // panic!(
            //     "table '{}' does not have a column called '{}'",
            //     table, token
            // );
            // } else if operator == "=" {
            //     condition = format!("{}{} {} = '' ", condition, operator, token,);
        } else {
            return Err(format!("config error for overlap. {}", table));
        }
    }
    condition = format!("{};", condition);

    match get_id_safe(table, condition, client) {
        Ok(ids) => Ok(Some(ids)),
        Err(message) => Err(format!("[ERROR] => {}", message))
    }
}

fn mapify_values(values: &SQLColumnAssociaions) -> HashMap<&str, String> {
    let mut values_map: HashMap<&str, String> = HashMap::new();

    for (key, val) in values.0.iter().zip(values.1.clone()) {
        values_map.insert(key.as_str(), val);
    }

    values_map
}

/// modifies an exsition row to include new info.
fn mod_row(
    id: String,
    table: &String,
    values: &SQLColumnAssociaions,
    client: &mut Client,
) -> Result<(), String> {
    let mut update_values: Vec<String> = Vec::new();
    let values_map: HashMap<&str, String> = mapify_values(values);

    // println!("map => {:?}", values_map); // map

    let row_data: HashMap<&str, String> = match client.query(
        &format!(
            "SELECT {} FROM {} WHERE id = {}",
            values.0.join(", "),
            table,
            id
        ),
        &[],
    ) {
        Ok(res) => {
            let mut map: HashMap<&str, String> = HashMap::new();
            for (i, c_name) in values.0.iter().enumerate() {
                if c_name == "host" {
                    continue;
                }
                map.insert(c_name, res[0].get(i));
            }
            map
        }
        Err(message) => return Err(message.to_string()), // return Err(format!("[INFO] => the host at the id {} has disapeared form the database", id)),
    };

    // println!("safe");

    for key in row_data.keys() {
        if let Some(output_data) = values_map.get(key) {
            update_values.push(format!("{} = {}", key, output_data));
        }
    }

    let update = &format!(
        "UPDATE {} SET {} WHERE id = {}",
        table,
        update_values.join(", "),
        id
    );

    // println!("UPDATE => {}", update); // debug

    let res = client.query(update, &[]);
    match res {
        Ok(_) => {}
        Err(e) => println!("got sql error on update => {}", e),
    }

    Ok(())
}

fn insert_to(
    table: &String,
    values: &SQLColumnAssociaions,
    client: &mut Client,
    configs: &config_loading::Config,
) -> Result<(), String> {
    // println!("values => {:?}", values); // debug

    if let Some(overlap) = configs.overlap.get(table) && let Ok(Some(ids)) = row_exists(table, overlap, values, client) {
        // println!("TABLES => {}", table); // debug 
        for id in ids {
            match mod_row(id, table, values, client) {
                Ok(_) => {}
                Err(message) if message == "unknown overlap" => {}
                Err(message) => {
                    println!("err {}", message);
                },
            };
        }
        return Ok(())
    }

    // println!("not moding row.");  // debug
    let res = client.query(
        &format!(
            "INSERT INTO {} ({}) VALUES ({})",
            &table,
            &values.0.join(", "),
            &values.1.join(", ")
        ),
        &[],
    );
    // println!("res {:?}", res);
    match res {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("got sql error => {}", e)),
    }
    // println!("{:?}", res);
}

fn connect(
    host: &String,
    user: &String,
    port: &String,
    db_name: &String,
    use_ssl: Option<bool>,
) -> Result<Client, String> {
    let ssl = use_ssl.unwrap_or(false);
    // this would look REALLY flipping ugly on one line.
    let con = if ssl {
        Client::connect(
            &format!(
                "host={} user={} port={} dbname={} sslmode=require",
                host, user, port, db_name
            ),
            get_ssl("/tmp/ca.cert"),
        )
    } else {
        Client::connect(
            &format!(
                "host={} user={} port={} dbname={}",
                host, user, port, db_name
            ),
            NoTls,
        )
    };

    match con {
        Ok(conection) => Ok(conection),
        Err(e) => {
            println!("server connection error => {}", e);
            Err("could not connect to sql database. :(".to_string())
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create sslconnector builder");
    builder
        .set_ca_file(ca_file)
        .expect("unable to load ca.cert");
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

fn get_cmd(log_data: &String) -> Result<(Vec<String>, String), String> {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(
                    dat.0
                        .replace("sudo", "")
                        .replace("doas", "")
                        .replace("time", "")
                        .trim()
                        .to_string(),
                );
                dat.1.to_owned()
            }
            None => return Err(format!("only one line found. {:?}", log_data)),
        }
    }

    // cmd_names.map(|s| s.replace("sudo" "").replace("doas", "").replace("time", "").trim());
    Ok((cmd_names, tmp_log))
}