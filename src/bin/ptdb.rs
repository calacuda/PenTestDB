#![warn(clippy::all)]
// use std::ascii::AsciiExt;
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use clap::{Command, ArgMatches, Arg, ArgAction};
use shellexpand::tilde;
use toml;
use std::fs::File;
use std::io::Error;
use strip_ansi_escapes;
use prettytable::{Table, Row, format};
use std::fs;
use std::collections::{HashSet, hash_set::IntoIter};


mod ptdb_lib;

fn main() {
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let engagement = ptdb_lib::config_loading::get_engagement(&format!("{}{}", ptdb_lib::CONFIG_DIR, configs.engagement_conf));

    // if engagement.complete {
    //     println!("the engagement is complete! quiting.");
    //     exit(0);
    // }

    let matches = get_args();

    match matches.subcommand() {
        Some(("server", _)) if !engagement.complete && configs.active => server_mode(),
        Some(("client", _)) if !engagement.complete && configs.active => client_mode(&configs.server.socket),
        Some(("parse", m)) if !engagement.complete && configs.active => manual_mode(m.clone()),
        Some(("engagement", m)) => engage_mode(m, configs),
        Some(("query", m)) => query_mode(m, configs, &engagement),
        Some(("pause", _m)) => pause(),
        Some(("resume", _m)) => resume(),
        // None => manual_mode(matches),
        // None => test_mode(matches),
        Some((_, _)) => {},
        None => {},
    }

    if engagement.complete {
        println!("the engagement is complete! quitting.");
        exit(0);
    }
}

fn pause() {
    change_config("active", "false", ptdb_lib::CONFIG_ADR);
    println!("paused parsing of commands. run the command \"ptdb resume\" to resume parsing.");
}

fn resume() {
    change_config("active", "true", ptdb_lib::CONFIG_ADR);
    println!("parsing of commands has been resumed.");
}

fn client_mode(serv_soc: &String) {
    println!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[PTDB ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin! WHY?!");
            exit(1);
        }
    };
    // println!("returning buf");
    buf
}

fn server_mode() {
    println!("starting server...");
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let socket_adr = configs.server.socket;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.6")
        .about("Parses the output of pen-testing commands and stores them in a database.")
        .subcommand_required(true)  // uncomment before release.
        .subcommand(
            Command::new("server")
                .about("Runs in server mode")
        )
        .subcommand(
            Command::new("client")
                .about("Runs in client mode (requires another instance running in server mode.)")
        )
        .subcommand(
            Command::new("parse")
                .about("Runs in stand alone mode. (ie. all commands are parsed and sent to the database from the current process. NOTE: that this is blocking.)")
                .arg(
                    Arg::new("quiet")
                    .long("quiet")
                    .short('q')
                    .required(false)
                    .action(ArgAction::SetTrue)
                    .help("Suppresses all output. (will not suppress fatal errors, like sql errors.)")
                )
                .arg(
                    Arg::new("command-name")
                    .long("command")
                    .short('c')
                    .value_name("EXECUTABLE-NAME")
                    .required(false)
                    .num_args(1)
                    .help("Sets the command. helpful for when you need to pipe the output of a command directly into ptdb.")
                )
        )
        .subcommand(
            Command::new("engagement")
                .about("get info about an engagement or make new ones. if no engagement is specified, the current engagement is used by default.")
                .arg(
                    Arg::new("new")
                    .long("new")
                    .short('n')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(1)
                    .conflicts_with_all(["engage", "complete", "remove"])
                    .help("makes a new engagement and switches to it.")
                )
                .arg(
                    Arg::new("engage")
                    .long("engagement")
                    .short('e')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(0..=1)
                    .conflicts_with_all(["complete", "new", "remove", "activate"])
                    .help("get info on a specific engagement")
                )
                .arg(
                    Arg::new("complete")
                    .long("is-complete")
                    .short('c')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(0..=1)
                    .conflicts_with_all(["engage", "new", "remove", "activate"])
                    .help("returns if the given engagement is completed. if no engagement is provided it will use the current engagement from the config file.")
                )
                .arg(
                    Arg::new("remove")
                    .long("delete")
                    .short('d')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(1)
                    .conflicts_with_all(["engage", "new", "complete", "activate"])
                    .help("removes an engagement data-base from the sql server.")
                )
                .arg(
                    Arg::new("activate")
                    .long("activate")
                    .short('a')
                    .alias("switch-to")
                    .short_alias('s')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(0..=1)
                    .conflicts_with_all(["engage", "complete", "remove"])
                    .help("activates an engagement in the config file. aliases include ['--switch-to', '-s'].")
                )
        )
        .subcommand(
            Command::new("query")
                .about("Used to query the engagement data-bases. if no engagement is specified, the current engagement is used by default.")
                .arg(
                    Arg::new("get")
                    .long("select")
                    .short('s')
                    .alias("get")
                    .short_alias('g')
                    .value_name("DATA-TO-PRINT")
                    .num_args(1..)
                    .help("the information to print to the console. (ie. what columns to SELECT from the database). aliases include ['--get', '-g'].")
                )
                .arg(
                    Arg::new("engagement")
                    .long("engagement")
                    .short('e')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(1)
                    .help("the engagement database to query.")
                )
                .arg(
                    Arg::new("sql_query")
                    .long("sql")
                    .short('q')
                    .alias("sql-query")
                    .alias("query")
                    .value_name("SQL-QUERY")
                    .num_args(1)
                    .conflicts_with_all(["get", "engagement", "condition", "target"])
                    .help("manually specify the sql, query. aliases include ['--sql-query', '--query'].")
                )
                .arg(
                    Arg::new("condition")
                    .long("where")
                    .short('w')
                    .alias("if")
                    .short_alias('i')
                    .value_name("WHERE-CLAUSE")
                    .num_args(1)
                    .help("specify the where clause of the query. aliases include ['', ''].")
                )
                .arg(
                    Arg::new("target")
                    .long("from")
                    .short('f')
                    .alias("target")
                    .short_alias('t')
                    .value_name("TARGET") // parse as an Option<String>
                    .num_args(1)
                    .required(true)
                    .help("the target to select from. targets are defined in the config file. aliases include ['--target', '-t']. targets are tables that are joined with other tables using the \"JOIN\" keyword. (or when using the '--list-columns' flag)")
                )
                .arg(
                    Arg::new("get-columns")
                    .long("list-columns")
                    .short('l')
                    .alias("columns")
                    .alias("get-columns")
                    .alias("list")
                    .short_alias('c')
                    // .value_name("") // parse as an Option<String>
                    .num_args(0)
                    .action(ArgAction::SetTrue)
                    // .required(true)
                    .help("lists the columns that can be selected from the target. aliases include ['--get-columns', '--columns', '--list', 'c']. (targets are designated with the '--from' or '--target').")
                )
        )
        .subcommand(
            Command::new("pause")
                .about("pauses the interpretation of commands until the resume command is received.")
        )
        .subcommand(
            Command::new("resume")
                .about("resumes the interpretation of commands from a paused state.")
        )
        .get_matches()
}

fn parse_arg_bool(matches: ArgMatches, option: &str, default: bool) -> bool {
    match matches.get_one::<bool>(option) {
        Some(value) => *value,
        None => default,
    }
}

/// entry point when running in manual mode.
fn parse_str_now(log: String, matches: ArgMatches) {
    match ptdb_lib::process_raw_input(log, true, matches.get_one::<String>("command-name")) {
        Ok(mesg) =>  ptdb_lib::console_log(&mesg, parse_arg_bool(matches, "quiet", false)),
        Err(mesg) =>  ptdb_lib::console_log(&mesg, false),
    };
}

fn manual_mode(matches: ArgMatches) {
    let buf = get_std_in();

    match strip_ansi_escapes::strip(&buf) {
        Ok(raw_text) => {
            match std::str::from_utf8(&raw_text) {
                Ok(log_d) => parse_str_now(log_d.to_string(), matches),
                Err(e) => {
                    eprintln!("[PTDB ERROR] could not interpret text on stdin as UTF-8. Are you sure is was ONLY text?");
                    eprintln!("got error message:");
                    eprintln!("{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("[PTDB ERROR] failed to strip ansi control codes from input.\ngot error message:\n{}", e);
            exit(1);
        }
    }
}

fn make_fname(dir: &str, name: Option<String>, alt: String) -> String {
    tilde(&format!("{}/{}", dir, match name {
        Some(file) => make_toml(&file),
        None => make_toml(&alt),
    })).to_string()
}

fn make_toml(fname: &str) -> String {
    if fname.ends_with(".toml") || fname.ends_with(".tml") {
        String::from(fname)
    } else {
        format!("{}.toml", fname)
    }
}

fn complete(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("The '{}' engagement is {}!", engage.name, if engage.complete {"complete"} else {"incomplete"});
}

fn info(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, configs: ptdb_lib::config_loading::Config, matches: &ArgMatches) -> Result<(), Error> {
    let path = make_fname(engagement_dir, None, name.clone());
    let conf = ptdb_lib::config_loading::EngageConf {
        name: name.clone(),
        complete: false,
    };

    if !Path::new(&path).exists() {
        // println!("conf file already exsists at location: '{}' .", path);
        // exit(1);
        let mut output = File::create(path)?;

        write!(output, "{}", match toml::to_string(&conf) {
            Ok(s) => s,
            Err(_) => {
                println!("could not serialize engagement configuration.");
                exit(1);
            }
        })?;
        println!("file created!");
    }

    match make_sql_db(&name, configs) {
        Ok(_) => {}
        Err(m) => {
            eprintln!("{}", m);
            exit(1);
        }
    };

    if matches.contains_id("activate") {
        change_config("engagement_conf", &format!("\"{}\"", &make_toml(&name)), ptdb_lib::CONFIG_ADR);
        println!("the engagement, \"{}\", is now active.", name);
    }

    Ok(())
}

fn make_sql_db(name: &str, configs: ptdb_lib::config_loading::Config) -> Result<(), String> {
    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &None,
        &configs.sql.ssl_cert,
    )?;
    
    // println!("client connected!");
    let cmd = format!("CREATE DATABASE \"{}\" TEMPLATE \"{}\";", name, configs.sql.template_db);
    // println!("{}", cmd);
    let _foo = client.execute(&cmd, &[]);
    let _ = client.close();
    println!("db created!");

    Ok(())
}

fn change_config(val_name: &str, new_val: &str, config_file: &str) {
    match fs::read_to_string(format!("{}", tilde(config_file))) {
        Ok(text) => {
            match mod_conf(&text, val_name, new_val, config_file) {
                Ok(_) => {},
                Err(e) => {
                    eprintln!("could not read/write from/to config file. got error:\n{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("could not read config file. got error:\n{}", e);
            exit(1);
        }
    };
}

fn mod_conf(text: &str, val_name: &str, new_val: &str, config_file: &str) -> Result<(), Error> {
    let mut file = File::create(format!("{}", tilde(config_file)))?;

    for line in text.lines() {
        if line.starts_with(&format!("{}=", val_name)) || line.starts_with(&format!("{} =", val_name)) {
            file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
        } else {
            file.write(format!("{}\n", line).as_bytes())?;
        };
    };

    Ok(())
}

fn engage_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config) {
    // println!("engage mode");
    if matches.contains_id("new") {
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), ptdb_lib::CONFIG_DIR, configs, matches);
            },
            None => {
                eprintln!("--new requires the name of the engagement you want to make.");
                exit(1);
            }
        }
    }
    else if matches.contains_id("engage") {
        info(matches.get_one::<String>("engage").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    }
    else if matches.contains_id("complete") {
        complete(matches.get_one::<String>("complete").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    } else if matches.contains_id("activate") {
        match matches.get_one::<String>("activate") {
            Some(engagement) => {
                change_config("engagement_conf", &format!("\"{}\"", make_toml(engagement)), ptdb_lib::CONFIG_ADR);
                println!("the engagement, \"{}\", is now active.", engagement);
            }
            None => {
                eprintln!("--activate requires the name of the engagement you want to activate.");
                exit(1);
            }
        }
    }
}

/// this shoudl really be renamed bc its NOT ONLY for usr defined sql queries. its for making
/// any sql query that it a full query defined in a string. (provided you know the engagement that is. 
/// but the template database can be used as a default.) 
fn usr_sql_query(query: &String, engagement: &String, configs: &ptdb_lib::config_loading::Config) -> Result<(), String> {
    // println!("not yet implemented.");
    let mut client = match ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &Some(engagement.clone()),
        &configs.sql.ssl_cert,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            ptdb_lib::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    for column in query.clone().split(' ') {
        if column.to_lowercase() == "select" {
            continue;
        } else if column.to_lowercase() == "from" {
            break;
        } else {
            titles.push(String::from(column));
        }
    }

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    if !res.is_empty() {
        print_table(res);
        let _ = client.close();
        Ok(())
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

fn generic_query(
    get_arg: Vec<String>, 
    engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: ptdb_lib::config_loading::Config,
    engage_conf: &ptdb_lib::config_loading::EngageConf
)  -> Result<(), String> {
    let select_clause = format!("SELECT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    let engagement = match engagement_arg {
        Some(engagement) => engagement,
        None => engage_conf.name.clone(),
    };
    let from_clause = match configs.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, from_clause, where_clause); // SELECT {select_clause}
    usr_sql_query(&cmd, &engagement, &configs)
}

fn get_tables(target: &str) -> IntoIter<&str> {
    let mut table_names: HashSet<&str> = HashSet::new();
    let tokens = target.split(' ');
    let mut last_token = "";

    for token in tokens {
        if last_token == "FROM" || last_token == "JOIN" {
            let _ = table_names.insert(token.clone());
        }
        last_token = token;
    }

    table_names.into_iter()
}

fn get_column_names(target_name: &str, engagement_arg: &Option<String>, configs: &ptdb_lib::config_loading::Config) {
    let engagement = match engagement_arg {
        Some(engage) => engage,
        None => &configs.sql.template_db,
    };
    let target = match configs.targets.get(target_name) {
        Some(target) => target,
        None => {
            println!("target \"{}\" is not in the config file.", target_name);
            return
        }
    };
    
    let columns = get_tables(target);
    let where_clause = columns
                            .map(|x| format!("table_name = '{}'", x))
                            .collect::<Vec<String>>()
                            .join(" OR ");

    // println!("where_clause: {}", where_clause);

    let query = format!(
        "SELECT table_name, column_name FROM information_schema.columns WHERE {} ORDER BY table_name;",
        where_clause
    );

    match usr_sql_query(&query, engagement, configs) {
        Ok(_) => {},
        Err(e) => {
            eprintln!("get_column_names() | could not get the columns for the tables from in the target: {}. got error:\n{}", target, e);
            exit(1);
        }
    };
}

fn query_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config, engage_conf: &ptdb_lib::config_loading::EngageConf) {
    // println!("query mode");
    let engagement = get_as_opt(matches, "engagement");

    if Some(&true) == matches.get_one::<bool>("get-columns") {
        get_column_names(&get_as_str(matches, "target", None), &engagement, &configs);
        // return;
    } else if let Some(query) = matches.get_one::<String>("sql_query") {
        match usr_sql_query(query, &engage_conf.name, &configs) {
            Ok(_) => {}
            Err(m) => ptdb_lib::console_log(&m, false),
        }
        // return;
    } else {
        let get_args = match matches.get_many::<String>("get") {
            Some(columns) => columns.cloned().map(|x| x.replace(",", "")).collect::<Vec<String>>(),
            None => vec!["*".to_string()],
        };
        
        let res = generic_query(
                    get_args,
                    engagement,
                    //   get_as_opt(matches, "engagement"),
                    get_as_str(matches, "condition", Some("")), 
                    get_as_str(matches, "target", None),
                    configs,
                    &engage_conf
                    );

        match res {
            Ok(_) => {}
            Err(message) => {
                eprintln!("[PTDB ERROR] could not query database. got error:\n{}", message);
                exit(1);
            }
        }
    }
}

fn get_as_opt(matches: &ArgMatches, option: &str) -> Option<String> {
    matches.get_one::<String>(option).cloned()
}

fn get_as_str(matches: &ArgMatches, option: &str, alt: Option<&str>) -> String {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>(option) {
        Some(columns) => columns.clone(),
        None => match alt {
            Some(alt_text) => alt_text.to_string(),
            None => {
                eprintln!("The argument, \"{}\", is required in this context but was not present. please try again.", option);
                exit(1);
            }
        }
    }
}

fn print_table(sql_rows: Vec<postgres::Row>) {
    let mut table = Table::new();
    // table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
    table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    // let mut titles = input_titles;
    let titles = make_title(&sql_rows[0]);
    table.set_titles(Row::from(titles));

    for sql_row in sql_rows {
        // let r= make;
        table.add_row(Row::from(make_printable_row(sql_row)));
    }
    // println!("titles : {:?}", titles);

    // Print the table to stdout
    table.printstd();
    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

fn make_printable_row(sql_row: postgres::Row) -> Vec<String> {
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            format!("{}", sql_row.get::<usize, i32>(i))
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

fn make_title(sql_row: &postgres::Row) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}