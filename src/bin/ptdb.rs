#![warn(clippy::all)]
// use std::ascii::AsciiExt;
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::fs::symlink;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use clap::{Command, ArgMatches, Arg, ArgAction};
use shellexpand::tilde;
use toml;
use std::fs::{File, remove_file};
use std::io::Error;
use strip_ansi_escapes;
use prettytable::{Table, Row, format};
use std::fs;
use std::collections::{HashSet, hash_set::IntoIter};


mod ptdb_lib;

fn main() {
    let configs = ptdb_lib::config_loading::get_config();
    let engagement = ptdb_lib::config_loading::get_engagement(ptdb_lib::ENGAGEMENT_ADR);

    // if engagement.complete {
    //     println!("the engagement is complete! quiting.");
    //     exit(0);
    // }

    let matches = get_args();

    match matches.subcommand() {
        Some(("server", _)) if !engagement.complete && configs.active => server_mode(),
        Some(("client", _)) if !engagement.complete && configs.active => client_mode(&configs.server_mode.socket_adr),
        Some(("parse", m)) if !engagement.complete && configs.active => manual_mode(m.clone(), configs, engagement),
        Some(("engagement", m)) => engage_mode(m),
        Some(("query", m)) => query_mode(m, configs, &engagement),
        Some(("pause", _)) => pause(),
        Some(("resume", _)) => resume(),
        Some(("config", m)) => config(m),
        Some(("info", _)) => info_dump(configs, engagement),
        // None => manual_mode(matches),
        // None => test_mode(matches),
        Some(("server", _)) | Some(("client", _)) | Some(("parse", _)) if engagement.complete => {
            println!("the engagement is complete! quitting.");
            exit(0);
        }
        Some((_, _)) => {},
        None => {},
    }
}

fn info_dump(config: ptdb_lib::config_loading::Config, engagement: ptdb_lib::config_loading::EngageConf) {
    // (engagement sql database name, host of current database, if engagement is complete)
    // println!("db name   =>  {}", engagement.name);
    // println!("db host   =>  {}", config.sql.host);
    // println!("complete  =>  {}", engagement.complete);
    // println!("parsing   =>  {}", config.active);
    println!("database name    =>  {}", engagement.name);
    println!("database host    =>  {}", config.sql.host);
    println!("engage complete  =>  {}", engagement.complete);
    println!("active status    =>  {}", if config.active {"active"} else {"paused"});
}

fn config(matches: &ArgMatches) {
    if let Some(sql_server) = matches.get_one::<String>("switch-sql") {
        // activate_server(sql_server);
        change_config("db_conf", &format!("\"{}\"", sql_server), ptdb_lib::ENGAGEMENT_ADR);        
        println!("switched server to \"{}\".", sql_server);
    }

    if let Some(enagement) = matches.get_one::<String>("switch-engagement") {
        activate_engagement(None, enagement);
        println!("the engagement, \"{}\", is now active.", enagement);
    }
}

// fn activate_server(sql_server: &str) {
//     let fname = make_fname(ptdb_lib::DB_DIR, None, sql_server);
//     // println!("{}", &fname); // debug
//     // if new engagement exists:s
//     if Path::new(&fname).exists() {
//         // remove sym link,
//         match remove_file(tilde(ptdb_lib::DB_ADR).to_string()) {
//             Ok(_) => {},
//             Err(e) => {
//                 println!("could not remove file. got error: {}", e);
//                 exit(1);
//             },
//         }
//         // replace sym link
//         match symlink(&fname, tilde(ptdb_lib::DB_ADR).to_string()) {
//             Ok(_) => {},
//             Err(e) => {
//                 println!("could not add symlink. got error: {}", e);
//                 exit(1);
//             }
//         }
//     } else { 
//         // else print error
//         eprintln!("could not create symlink to the sql server config file located at <{}>", fname);
//         exit(1);
//     }
// }

fn pause() {
    change_config("active", "false", ptdb_lib::config_loading::USR_CONFIG_ADR);
    println!("paused parsing of commands. run the command \"ptdb resume\" to resume parsing.");
}

fn resume() {
    change_config("active", "true", ptdb_lib::config_loading::USR_CONFIG_ADR);
    println!("parsing of commands has been resumed.");
}

fn client_mode(serv_soc: &String) {
    println!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[PTDB ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            // println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin!");
            exit(1);
        }
    };
    // println!("returning buf");
    buf
}

fn server_mode() {
    println!("starting server...");
    let configs = ptdb_lib::config_loading::get_config();
    let socket_adr = configs.server_mode.socket_adr;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.10")
        .about("Parses the output of pen-testing commands and stores them in a database.")
        .subcommand_required(true)
        .subcommand(
        Command::new("server")
            .about("Runs in server mode")
        )
        .subcommand(
        Command::new("client")
            .about("Runs in client mode (requires another instance running in server mode.)")
        )
        .subcommand(
        Command::new("parse")
            .about("Runs in stand alone mode. (ie. all commands are parsed and sent to the database from the current process. NOTE: that this is blocking.)")
            .arg(
                Arg::new("quiet")
                .long("quiet")
                .short('q')
                .required(false)
                .action(ArgAction::SetTrue)
                .help("Suppresses all output. (will not suppress fatal errors, like sql errors.)")
            )
            .arg(
                Arg::new("command-name")
                .long("command")
                .short('c')
                .value_name("EXECUTABLE-NAME")
                .required(false)
                .num_args(1)
                .help("Sets the command. helpful for when you need to pipe the output of a command directly into ptdb.")
            )
            .arg(
                Arg::new("exit-status")
                .long("exit-status")
                .short('e')
                .value_name("EXIT_STATUS")
                .required(false)
                .num_args(1)
                .help("the exit status of the command being parsed.")
            )
        )
        .subcommand(
        Command::new("engagement")
            .about("get info about an engagement or make new ones. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("new")
                .long("new")
                .short('n')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("makes a new engagement and switches to it.")
            )
            .arg(
                Arg::new("engage")
                .long("engagement")
                .short('e')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["complete", "new", "remove", "activate"])
                .help("get info on a specific engagement")
            )
            .arg(
                Arg::new("complete")
                .long("is-complete")
                .short('c')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "new", "remove", "activate"])
                .help("returns if the given engagement is completed. if no engagement is provided it will use the current engagement from the config file.")
            )
            .arg(
                Arg::new("remove")
                .long("delete")
                .short('d')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "new", "complete", "activate"])
                .help("removes an engagement data-base from the sql server.")
            )
            .arg(
                Arg::new("activate")
                .long("activate")
                .short('a')
                .alias("switch-to")
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("activates an engagement in the config file. aliases include ['--switch-to', '-s'].")
            )
            .arg(
                Arg::new("sql-server")
                .long("server")
                .short('s')
                .value_name("DB-SERVER-CONF-FILE")
                .num_args(1)
                .conflicts_with_all(["engage", "complete"])
                .help("the sql server config file to use. \"default\" is assumed if this argument is not provided.")
            )
        )
        .subcommand(
        Command::new("query")
            .about("Used to query the engagement data-bases. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("get")
                .long("select")
                .short('s')
                .alias("get")
                .short_alias('g')
                .value_name("COLUMNS-TO-RETRIEVE")
                .num_args(1..)
                .help("the information to print to the console. (ie. what columns to SELECT from the database). aliases include ['--get', '-g'].")
            )
            .arg(
                Arg::new("engagement")
                .long("engagement")
                .short('e')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .help("the engagement database to query.")
            )
            .arg(
                Arg::new("sql_query")
                .long("sql")
                .short('q')
                .alias("sql-query")
                .alias("query")
                .value_name("SQL-QUERY")
                .num_args(1)
                .conflicts_with_all(["get", "condition", "target"])
                .help("manually specify the sql, query. aliases include ['--sql-query', '--query'].")
            )
            .arg(
                Arg::new("condition")
                .long("where")
                .short('w')
                .alias("if")
                .short_alias('i')
                .value_name("WHERE-CLAUSE")
                .num_args(1)
                .help("specify the where clause of the query. aliases include ['', ''].")
            )
            .arg(
                Arg::new("target")
                .long("from")
                .short('f')
                .alias("target")
                .short_alias('t')
                .value_name("TARGET") // parse as an Option<String>
                .num_args(1)
                .required(true)
                .help("the target to select from. targets are defined in the config file. aliases include ['--target', '-t']. targets are tables that are joined with other tables using the \"JOIN\" keyword. (or when using the '--list-columns' flag)")
            )
            .arg(
                Arg::new("get-columns")
                .long("list-columns")
                .short('l')
                .alias("columns")
                .alias("get-columns")
                .alias("list")
                .short_alias('c')
                .num_args(0)
                .action(ArgAction::SetTrue)
                .help("lists the columns that can be selected from the target. aliases include ['--get-columns', '--columns', '--list', 'c']. (targets are designated with the '--from' or '--target').")
            )
        )
        .subcommand(
            Command::new("pause")
                .about("Pauses the interpretation of commands until the resume command is received.")
        )
        .subcommand(
            Command::new("resume")
                .about("Resumes the interpretation of commands from a paused state.")
        )
        .subcommand(
        Command::new("config")
            .about("Used to change configurations.")
            .arg(
                Arg::new("switch-engagement")
                .long("s-eng")
                .short('e')
                .alias("switch-engagement")
                .value_name("ENGAGEMENT-CONF")
                .num_args(1)
                .help("switches to the selected engagement config.")
            )
            .arg(
                Arg::new("switch-sql")
                .long("s-sql")
                .short('s')
                .alias("switch-sql")
                .value_name("SQL-SERVER-CONF")
                .num_args(1)
                .help("switches to the selected SQL server config.")
            )
        )
        .subcommand(
            Command::new("info")
                .about("Prints information about the current state.")
        )
        .get_matches()
}

fn parse_arg_bool(matches: ArgMatches, option: &str, default: bool) -> bool {
    match matches.get_one::<bool>(option) {
        Some(value) => *value,
        None => default,
    }
}

/// entry point when running in manual mode.
/// TODO: make it use the quite flag instead of hardcoding 'true'  
fn parse_str_now(
    log: String,
    exit_status: i32,
    matches: ArgMatches, 
    configs: ptdb_lib::config_loading::Config, 
    engage_conf: ptdb_lib::config_loading::EngageConf
) {
    match ptdb_lib::process_raw_input(format!("{}\n{}", exit_status, log), true, matches.get_one::<String>("command-name"), configs, engage_conf) {
        Ok(mesg) =>  ptdb_lib::console_log(&mesg, parse_arg_bool(matches, "quiet", false)),
        Err(mesg) =>  ptdb_lib::console_log(&mesg, false),
    };
}

fn manual_mode(
    matches: ArgMatches, 
    configs: ptdb_lib::config_loading::Config, 
    engage_conf: ptdb_lib::config_loading::EngageConf
) {
    let buf = get_std_in();
    let es = match matches.get_one::<String>("exit-status") {
        Some(es) => match es.parse::<i32>() {
            Ok(num) => num,
            Err(_mess) => {
                ptdb_lib::console_log("exit status must be parsable as an i32.", false);
                exit(1);
            }
        },
        None => 0,
    };

    match strip_ansi_escapes::strip(&buf) {
        Ok(raw_text) => {
            match std::str::from_utf8(&raw_text) {
                Ok(log_d) => {
                    parse_str_now(log_d.to_string(), es, matches, configs, engage_conf);
                    // println!("{}", log_d);
                }
                Err(e) => {
                    eprintln!("[PTDB ERROR] could not interpret text on stdin as UTF-8. Are you sure is was ONLY text?");
                    eprintln!("got error message:");
                    eprintln!("{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("[PTDB ERROR] failed to strip ansi control codes from input.\ngot error message:\n{}", e);
            exit(1);
        }
    }
    // parse_str_now(String::from_utf8(buf).unwrap(), es, matches, configs, engage_conf)
}

fn make_fname(dir: &str, name: Option<String>, alt: &str) -> String {
    let name = match name {
        Some(file) => ptdb_lib::config_loading::make_toml(&file),
        None => ptdb_lib::config_loading::make_toml(&alt),
    };
    tilde(&if name.starts_with("~/") || name.starts_with("/") {name} else {format!("{}/{}", dir, name)}).to_string()
}

// fn make_toml(fname: &str) -> String {
//     if fname.ends_with(".toml") || fname.ends_with(".tml") {
//         String::from(fname)
//     } else {
//         format!("{}.toml", fname)
//     }
// }

fn complete() {
    // let fname = make_fname(dir, name, ptdb_lib::ENGAGEMENT_ADR);
    let engage = ptdb_lib::config_loading::get_engagement(ptdb_lib::ENGAGEMENT_ADR);

    println!("The '{}' engagement is {}!", engage.name, if engage.complete {"complete"} else {"incomplete"});
}

fn info(name: Option<String>, dir: &str, current: &str) {
    let fname = make_fname(dir, name, &current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, matches: &ArgMatches) -> Result<(), Error> {
    let path = make_fname(engagement_dir, None, &name);
    let conf = ptdb_lib::config_loading::EngageConfRaw {
        name: name.clone(),
        complete: false,
        db_conf: matches.get_one::<String>("sql-server").cloned(),
    }.defaultify();

    println!("making file at location: '{}'.", path);

    if !Path::new(&path).exists() {
        // println!("conf file already exsists at location: '{}' .", path);
        // exit(1);
        let mut output = File::create(path)?;

        write!(output, "{}", match toml::to_string(&conf) {
            Ok(s) => s,
            Err(_) => {
                println!("could not serialize engagement configuration.");
                exit(1);
            }
        })?;
        println!("file created!");
    }

    if matches.contains_id("activate") {
        // change_config("engagement_conf", &format!("\"{}\"", &make_toml(&name)), ptdb_lib::CONFIG_ADR);
        activate_engagement(matches.get_one::<String>("activate").cloned(), &ptdb_lib::config_loading::make_toml(&name));
        println!("the engagement, \"{}\", is now active.", name);
    }

    match make_sql_db(&name, ptdb_lib::config_loading::get_config()) {
        Ok(_) => {}
        Err(m) => {
            eprintln!("{}", m);
            exit(1);
        }
    };

    Ok(())
}

fn activate_engagement(engagement_1: Option<String>, engagement_2: &str) {
    let fname = make_fname(ptdb_lib::ENGAGEMENTS_DIR, engagement_1, engagement_2);
    // println!("{}", &fname); // debug
    // if new engagement exists:
    if Path::new(&fname).exists() {
        // remove sym link,
        match remove_file(tilde(ptdb_lib::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {},
            Err(e) => {
                println!("could not remove file. got error: {}", e);
                exit(1);
            },
        }
        // replace sym link
        match symlink(&fname, tilde(ptdb_lib::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {},
            Err(e) => {
                println!("could not add symlink. got error: {}", e);
                exit(1);
            }
        }
    } else { 
        // else print error
        eprintln!("could not create symlink to the engagement file located at <{}>", fname);
        exit(1);
    }
}

fn make_sql_db(name: &str, configs: ptdb_lib::config_loading::Config) -> Result<(), String> {
    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &None,
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    )?;

    let create_db = format!("CREATE DATABASE \"{}\";", name);
    match client.execute(&create_db, &[]) {
        Ok(_) => {}
        Err(mesg) => return Err(format!("could not create an sql database called \"{}\". got error:\n{}", name, mesg)),
    }
    let _ = client.close();

    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &Some(String::from(name)),
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    )?;
    let format_db = match std::fs::read_to_string(ptdb_lib::MAKE_SQL_DB) {
        Ok(contents) => contents,
        Err(mesg) => return Err(format!("could not read the sql database, template file. got error:\n{}", mesg)),
    };

    let res = client.batch_execute(&format_db);
    let _ = client.close();
    
    match res {
        Ok(_) => {
            println!("db created!");
            Ok(())
        }
        Err(mesg) => Err(format!("could not set up the sql database with the required tables. got error:\n{}", mesg))
    }
}

fn change_config(val_name: &str, new_val: &str, config_file: &str) {
    match fs::read_to_string(format!("{}", tilde(config_file))) {
        Ok(text) => {
            match mod_conf(&text, val_name, new_val, config_file) {
                Ok(_) => {},
                Err(e) => {
                    eprintln!("could not read/write from/to config file. got error:\n{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("could not read config file. got error:\n{}", e);
            exit(1);
        }
    };
}

fn mod_conf(text: &str, val_name: &str, new_val: &str, config_file: &str) -> Result<(), Error> {
    let mut file = File::create(format!("{}", tilde(config_file)))?;
    let mut changed = false;

    for line in text.lines() {
        if line.starts_with(&format!("{}=", val_name)) || line.starts_with(&format!("{} =", val_name)) {
            file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
            changed = true;
        } else {
            file.write(format!("{}\n", line).as_bytes())?;
        };
    };

    if !changed {
        file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
    }

    Ok(())
}

fn engage_mode(matches: &ArgMatches) {
    // println!("engage mode");
    if matches.contains_id("new") {
        // TODO: make this an if let Some(...) ...
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), ptdb_lib::ENGAGEMENTS_DIR, matches);
            },
            None => {
                // unreachable but necessary to unwrap the Option<String> returned by .get_one(...)
                eprintln!("--new requires the name of the engagement you want to make.");
                exit(1);
            }
        }
    }
    else if matches.contains_id("engage") {
        info(matches.get_one::<String>("engage").cloned(), ptdb_lib::CONFIG_DIR, ptdb_lib::ENGAGEMENT_ADR)
    }
    else if matches.contains_id("complete") {
        complete()
    } else if matches.contains_id("activate") {
        match matches.get_one::<String>("activate") {
            Some(engagement) => {
                // change_config("engagement_conf", &format!("\"{}\"", make_toml(engagement)), ptdb_lib::CONFIG_ADR);
                activate_engagement(None, &engagement);
                println!("the engagement, \"{}\", is now active.", engagement);
            }
            None => {
                eprintln!("--activate requires the name of the engagement you want to activate.");
                exit(1);
            }
        }
    }
}

/// this shoudl really be renamed bc its NOT ONLY for usr defined sql queries. its for making
/// any sql query that it a full query defined in a string. (provided you know the engagement that is. 
/// but the template database can be used as a default.) 
fn usr_sql_query(
    query: &String, 
    engagement: Option<String>, 
    configs: &ptdb_lib::config_loading::Config
) -> Result<(), String> {
    println!("{:?}", engagement);
    let mut client = match ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &engagement,
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            ptdb_lib::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    for column in query.clone().split(' ') {
        if column.to_lowercase() == "select" {
            continue;
        } else if column.to_lowercase() == "from" {
            break;
        } else {
            titles.push(String::from(column));
        }
    }

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    let _ = client.close();

    if !res.is_empty() && !titles.is_empty() {
        print_table(res);
        Ok(())
    } else if !res.is_empty() && titles.is_empty() {
        println!("{:?}", res);
        Ok(())
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

fn generic_query(
    get_arg: Vec<String>, 
    engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: ptdb_lib::config_loading::Config,
    engage_conf: &ptdb_lib::config_loading::EngageConf
)  -> Result<(), String> {
    let select_clause = format!("SELECT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    let engagement = match engagement_arg {
        Some(engagement) if engagement.is_empty() => None,
        Some(engagement) => Some(engagement),
        None => Some(engage_conf.name.clone()),
    };
    let from_clause = match configs.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, from_clause, where_clause); // SELECT {select_clause}
    usr_sql_query(&cmd, engagement, &configs)
}

fn get_tables(target: &str) -> IntoIter<&str> {
    let mut table_names: HashSet<&str> = HashSet::new();
    let tokens = target.split(' ');
    let mut last_token = "";

    for token in tokens {
        if last_token == "FROM" || last_token == "JOIN" {
            let _ = table_names.insert(token.clone());
        }
        last_token = token;
    }

    table_names.into_iter()
}

fn get_column_names(target_name: &str, engagement_arg: Option<String>, configs: &ptdb_lib::config_loading::Config, engage_conf: &ptdb_lib::config_loading::EngageConf) {
    let engagement = match engagement_arg {
        Some(engage) => Some(engage),
        // None => &configs.sql.template_db,
        None => Some(engage_conf.name.clone()),
    };
    let target = match configs.targets.get(target_name) {
        Some(target) => target,
        None => {
            println!("target \"{}\" is not in the config file.", target_name);
            return
        }
    };
    
    let columns = get_tables(target);
    // println!("columns : {:?}", &columns);
    let where_clause = columns
                            .map(|x| format!("table_name = '{}'", x))
                            .collect::<Vec<String>>()
                            .join(" OR ");

    // println!("where_clause: {}", where_clause);

    let query = format!(
        "SELECT table_name, column_name FROM information_schema.columns WHERE {} ORDER BY table_name;",
        where_clause
    );
    // println!("sql query: {}", query);

    match usr_sql_query(&query, engagement, configs) {
        Ok(_) => {},
        Err(e) => {
            eprintln!("get_column_names() | could not get the columns for the tables from in the target: {}. got error:\n{}", target, e);
            exit(1);
        }
    };
}

fn query_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config, engage_conf: &ptdb_lib::config_loading::EngageConf) {
    // println!("query mode");
    let engagement = get_engagement_as_opt(matches, &engage_conf.name);

    if Some(&true) == matches.get_one::<bool>("get-columns") {
        get_column_names(&get_as_str(matches, "target", None), engagement, &configs, engage_conf);
        // return;
    } else if let Some(query) = matches.get_one::<String>("sql_query") {
        match usr_sql_query(query, engagement, &configs) {
            Ok(_) => {}
            Err(m) => ptdb_lib::console_log(&m, false),
        }
        // return;
    } else {
        let get_args = match matches.get_many::<String>("get") {
            Some(columns) => columns.cloned().map(|x| x.replace(",", "")).collect::<Vec<String>>(),
            None => vec!["*".to_string()],
        };
        
        let res = generic_query(
                    get_args,
                    engagement,
                    //   get_as_opt(matches, "engagement"),
                    get_as_str(matches, "condition", Some("")), 
                    get_as_str(matches, "target", None),
                    configs,
                    &engage_conf
                    );

        match res {
            Ok(_) => {}
            Err(message) => {
                eprintln!("[PTDB ERROR] could not query database. got error:\n{}", message);
                exit(1);
            }
        }
    }
}

fn get_engagement_as_opt(matches: &ArgMatches, alt: &str) -> Option<String> {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>("engagement").cloned() {
        Some(engagement) => {
            // if the user says `-e ""`
            if !engagement.is_empty() {
                Some(engagement.clone())
            } else {
                None
            }
        }
        None => {
            // if the user includes the -e flag but provides no option
            if !matches.contains_id("engagement") {
                Some(String::from(alt))
            } else {
                None
            }
        }
    }
}

fn get_as_str(matches: &ArgMatches, option: &str, alt: Option<&str>) -> String {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>(option) {
        Some(columns) => columns.clone(),
        None => match alt {
            Some(alt_text) => alt_text.to_string(),
            None => {
                eprintln!("The argument, \"{}\", is required in this context but was not present. please try again.", option);
                exit(1);
            }
        }
    }
}

fn print_table(sql_rows: Vec<postgres::Row>) {
    let mut table = Table::new();
    table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
    // table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    // let mut titles = input_titles;
    let n_rows = sql_rows.len();
    let titles = make_title(&sql_rows[0]);
    table.set_titles(Row::from(titles));

    for sql_row in sql_rows {
        // let r= make;
        table.add_row(Row::from(make_printable_row(sql_row)));
    }
    // println!("titles : {:?}", titles);

    // Print the table to stdout
    table.printstd();
    println!("({} rows of data)", n_rows);
    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

fn make_printable_row(sql_row: postgres::Row) -> Vec<String> {
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            format!("{}", sql_row.get::<usize, i32>(i))
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

fn make_title(sql_row: &postgres::Row) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}