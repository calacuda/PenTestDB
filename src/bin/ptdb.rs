#![warn(clippy::all)]
use anyhow::Result;
use clap::{Arg, ArgAction, ArgMatches, Command};
use fern::colors::{Color, ColoredLevelConfig};
use log::{debug, error, info};
use ptdb::config::{get_config, Config};
use ptdb::db_com;
use ptdb::sql::make_new_sql_db;
use ptdb::{config, paused_locally};
use ptdb_lib as ptdb;
use shellexpand::tilde;
use std::fs::{read_to_string, remove_file, File};
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::fs::symlink;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use toml;

fn main() {
    logger_init();

    let configs = config::get_config();
    let matches = get_args();

    if let Some(("engagement", m)) = matches.subcommand() {
        engage_mode(m, configs);
    } else {
        let engagement = config::get_engagement(db_com::ENGAGEMENT_ADR);

        match matches.subcommand() {
            Some(("server", _)) if !engagement.complete && configs.active => server_mode(),
            Some(("client", _)) if !engagement.complete && configs.active => {
                client_mode(&configs.server_mode.socket_adr)
            }
            Some(("parse", m)) if !engagement.complete && configs.active && !paused_locally() => {
                manual_mode(m.clone(), configs, engagement)
            }
            // Some(("engagement", m)) => engage_mode(m, configs),
            Some(("query", m)) => query_mode(m, configs, engagement),
            Some(("pause", m)) => pause(m),
            Some(("resume", m)) => resume(m),
            Some(("config", m)) => config(m),
            Some(("info", _)) => info_dump(configs, engagement),
            // None => manual_mode(matches),
            // None => test_mode(matches),
            Some(("server", _)) | Some(("client", _)) | Some(("parse", _))
                if engagement.complete =>
            {
                info!("the engagement is complete! quitting.");
                exit(0);
            }
            Some((_, _)) => {}
            None => {}
        }
    }
}

fn info_dump(configs: config::Config, engagement: config::EngageConf) {
    let local = if !paused_locally() {
        "active"
    } else {
        "paused"
    };

    println!("database name    =>  {}", engagement.name);
    println!("database host    =>  {}", configs.db_server.host);
    println!("engage complete  =>  {}", engagement.complete);
    println!(
        "active status    =>  global: {} | local: {}",
        if configs.active { "active" } else { "paused" },
        local
    );
}

fn config(matches: &ArgMatches) {
    if let Some(sql_server) = matches.get_one::<String>("switch-sql") {
        // activate_server(sql_server);
        change_config(
            "db_conf",
            &format!("\"{}\"", sql_server),
            db_com::ENGAGEMENT_ADR,
        );
        println!("switched server to \"{}\".", sql_server);
    }

    if let Some(enagement) = matches.get_one::<String>("switch-engagement") {
        activate_engagement(None, enagement);
        println!("the engagement, \"{}\", is now active.", enagement);
    }
}

fn pause_globally() {
    change_config("active", "false", config::USR_CONFIG_ADR);
    println!("paused parsing of commands. run the command \"ptdb resume\" to resume parsing.");
}

fn pause_terminal() -> anyhow::Result<()> {
    write_to_pause_f(b"true")?;
    println!("parsing of commands has been paused locally.");
    Ok(())
}

fn pause(matches: &ArgMatches) {
    if parse_arg_bool(matches.clone(), "global", false) {
        pause_globally();
    } else {
        if let Err(e) = pause_terminal() {
            error!("unknown error encountered while pausing session. error message: \"{e}\"");
            info!("session NOT paused!");
        }
    }
}

fn write_to_pause_f(contents: &[u8]) -> anyhow::Result<()> {
    let mut file = File::create(crate::config::get_pause_f()?)?;
    file.write_all(contents)?;
    Ok(())
}

fn resume_globally() {
    change_config("active", "true", config::USR_CONFIG_ADR);
    info!("parsing of commands has been resumed.");
}

fn resume_terminal() -> anyhow::Result<()> {
    write_to_pause_f(b"false")?;
    info!("parsing of commands in the current session has been resumed.");
    Ok(())
}

fn resume(matches: &ArgMatches) {
    if parse_arg_bool(matches.clone(), "global", false) {
        resume_globally();
    } else {
        if let Err(e) = resume_terminal() {
            error!("unknown error encountered while resuming session. error message: \"{e}\"");
            info!("session will NOT be resumed!");
        }
    }
}

fn client_mode(serv_soc: &String) {
    info!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc); // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            error!(
                "[PTDB ERROR] couldn't connect to socket at \"{}\"",
                server_soc
            );
            info!("Hints:");
            info!(" - Do you have the socket configured corectly?");
            info!(" - Is the server running?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            error!("could not send data to server.");
            debug!("{e}");
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            error!("failed to shutdown write access to socket file.");
            // println!("program will now hang.");
            debug!("{e}");
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            error!("could not read stdin!");
            exit(1);
        }
    };
    // println!("returning buf");
    buf
}

fn server_mode() {
    info!("starting server...");
    let configs = config::get_config();
    let socket_adr = configs.server_mode.socket_adr;
    let _ = ptdb::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.12")
        .about("Parses the output of pen-testing commands and stores them in a database.")
        .subcommand_required(true)
        .subcommand(
        Command::new("server")
            .about("Runs in server mode")
        )
        .subcommand(
        Command::new("client")
            .about("Runs in client mode (requires another instance running in server mode.)")
        )
        .subcommand(
        Command::new("parse")
            .about("Runs in stand alone mode. (ie. all commands are parsed and sent to the database from the current process. NOTE: that this is blocking.)")
            .arg(
                Arg::new("quiet")
                .long("quiet")
                .short('q')
                .required(false)
                .action(ArgAction::SetTrue)
                .help("Suppresses all output. (will not suppress fatal errors, like sql errors.)")
            )
            .arg(
                Arg::new("command-name")
                .long("command")
                .short('c')
                .value_name("EXECUTABLE-NAME")
                .required(false)
                .num_args(1)
                .help("Sets the command. helpful for when you need to pipe the output of a command directly into ptdb.")
            )
            .arg(
                Arg::new("exit-status")
                .long("exit-status")
                .short('e')
                .value_name("EXIT_STATUS")
                .required(false)
                .num_args(1)
                .help("the exit status of the command being parsed.")
            )
        )
        .subcommand(
        Command::new("engagement")
            .about("get info about an engagement or make new ones. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("new")
                .long("new")
                .short('n')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("makes a new engagement and switches to it.")
            )
            .arg(
                Arg::new("engage")
                .long("engagement")
                .short('e')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["complete", "new", "remove", "activate"])
                .help("get info on a specific engagement")
            )
            .arg(
                Arg::new("complete")
                .long("is-complete")
                .short('c')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "new", "remove", "activate"])
                .help("returns if the given engagement is completed. if no engagement is provided it will use the current engagement from the config file.")
            )
            .arg(
                Arg::new("remove")
                .long("delete")
                .short('d')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "new", "complete", "activate"])
                .help("removes an engagement data-base from the sql server.")
            )
            .arg(
                Arg::new("activate")
                .long("activate")
                .short('a')
                .visible_alias("switch-to")
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("activates an engagement in the config file. aliases include ['--switch-to', '-s'].")
            )
            .arg(
                Arg::new("sql-server")
                .long("server")
                .short('s')
                .value_name("DB-SERVER-CONF-FILE")
                .num_args(1)
                .conflicts_with_all(["engage", "complete"])
                .help("the sql server config file to use. \"default\" is assumed if this argument is not provided.")
            )
        )
        .subcommand(
        Command::new("query")
            .about("Used to query the engagement data-bases. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("get")
                .long("get")
                .short('g')
                .visible_alias("select")
                .visible_short_alias('s')
                .value_name("DATA-TO-RETRIEVE")
                .num_args(1..)
                // .required(true)
                .required_unless_present_any(["explicit_query", "get-predicates"])
                .help("the information to print to the console. (ie. what columns to SELECT from the database). aliases include ['--select', '-s'].")
            )
            .arg(
                Arg::new("engagement")
                .long("engagement")
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .help("the engagement database to query. (defaults to '~/.config/ptdb/engagement.toml')")
            )
            .arg(
                Arg::new("explicit_query")
                .long("query")
                .short('q')
                .value_name("QUERY")
                .num_args(1)
                .conflicts_with_all(["get", "require", "get-predicates"])
                .required_unless_present_any(["get", "target", "get-predicates"])
                .help("manually specify the SQL or GraphQL, query.")
            )
            .arg(
                Arg::new("condition")
                .long("where")
                .short('w')
                // .value_delimiter(',')
                .action(ArgAction::Append)
                .value_name("CONDITION")
                .num_args(1..)
                .help("specify an \"eq\" function call inside a filter derivative. this should be given in a data base specific format.")
            )
            .arg(
                Arg::new("require")
                .long("require")
                .short('r')
                .num_args(0..)
                // .action(ArgAction::SetFalse)
                .value_name("REQUIRED-PREDICATES")
                .help("require that listed predicates must be present in return value. (GraphQL Only)")
            )
            .arg(
                Arg::new("target")
                .long("from")
                .short('f')
                .alias("target")
                .short_alias('t')
                .value_name("TARGET") // parse as an Option<String>
                .num_args(1)
                // .required(true)
                .required_unless_present("explicit_query")
                .help("the target to select from. targets are defined in the config file. aliases include ['--target', '-t']. targets are tables that are joined with other tables using the \"JOIN\" keyword. (or when using the '--list-columns' flag)")
            )
            .arg( // make this get the schema
                Arg::new("get-predicates")
                .long("list-columns")
                .short('l')
                .alias("columns")
                .alias("get-columns")
                .alias("list")
                .alias("ls")
                .num_args(0)
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["get", "require", "explicit_query"])
                .help("lists the columns that can be selected from the target. aliases include ['--get-columns', '--columns', '--list', '--ls']. (targets are designated with the '--from' or '--target').")
            )
        )
        .subcommand(
            Command::new("pause")
                .about("Pauses the interpretation of commands until the resume command is issued. By default parsing will be paused for the current terminal session only. Adding \"--global\" will pause for all terminal session.")
                .arg(
                    Arg::new("global")
                    .long("global")
                    .short('g')
                    .num_args(0)
                    .action(ArgAction::SetTrue)
                    .help("pauses parsing globally.")
                )
        )
        .subcommand(
            Command::new("resume")
                .about("Resumes the interpretation of commands from a paused state.")
                .arg(
                    Arg::new("global")
                    .long("global")
                    .short('g')
                    .num_args(0)
                    .action(ArgAction::SetTrue)
                    .help("resumes parsing globally.")
                )
        )
        .subcommand(
        Command::new("config")
            .about("Used to change configurations.")
            .arg(
                Arg::new("switch-engagement")
                .long("s-eng")
                .short('e')
                .alias("switch-engagement")
                .value_name("ENGAGEMENT-CONF")
                .num_args(1)
                .help("switches to the selected engagement config.")
            )
            .arg(
                Arg::new("switch-sql")
                .long("s-sql")
                .short('s')
                .alias("switch-sql")
                .value_name("SQL-SERVER-CONF")
                .num_args(1)
                .help("switches to the selected SQL server config.")
            )
        )
        .subcommand(
            Command::new("info")
                .about("Prints information about the current state.")
        )
        .get_matches()
}

fn parse_arg_bool(matches: ArgMatches, option: &str, default: bool) -> bool {
    match matches.get_one::<bool>(option) {
        Some(value) => *value,
        None => default,
    }
}

fn parse_str_now(
    log: String,
    exit_status: i32,
    matches: ArgMatches,
    configs: config::Config,
    engage_conf: config::EngageConf,
) {
    match ptdb::process_raw_input(
        log,
        exit_status,
        true,
        matches.get_one::<String>("command-name"),
        configs,
        engage_conf,
    ) {
        Ok(mesg) => {
            if !mesg.is_empty() {
                println!("{mesg}")
            }
        }
        Err(mesg) => error!("{mesg}"),
    };
}

/// entry point when running in manual mode.
fn manual_mode(matches: ArgMatches, configs: config::Config, engage_conf: config::EngageConf) {
    let buf = get_std_in();
    let es = match matches.get_one::<String>("exit-status") {
        Some(es) => match es.parse::<i32>() {
            Ok(num) => num,
            Err(_mess) => {
                error!("exit status must be parsable as an i32.");
                exit(1);
            }
        },
        None => 0,
    };

    match matches.get_one::<String>("command-name") {
        Some(cmd_name) => {
            if ptdb::parser_exists(cmd_name.to_owned(), &configs) {
                // match strip_ansi_escapes::strip(&buf) {  // sometimes strips tab characters
                //     Ok(raw_text) => {
                match std::str::from_utf8(&buf) {
                    Ok(log_d) => {
                        parse_str_now(log_d.to_string(), es, matches, configs, engage_conf);
                    }
                    Err(e) => {
                        error!("could not interpret text on stdin as UTF-8. Are you sure is was ONLY text? got error message: {}", e);
                        exit(1);
                    }
                }
            }
        }
        None => {
            error!("the raw shell command must be provided with \"--command\"/ \"-c\"");
            exit(1);
        }
    };
}

fn make_fname(dir: &str, name: Option<String>, alt: &str) -> String {
    let name = match name {
        Some(file) => config::make_toml(&file),
        None => config::make_toml(&alt),
    };
    tilde(&if name.starts_with("~/") || name.starts_with("/") {
        name
    } else {
        format!("{}/{}", dir, name)
    })
    .to_string()
}

fn complete(engage_name: &str) {
    // let fname = make_fname(dir, name, db_com::ENGAGEMENT_ADR);
    if std::path::Path::new(engage_name).exists() {
        let engage = config::get_engagement(engage_name);

        println!(
            "The '{}' engagement is {}!",
            engage.name,
            if engage.complete {
                "complete"
            } else {
                "incomplete"
            }
        );
    } else {
        error!("No engagement by that name can be found.");
        exit(1);
    }
}

fn info(name: Option<String>, dir: &str, current: &str) {
    let fname = make_fname(dir, name, &current);
    let engage = config::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, matches: &ArgMatches) -> Result<()> {
    let path = make_fname(engagement_dir, None, &name);
    let conf = config::EngageConfRaw {
        name: name.clone(),
        complete: false,
        db_conf: matches.get_one::<String>("sql-server").cloned(),
    }
    .defaultify();

    info!("making file at location: '{}'.", path);

    if !Path::new(&path).exists() {
        // println!("conf file already exsists at location: '{}' .", path);
        // exit(1);
        let mut output = File::create(path)?;

        write!(
            output,
            "{}",
            match toml::to_string(&conf) {
                Ok(s) => s,
                Err(_) => {
                    error!("could not serialize engagement configuration.");
                    exit(1);
                }
            }
        )?;
        info!("file created!");
    }

    if matches.contains_id("activate") {
        // change_config("engagement_conf", &format!("\"{}\"", &make_toml(&name)), db_com::CONFIG_ADR);
        activate_engagement(
            matches.get_one::<String>("activate").cloned(),
            &config::make_toml(&name),
        );
        println!("the engagement, \"{}\", is now active.", name);
    }

    Ok(())
}

fn activate_engagement(engagement_1: Option<String>, engagement_2: &str) {
    let fname = make_fname(db_com::ENGAGEMENTS_DIR, engagement_1, engagement_2);
    debug!("{}", &fname);

    if Path::new(&fname).exists() {
        // remove sym link,
        match remove_file(tilde(db_com::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {}
            Err(e) => {
                error!("could not remove file. got error: {}", e);
                exit(1);
            }
        }
        // replace sym link
        match symlink(&fname, tilde(db_com::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {}
            Err(e) => {
                error!("could not add symlink. got error: {}", e);
                exit(1);
            }
        }
    } else {
        // else print error
        error!(
            "could not create symlink to the engagement file located at \"{}\"",
            fname
        );
        exit(1);
    }
}

fn change_config(val_name: &str, new_val: &str, config_file: &str) {
    match read_to_string(format!("{}", tilde(config_file))) {
        Ok(text) => match mod_conf(&text, val_name, new_val, config_file) {
            Ok(_) => {}
            Err(e) => {
                error!(
                    "could not read/write from/to config file. got error:\n{}",
                    e
                );
                exit(1);
            }
        },
        Err(e) => {
            error!("could not read config file. got error:\n{}", e);
            exit(1);
        }
    };
}

fn mod_conf(text: &str, val_name: &str, new_val: &str, config_file: &str) -> Result<()> {
    let mut file = File::create(format!("{}", tilde(config_file)))?;
    let mut changed = false;

    for line in text.lines() {
        if line.starts_with(&format!("{}=", val_name))
            || line.starts_with(&format!("{} =", val_name))
        {
            file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
            changed = true;
        } else {
            file.write(format!("{}\n", line).as_bytes())?;
        };
    }

    if !changed {
        file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
    }

    Ok(())
}

fn engage_mode(matches: &ArgMatches, configs: Config) {
    // println!("engage mode");
    if matches.contains_id("new") {
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), db_com::ENGAGEMENTS_DIR, matches);
                match configs.db_server.db_type {
                    config::DBType::SQL => {
                        if let Err(m) = make_new_sql_db(&name, get_config()) {
                            error!("{}", m);
                            exit(1);
                        }
                    }
                    config::DBType::GraphQL => {
                        todo!("Implement GraphQL");
                    }
                }
            }
            None => {
                // unreachable but necessary to unwrap the Option<String> returned by .get_one(...)
                error!("--new requires the name of the engagement you want to make.");
                exit(1);
            }
        }
    } else if matches.contains_id("engage") {
        info(
            matches.get_one::<String>("engage").cloned(),
            db_com::CONFIG_DIR,
            config::ENGAGEMENT_ADR,
        )
    } else if matches.contains_id("complete") {
        let default = db_com::ENGAGEMENT_ADR.to_string();
        let engage_name = matches.get_one::<String>("complete").unwrap_or(&default);
        complete(engage_name);
    } else if matches.contains_id("activate") {
        match matches.get_one::<String>("activate") {
            Some(engagement) => {
                // change_config("engagement_conf", &format!("\"{}\"", make_toml(engagement)), db_com::CONFIG_ADR);
                activate_engagement(None, &engagement);
                info!("the engagement, \"{}\", is now active.", engagement);
            }
            None => {
                error!("--activate requires the name of the engagement you want to activate.");
                exit(1);
            }
        }
    }
}

fn query_mode(matches: &ArgMatches, configs: config::Config, engage_conf: config::EngageConf) {
    // println!("query mode");
    let engagement = get_engagement_as_str(matches, &engage_conf.name);

    let res = if Some(&true) == matches.get_one::<bool>("get-predicates") {
        ptdb::get_data_names(matches, configs, engage_conf)
    } else if let Some(query) = matches.get_one::<String>("explicit_query") {
        ptdb::send_query(query, &configs, &engage_conf)
    } else {
        ptdb::gen_query(matches, &engagement, configs, engage_conf)
    };

    println!("{res}");
}

fn get_engagement_as_str(matches: &ArgMatches, alt: &str) -> String {
    match matches.get_one::<String>("engagement") {
        Some(name) => name.to_owned(),
        None => alt.to_string(),
    }
}

fn logger_init() {
    let colors = ColoredLevelConfig::new()
        .debug(Color::Blue)
        .info(Color::Green)
        .warn(Color::Magenta)
        .error(Color::Red);

    #[cfg(debug_assertions)]
    let res = fern::Dispatch::new()
        .format(move |out, message, record| {
            out.finish(format_args!(
                "[{} {}] {}",
                colors.color(record.level()),
                record.target(),
                message
            ))
        })
        .filter(|metadata| metadata.target().starts_with("ptdb"))
        .chain(std::io::stderr())
        // .chain(fern::log_file("output.log")?)
        .apply();

    #[cfg(not(debug_assertions))]
    let res = fern::Dispatch::new()
        .format(move |out, message, record| {
            out.finish(format_args!(
                "[{}] {}",
                colors.color(record.level()),
                message
            ))
        })
        .filter(|metadata| metadata.target().starts_with("ptdb"))
        .chain(std::io::stderr())
        // .chain(fern::log_file("output.log")?)
        .apply();

    if let Err(reason) = res {
        eprintln!("failed to initiate logger because {reason}");
    } else {
        log::debug!("logger initiated");
    }
}
