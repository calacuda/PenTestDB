#![warn(clippy::all)]
// #![feature(let_chains)]
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use clap::{Command, ArgMatches, Arg, ArgAction};
use shellexpand::tilde;
use toml;
use std::fs::File;
use std::io::Error;
use strip_ansi_escapes;
use prettytable::{Table, Row, format};

mod ptdb_lib;

fn main() {
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let engagement = ptdb_lib::config_loading::get_engagement(&format!("{}/{}", ptdb_lib::CONFIG_DIR, configs.engagement_conf));

    // if engagement.complete {
    //     println!("the engagement is complete! quiting.");
    //     exit(0);
    // }

    let matches = get_args();

    match matches.subcommand() {
        Some(("server", _)) if !engagement.complete => server_mode(),
        Some(("client", _)) if !engagement.complete => client_mode(&configs.server.socket),
        Some(("parse", m)) if !engagement.complete => manual_mode(m.clone()),
        Some(("engagement", m)) => engage_mode(m, configs),
        Some(("query", m)) => query_mode(m, configs, &engagement),
        // None => manual_mode(matches),
        // None => test_mode(matches),
        Some((_, _)) => {},
        None => {},
    }

    if engagement.complete {
        println!("the engagement is complete! quiting.");
        exit(0);
    }
}

fn client_mode(serv_soc: &String) {
    println!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[PTDB ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin! WHY?!");
            exit(1);
        }
    };
    // println!("returning buf");
    buf
}

fn server_mode() {
    println!("starting server...");
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let socket_adr = configs.server.socket;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.6")
        .about("Parses the output of pen-testing commands and stores them in a database.")
        .subcommand_required(true)  // uncomment before release.
        .subcommand(
            Command::new("server")
                .about("Runs in server mode")
        )
        .subcommand(
            Command::new("client")
                .about("Runs in client mode (requires another instance running in server mode.)")
        )
        .subcommand(
            Command::new("parse")
                .about("Runs in stand alone mode. (ie. all commands are parsed and sent to the database from the current process. NOTE: that this is blocking.)")
                .arg(
                    Arg::new("quiet")
                    .long("quiet")
                    .short('q')
                    .required(false)
                    .action(ArgAction::SetTrue)
                    .help("Suppresses all output. (will not suppress fatal errors, like sql errors.)")
                )
                .arg(
                    Arg::new("command-name")
                    .long("command")
                    .short('c')
                    .value_name("EXECUTABLE-NAME")
                    .required(false)
                    .num_args(1)
                    .help("Sets the command. helpful for when you need to pipe the output of a command directly into ptdb.")
                )
        )
        .subcommand(
            Command::new("engagement")
                .about("get info about an engagement or make new ones. if no engagement is specified, the current engagement is used by default.")
                .arg(
                    Arg::new("new")
                    .long("new")
                    .short('n')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(1)
                    .conflicts_with_all(["engage", "complete", "remove"])
                    .help("makes a new engagement and switches to it.")
                )
                .arg(
                    Arg::new("engage")
                    .long("engagement")
                    .short('e')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(0..=1)
                    .conflicts_with_all(["complete", "new", "remove"])
                    .help("get info on a specific engagement")
                )
                .arg(
                    Arg::new("complete")
                    .long("is-complete")
                    .short('c')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(0..=1)
                    .conflicts_with_all(["engage", "new", "remove"])
                    .help("returns if the given engagement is completed. if no engagement is provided it will use the current engagement from the config file.")
                )
                // .arg(
                //     Arg::new("remove")
                //     .long("delete")
                //     .short('d')
                //     .value_name("ENGAGEMENT-NAME")
                //     .num_args(1)
                //     .conflicts_with_all(["engage", "new", "complete"])
                //     .help("removes an engagement data-base from the sql server.")
                // )
            )
        .subcommand(
            Command::new("query")
                .about("Used to query the engagement data-bases. if no engagement is specified, the current engagement is used by default.")
                .arg(
                    Arg::new("get")
                    .long("get")
                    .short('g')
                    .alias("select")
                    .short_alias('s')
                    .value_name("DATA-TO-PRINT")  // make defautl value "*"
                    .num_args(1..)
                    .help("the information to print to the console. (ie. what columns to SELECT from the database)")
                )
                .arg(
                    Arg::new("engagement")
                    .long("engagement")
                    .short('e')
                    .value_name("ENGAGEMENT-NAME")
                    .num_args(1)
                    .help("the engagement databade to query.")
                )
                .arg(
                    Arg::new("sql_query")
                    .long("query")
                    .short('q')
                    .alias("sql")
                    .value_name("SQL-QUERY")
                    .num_args(1)
                    .conflicts_with_all(["get", "engagement", "condition", "target"])
                    .help("manually specify the sql, query.")  // make mutualy exclusive with all other flags
                )
                .arg(
                    Arg::new("condition")
                    .long("where")
                    .short('w')
                    .alias("if")
                    .short_alias('i')
                    .value_name("WHERE-CLAUSE")
                    .num_args(1)
                    .help("specify the where clause of the query")
                )
                .arg(
                    Arg::new("target")
                    .long("target")
                    .short('t')
                    .alias("from")
                    .short_alias('f')
                    .value_name("TARGET") // parse as an Option<String>
                    .num_args(1)
                    .required(true)
                    .help("what target to select from. targets are defined in the config file, they are a tabled that is joined to others using the \"JOIN\" keyword.")
                )
        )
        .get_matches()
}

fn parse_arg_bool(matches: ArgMatches, option: &str, default: bool) -> bool {
    match matches.get_one::<bool>(option) {
        Some(value) => *value,
        None => default,
    }
}

/// entry point when running in manual mode.
fn parse_str_now(log: String, matches: ArgMatches) {
    match ptdb_lib::process_raw_input(log, true, matches.get_one::<String>("command-name")) {
        Ok(mesg) =>  ptdb_lib::console_log(&mesg, parse_arg_bool(matches, "quiet", false)),
        Err(mesg) =>  ptdb_lib::console_log(&mesg, false),
    };
}

fn manual_mode(matches: ArgMatches) {
    let buf = get_std_in();

    match strip_ansi_escapes::strip(&buf) {
        Ok(raw_text) => {
            match std::str::from_utf8(&raw_text) {
                Ok(log_d) => parse_str_now(log_d.to_string(), matches),
                Err(e) => {
                    eprintln!("[PTDB ERROR] could not interpret text on stdin as UTF-8. Are you sure is was ONLY text?");
                    eprintln!("got error message:");
                    eprintln!("{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("[PTDB ERROR] failed to strip ansi control codes from input.\ngot error message:\n{}", e);
            exit(1);
        }
    }
}

fn make_fname(dir: &str, name: Option<String>, alt: String) -> String {
    tilde(&format!("{}/{}", dir, match name {
        Some(file) => file,
        None => alt,
    })).to_string()
}

fn complete(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("The '{}' engagement is {}!", engage.name, if engage.complete {"complete"} else {"incomplete"});
}

fn info(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, configs: ptdb_lib::config_loading::Config) -> Result<(), Error> {
    let path = make_fname(engagement_dir, None, name.clone());
    let conf = ptdb_lib::config_loading::EngageConf {
        name: name.clone(),
        complete: false,
    };

    if !Path::new(&path).exists() {
        // println!("conf file already exsists at location: '{}' .", path);
        // exit(1);
        let mut output = File::create(path)?;

        write!(output, "{}", match toml::to_string(&conf) {
            Ok(s) => s,
            Err(_) => {
                println!("could not serialize engagement configuration.");
                exit(1);
            }
        })?;
        println!("file created!");
    }

    match make_sql_db(name, configs) {
        Ok(_) => {}
        Err(m) => {
            eprintln!("{}", m);
            exit(1);
        }
    };

    Ok(())
}

fn make_sql_db(name: String, configs: ptdb_lib::config_loading::Config) -> Result<(), String> {
    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &None,
        &configs.sql.ssl_cert,
    )?;
    
    // println!("client connected!");
    let cmd = format!("CREATE DATABASE \"{}\" TEMPLATE \"{}\";", name, configs.sql.template_db);
    // println!("{}", cmd);
    let _foo = client.execute(&cmd, &[]);
    let _ = client.close();
    println!("db created!");

    Ok(())
}

fn engage_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config) {
    // println!("engage mode");
    if matches.contains_id("new") {
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), ptdb_lib::CONFIG_DIR, configs);
            },
            None => {}
        }
    }
    else if matches.contains_id("engage") {
        info(matches.get_one::<String>("engage").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    }
    else if matches.contains_id("complete") {
        complete(matches.get_one::<String>("complete").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    }
}

fn usr_sql_query(query: &String, engagement: &String, configs: ptdb_lib::config_loading::Config) -> Result<(), String> {
    // println!("not yet implemented.");
    let mut client = match ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &Some(engagement.clone()),
        &configs.sql.ssl_cert,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            ptdb_lib::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    for column in query.clone().split(' ') {
        if column.to_lowercase() == "select" {
            continue;
        } else if column.to_lowercase() == "from" {
            break;
        } else {
            titles.push(String::from(column));
        }
    }

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    if !res.is_empty() {
        print_table(res);
        let _ = client.close();
        Ok(())
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

fn generic_query(
    get_arg: Vec<String>, 
    engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: ptdb_lib::config_loading::Config,
    engage_conf: &ptdb_lib::config_loading::EngageConf
)  -> Result<(), String> {
    let select_clause = format!("SELECT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    let engagement = match engagement_arg {
        Some(engagement) => engagement,
        None => engage_conf.name.clone(),
    };
    let from_clause = match configs.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, from_clause, where_clause); // SELECT {select_clause}
    usr_sql_query(&cmd, &engagement, configs)
}

fn query_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config, engage_conf: &ptdb_lib::config_loading::EngageConf) {
    // println!("query mode");
    
    if matches.contains_id("sql_query") {
        match matches.get_one::<String>("sql_query") {
            Some(query) => {
                match usr_sql_query(query, &engage_conf.name, configs) {
                    Ok(_) => {}
                    Err(m) => ptdb_lib::console_log(&m, false),
                }
            }
            None => {}
        }
        return
    }

    let get_args = match matches.get_many::<String>("get") {
        Some(columns) => columns.cloned().map(|x| x.replace(",", "")).collect::<Vec<String>>(),
        None => vec!["*".to_string()],
    };
    
    let res = generic_query(
                  get_args,
                  get_as_opt(matches, "engagement"), 
                  get_as_str(matches, "condition", Some("")), 
                  get_as_str(matches, "target", None),
                  configs,
                  &engage_conf
                );

    match res {
        Ok(_) => {}
        Err(message) => {
            eprintln!("[PTDB ERROR] could not query database. got error:\n{}", message);
            exit(1);
        }
    }
}

fn get_as_opt(matches: &ArgMatches, option: &str) -> Option<String> {
    matches.get_one::<String>(option).cloned()
}

fn get_as_str(matches: &ArgMatches, option: &str, alt: Option<&str>) -> String {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>(option) {
        Some(columns) => columns.clone(),
        None => match alt {
            Some(alt_text) => alt_text.to_string(),
            None => {
                eprintln!("The argument \"{}\" is required in this context but was not present.", option);
                exit(1);
            }
        }
    }
}

fn print_table(sql_rows: Vec<postgres::Row>) {
    let mut table = Table::new();
    // table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
    table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    // let mut titles = input_titles;
    let titles = make_title(&sql_rows[0]);
    table.set_titles(Row::from(titles));

    for sql_row in sql_rows {
        // let r= make;
        table.add_row(Row::from(make_printable_row(sql_row)));
    }
    // println!("titles : {:?}", titles);

    // Print the table to stdout
    table.printstd();
    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

fn make_printable_row(sql_row: postgres::Row) -> Vec<String> {
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            format!("{}", sql_row.get::<usize, i32>(i))
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

fn make_title(sql_row: &postgres::Row) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}