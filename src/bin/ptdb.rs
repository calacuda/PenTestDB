#![warn(clippy::all)]
#![feature(let_chains)]
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use clap::{Command};

mod ptdb_lib;

fn main() {
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let engagement = ptdb_lib::config_loading::get_engagement(
        Path::new(ptdb_lib::CONFIG_ADR)
            .parent()
            .unwrap()
            .join(configs.engagement_conf),
    );

    if engagement.complete {
        println!("the engagement is complete! quiting.");
        exit(0);
    }

    let mode = get_mode();

    if mode == "server" {
        println!("starting server...");
        server_mode();
    } else if mode == "client" {
        println!("sending data to server...");
        client_mode(&configs.server.socket);
    } else if mode == "manual" {
        manual_mode();
    }
}

fn client_mode(serv_soc: &String) {
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin! WHY?!");
            exit(1);
        }
    };
    buf
}

fn server_mode() {
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let socket_adr = configs.server.socket;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_mode() -> String {
    let matches = Command::new("PenTestDB")
        .version("0.3.1")
        .about("parses the output of pentesting commands and stores them in a database.")
        // .subcommand_required(true)
        .subcommands([
            Command::new("server")
                .about("runs in server mode"),
            Command::new("client")
                .about("runs in client mode (requires another instance runnign in server mode.)"),
            Command::new("manual")
                .about("runs in stand alone mode. all commands are parsed adn sent to the database in a blocking manner."),
        ])
        .get_matches();

    let mode = match matches.subcommand() {
        Some((mode, _)) => mode,
        None => "manual",
    };
    // println!("mode {:?}", mode);
    mode.to_string()
}

fn manual_mode() {
    let buf = get_std_in();
    if let Ok(log_d) = std::str::from_utf8(&buf) {
        ptdb_lib::process_raw_input(log_d.to_string())    ;        
    } else {
        println!("could not interpret text on stdin.");
        exit(1);
    }
}
