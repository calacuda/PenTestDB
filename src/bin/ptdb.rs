#![warn(clippy::all)]
#![feature(let_chains)]
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use clap::{Command, ArgMatches, Arg};
use shellexpand::tilde;
use toml;
use std::fs::File;
use std::io::Error;

mod ptdb_lib;

fn main() {
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let engagement = ptdb_lib::config_loading::get_engagement(&format!("{}/{}", ptdb_lib::CONFIG_DIR, configs.engagement_conf));

    // if engagement.complete {
    //     println!("the engagement is complete! quiting.");
    //     exit(0);
    // }

    match get_args().subcommand() {
        Some(("server", _)) if !engagement.complete => server_mode(),
        Some(("client", _)) if !engagement.complete => client_mode(&configs.server.socket),
        Some(("manual", _)) if !engagement.complete => manual_mode(),
        Some(("engagement", m)) => engage_mode(m, configs),
        None => manual_mode(),
        Some((_, _)) => {},
    }

    if engagement.complete {
        println!("the engagement is complete! quiting.");
        exit(0);
    }
}

fn client_mode(serv_soc: &String) {
    println!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin! WHY?!");
            exit(1);
        }
    };
    buf
}

fn server_mode() {
    println!("starting server...");
    let configs = ptdb_lib::config_loading::get_config(ptdb_lib::CONFIG_ADR);
    let socket_adr = configs.server.socket;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.2")
        .about("parses the output of pentesting commands and stores them in a database.")
        // .subcommand_required(true)
        .subcommand(
            Command::new("server")
            .about("runs in server mode")
        )
        .subcommand(
            Command::new("client")
            .about("runs in client mode (requires another instance runnign in server mode.)")
        )
        .subcommand(
            Command::new("manual")
            .about("runs in stand alone mode. all commands are parsed and sent to the database in a blocking manner.")
        )
        .subcommand(
            Command::new("engagement")
            .about("get info about the current engagement or make new ones.")
            .arg(
                Arg::new("new")
                .long("new")
                .short('n')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "complete"])
                .help("makes a new engagement and switches to it.")
            )
            .arg(
                Arg::new("engage")
                .long("engagement")
                .short('e')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["complete", "new"])
                .help("get info on a specific engagement")
            )
            .arg(
                Arg::new("complete")
                .long("is-complete")
                .short('c')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "new"])
                .help("returns if the given engagement is completed. if no engagement is provided it will use the curent engagement from the config file.")
            )
        // .subcommand(
        //     Command::new("query")
        //     .about("query the data base.")
        // )
        )
        .get_matches()
}

fn manual_mode() {
    let buf = get_std_in();
    if let Ok(log_d) = std::str::from_utf8(&buf) {
        ptdb_lib::process_raw_input(log_d.to_string())    ;        
    } else {
        println!("could not interpret text on stdin.");
        exit(1);
    }
}

fn make_fname(dir: &str, name: Option<String>, alt: String) -> String {
    tilde(&format!("{}/{}", dir, match name {
        Some(file) => file,
        None => alt,
    })).to_string()
}

fn complete(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("The '{}' engagement is {}!", engage.name, if engage.complete {"complete"} else {"incomplete"});
}

fn info(name: Option<String>, dir: &str, current: String) {
    let fname = make_fname(dir, name, current);
    let engage = ptdb_lib::config_loading::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, configs: ptdb_lib::config_loading::Config) -> Result<(), Error> {
    let path = make_fname(engagement_dir, None, name.clone());
    let conf = ptdb_lib::config_loading::EngageConf {
        name: name.clone(),
        complete: false,
    };

    if Path::new(&path).exists() {
        eprintln!("conf file already exsists at location: '{}'.", path);
        exit(1);
    }

    let mut output = File::create(path)?;

    write!(output, "{}", match toml::to_string(&conf) {
        Ok(s) => s,
        Err(_) => {
            eprintln!("could not serialize engagement configuration.");
            exit(1);
        }
    })?;
    println!("file created!");

    match make_sql_db(name, configs) {
        Ok(_) => {}
        Err(m) => {
            eprintln!("{}", m);
            exit(1);
        }
    };

    Ok(())
}

fn make_sql_db(name: String, configs: ptdb_lib::config_loading::Config) -> Result<(), String>{
    let mut client = ptdb_lib::tl_connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.port,
        configs.sql.ssl,
    )?;
    
    // println!("client connected!");
    let cmd = format!("CREATE DATABASE \"{}\" TEMPLATE \"{}\";", name, configs.template_db);
    // println!("{}", cmd);
    let _foo = client.execute(&cmd, &[]);
    println!("db created!");

    Ok(())
}

fn engage_mode(matches: &ArgMatches, configs: ptdb_lib::config_loading::Config) {
    // println!("engagemode");
    if matches.contains_id("new") {
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), ptdb_lib::CONFIG_DIR, configs);
            },
            None => {}
        }
    }
    else if matches.contains_id("engage") {
        info(matches.get_one::<String>("engage").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    }
    else if matches.contains_id("complete") {
        complete(matches.get_one::<String>("complete").cloned(), ptdb_lib::CONFIG_DIR, configs.engagement_conf)
    }
}
