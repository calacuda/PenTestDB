// use std::collections::HashMap;
// use std::error::Error;
// use std::io::prelude::*;
// use std::fs::read_to_string;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::exit;
use std::process::{Command, Stdio};
use std::thread;

mod config_loading;
mod output_parser;

const CONFIG_ADR: &str = "/home/yogurt/Code/misc/PenTestDB/configs/.config/ptdb/config.toml";

fn main() {
    let configs = //config_loading::get_config(&"./configs/etc/ptdb/system-config.toml");
    config_loading::get_config(CONFIG_ADR);
    // config_loading::get_config(&"/etc/ptdb/system-config.toml", &"~/.config/ptdb/ptdb.toml");
    // println!("{:#?}", sys_configs);
    let socket_adr = configs.server.socket;
    recv_loop(&socket_adr);
}

fn recv_loop(progr: &str) -> std::io::Result<()> {
    println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("{:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

fn handle_client(mut stream: UnixStream) {
    let (command, log_data) = get_cmd(&read_log(&mut stream));
    // let command = get_cmd(&log_data);
    // println!("$> {:#?}", command);
    // print!("{}", log_data);
    // println!("============");
    run_parsers(command, log_data);
    drop(stream)
}

fn run_parsers(commands: Vec<String>, log_data: String) {
    let configs = config_loading::get_config(CONFIG_ADR);
    let parsers = configs.parsers;
    let parser = match get_parser(&commands, parsers) {
        Ok(parser) => parser,
        Err(_) => return,
    };
    // println!("{}", parser);
    let parser_adr = Path::new(&configs.server.parser_dir).join(parser);
    // println!("{:#?}", parser_adr);
    if parser_adr.exists() {
        parse(&parser_adr, log_data, commands[1].clone());
    } else {
        println!(
            "parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        );
        exit(1);
    }
}

fn get_parser(commands: &Vec<String>, parsers: HashMap<String, String>) -> Result<String, ()> {
    // println!("get_parser");
    for i in 0..3 {
        // println!("parser: {}", commands[2 - i]);
        match parsers.get(&commands[2 - i]) {
            Some(parser) => return Ok(parser.to_owned()),
            None => {}
        }
    }
    return Err(());
}

fn parse(parser: &PathBuf, log_data: String, cmd: String) {
    let mut child = Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn child process");

    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let output = String::from_utf8_lossy(
        &child
            .wait_with_output()
            .expect("Failed to read stdout")
            .stdout,
    )
    .to_string();
    // output = &output.stdout;
    // println!("output: {}", output);

    //do SQL stuff with output.
}

fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    return log_data;
}

fn get_cmd(log_data: &String) -> (Vec<String>, String) {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.trim().split_once('\n') {
            Some(dat) => {
                cmd_names.push(match dat.0.split_once(' ') {
                    Some(cmd) => cmd.0.to_string(),
                    None => dat.0.to_string(),
                });
                dat.1.to_owned()
            }
            None => panic!("only one line found. {:?}", log_data),
        }
    }

    return (cmd_names, tmp_log.to_string());
}
