#![warn(clippy::all)]
// use std::collections::HashMap;
// use std::error::Error;
// use std::io::prelude::*;
// use std::fs::read_to_string;
// use std::process::exit;
// use std::error::Error;
use chrono::prelude::*;
use openssl::ssl::{SslConnector, SslMethod, SslVerifyMode};
use postgres::{Client, NoTls};
use postgres_openssl::MakeTlsConnector;
use std::collections::HashMap;
use std::io::Read;
use std::io::Write;
use std::os::unix::net::{UnixListener, UnixStream};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::thread;

mod config_loading;

type SQLColumnNames = Vec<String>;
type SQLColumnValues = Vec<String>;
type SQLColumnAssociaions = (SQLColumnNames, SQLColumnValues); 
type SQLTableData = HashMap<String, SQLColumnAssociaions>; 
type SQLTableDatas = Vec<SQLTableData>; 

// struct ID {
    // id: i32,
// }

// ~/.config/ptdb/config.toml
const CONFIG_ADR: &str = "~/Code/misc/PenTestDB/configs/.config/ptdb/config.toml";
// "/etc/ptdb/parsers" // "~/.local/ptdb/parsers/"
const PARSERS_DIR: &str = "~/Code/misc/PenTestDB/configs/etc/ptdb/parsers/";
// const SQL_BASE_FILE: &str = "~/Code/misc/PenTestDB/configs/etc/make-db.sql";

fn main() {
    let configs = config_loading::get_config(CONFIG_ADR);
    let socket_adr = configs.server.socket;
    // merge_to_db("foobar".to_string());
    let _ = recv_loop(&socket_adr);
}

fn recv_loop(progr: &str) -> std::io::Result<()> {
    // println!("recv_loop");
    let listener = UnixListener::bind(progr)?;
    // println!("recv_loop");

    for stream in listener.incoming() {
        // println!("stream connected");
        match stream {
            Ok(stream) => {
                /* connection succeeded */
                thread::spawn(move || handle_client(stream));
            }
            Err(err) => {
                println!("connection failed with error: {:#?}", err);
                /* connection failed */
                break;
            }
        }
    }

    println!("killing listener");
    drop(listener);
    Ok(())
}

fn handle_client(mut stream: UnixStream) {
    let (commands, log_data) = get_cmd(&read_log(&mut stream));
    let configs = config_loading::get_config(CONFIG_ADR);
    let engage_conf = config_loading::get_engagement(
        Path::new(CONFIG_ADR)
            .parent()
            .unwrap()
            .join(&configs.engagement_conf),
    );
    // let command = get_cmd(&log_data);
    // println!("commands {:#?}", commands);
    // print!("{}", log_data);
    // println!("============");
    if !engage_conf.complete {
        // add date check and turnning off of "complete flag" here as a conditional
        run_parsers(commands, log_data, configs, engage_conf);
    }
    drop(stream)
}

fn run_parsers(
    commands: Vec<String>,
    log_data: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) {
    let parsers = &configs.parsers;
    let parser = match get_parser(&commands, parsers) {
        Ok(parser) => parser,
        Err(_) => return,
    };
    // println!("parsers {:?}", configs.parsers);
    let parser_adr = match &configs.server.parser_dir {
        Some(path) => Path::new(&shellexpand::tilde(&path).to_string()).to_owned(),
        None => Path::new(&shellexpand::tilde(PARSERS_DIR).to_string()).to_owned(),
    }
    .join(parser);
    // println!("parser adr => {:#?}", parser_adr);
    if parser_adr.exists() {
        parse(
            &parser_adr,
            log_data,
            commands[1].clone(),
            configs,
            engage_conf,
        );
        println!("parsed output or command: {:?}", commands[1]);
    } else {
        println!(
            "parser at adress, {}, not found!",
            parser_adr.as_path().to_str().unwrap()
        );
    }
}

fn get_parser(
    commands: &[String],
    parsers: &HashMap<String, Vec<config_loading::ParserConf>>,
) -> Result<String, ()> {
    // println!("get_parser");
    for i in 0..3 {
        // println!("parser: {}", commands[2 - i]);
        let cmd = &commands[2 - i];
        // let exec = cmd.split_once(' ').into_iter().nth(0).expect(&cmd);
        let (exec, given_args): (String, Vec<String>) = match cmd.split_once(' ') {
            Some((exec, args)) => (
                exec.to_string(),
                args.split(' ').map(|x| x.to_string()).collect(),
            ),
            None => (cmd.clone(), Vec::new()),
        };

        if let Some(ps) = parsers.get(&exec) {
            let default = get_default_parser(ps);
            for parser in ps {
                if let Some(args) = parser.args.clone() {
                    for arg_set in args {
                        if parser_match(&given_args, arg_set) {
                            return Ok(parser.parser.clone());
                        }
                    }
                }
            }
            match default {
                Some(parser) => return Ok(parser),
                None => {
                    println!("a parser for {} is not in config file.", exec)
                }
            }
        }
        
    }
    Err(())
}

fn get_default_parser(parsers: &Vec<config_loading::ParserConf>) -> Option<String> {
    for parser in parsers {
        match parser.args.clone() {
            Some(_) => {}
            None => return Some(parser.parser.clone()),
        }
    }
    None
}

fn parser_match(
    given_args: &[String],
    arg_set: Vec<String>, // HashMap<String, Vec<config_loading::ParserConf>>,
) -> bool {
    // println!("given args: {:?}", given_args);
    for arg in arg_set {
        // print!("{} ", arg);
        if !given_args.contains(&arg.to_string()) {
            // println!("arg not contained {}", arg.to_string());
            return false;
        }
        // println!();
    }
    true
}

fn parse(
    parser: &PathBuf,
    log_data: String,
    cmd: String,
    config: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) {
    let mut child = Command::new(parser)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn child process");

    let to_send = format!("{}\n{}", cmd, log_data);

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    std::thread::spawn(move || {
        stdin
            .write_all(to_send.as_bytes())
            .expect("Failed to write to stdin");
    });

    let output = String::from_utf8_lossy(
        &child
            .wait_with_output()
            .expect("Failed to read stdout")
            .stdout,
    )
    .to_string();
    // output = &output.stdout;
    // println!("output: {}", output);

    //do SQL stuff with output.
    match merge_to_db(output, cmd, config, engage_conf) {
        Ok(_) => {}
        Err(e) => println!("could not comunicate with database => {}", e),
    }
}

fn merge_to_db(
    output: String,
    cmd: String,
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf,
) -> Result<(), postgres::Error> {
    let mut client = connect(
        configs.sql.host,
        configs.sql.user,
        configs.sql.port,
        engage_conf.name,
        configs.sql.ssl,
    );
    // ensure_db(&mut client, engage_conf.name);
    store_data(output, cmd, &mut client);
    let _ = client.close();
    Ok(())
}

fn parse_output(line: String) -> Result<HashMap<String, String>, ()> {
    // let tmp_line = line.clone();
    let mut params: HashMap<String, String> = HashMap::new();
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    // println!("tokens len => {}", tokens.len());
    // println!(
    //     "tokens last 2 => {} {}",
    //     tokens[tokens.len() - 2],
    //     tokens[tokens.len() - 1]
    // );
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        println!("[ERROR] every key needs a value!");
        return Err(());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.insert(key.to_string(), value.to_string());
    }

    Ok(params)
}

fn add_params(
    params: HashMap<String, String>,
    cmd: &String,
    table_data: &mut HashMap<String, (Vec<String>, Vec<String>)>,
    _client: &mut Client,
) {
    // println!("add_params");
    let mut host_ip = "".to_string();
    // let _host_id: i32 = -1;
    // let cmd = format!("{}", cmd);
    // let _cmd_id: i32 = -1;
    let mut tables = Vec::new();
    // let params = params.clone();
    // params.insert("cmd".to_string(), cmd.clone());

    for (key, value) in params {
        // maybe i should read this from the config file? that way the program is more
        // customizable. food for thought.
        let table = match key.as_str() {
            "ip" => {
                host_ip = value.clone();
                "hosts"
            }
            "ipv6" => {
                host_ip = value.clone();
                "hosts"
            }
            "dns_name" => {
                println!("value => {}", value);
                host_ip = value.clone();
                "hosts"
            }
            "port" => "ports",
            "web_protocol" => "web_dirs",
            "TL_protocol" => "ports",
            "service" => "ports",
            "version" => "ports",
            "cmd" => "commands",
            "host_name" => "hosts",
            "res_code" => "web_dirs",
            "base_url" => "web_dirs",
            "url" => "web_dirs",
            "method" => "web_dirs",
            "redirect_adr" => "web_dirs",
            "dir" => "web_dirs",
            "num_chars" => "web_dirs",
            "user_name" => "passwds",
            "pass_wd" => "passwds",
            "local" => "passwds",
            "ssh" => "dns_namepasswds",
            "ftp" => "passwds",
            "gateway_to" => "hosts",
            "gateway_from" => "hosts",
            "state" => "ports",
            "output" => "commands",
            _ => {
                println!("unknown column. what is\"{}\"?", key);
                continue;
            }
        };

        // println!("{}", table);

        tables.push(table);

        // if table_data.contains_key(&table.to_string()) {
        match table_data.get_mut(&table.to_string()) {
            Some(data) => {
                data.0.push(key.clone());
                data.1.push(value.clone());
            },
            None => {table_data.insert(table.to_string(), (vec![key.clone()], vec![value.clone()]));}
        }
        // println!(
        //     "DEBUG {}: {}",
        //     key,
        //     if key != "output" {
        //         value
        //     } else {
        //         "...".to_string()
        //     }
        // );
    }

    // add cmd and host
    for table in ["ports", "web_dirs", "passwds"] {
        // for (c_name, id) in [("command", cmd.to_string())] {
        for (c_name, id) in [("command", cmd.to_string()), ("host", host_ip.to_string())] {
            // for (c_name, id) in [("host", host_ip.to_string())] {
            if table_data.contains_key(&table.to_string()) {
                // println!("adding {}:{} to table: {}", c_name, id, table);
                table_data
                    .get_mut(&table.to_string())
                    .unwrap()
                    .0
                    .push(c_name.to_string());
                table_data
                    .get_mut(&table.to_string())
                    .unwrap()
                    .1
                    .push(id);
            }
            // }
        }
    }
}

fn store_data(output: String, cmd: String, client: &mut Client) {
    // let insert = "INSERT INTO $1($2) VALUES($3)";
    // let select = "SELECT $2 FROM $1 WHERE ($2) = ($3)";
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    // println!("line => ^{:?}?", tmp_output);
    let mut table_datas: SQLTableDatas = Vec::new();

    let mut tmp_table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();
    let time: DateTime<Local> = Local::now();
    let cmd = format!("'{}'", cmd);
    tmp_table_data.insert(
        "commands".to_string(),
        (
            vec!["cmd".to_string(), "local_time".to_string()],
            vec![cmd.clone(), format!("'{}'", time)],
        ),
    );
    table_datas.push(tmp_table_data);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        let mut table_data: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string()) {
            Ok(data) => data,
            Err(_e) => {
                println!(
                    "[Error] could not understand the output of the parser. next. error on key: ^{}?",
                    line
                );
                return;
            }
        };
        add_params(params, &cmd, &mut table_data, client);
        table_datas.push(table_data);
    }

    send_to_db(table_datas, cmd, client);
}

fn send_to_db(
    table_datas: SQLTableDatas,
    cmd: String,
    client: &mut Client,
) {
    let pre_add_tables = ["hosts", "commands"];
    // add cmd and host here first.
    for table_data in &table_datas {
        for table_name in pre_add_tables {
            // println!("table name => {}", table_name);
            if let Some(table) = table_data.get(table_name) {
                // println!("inserting into => {}", table_name);
                insert_to(&table_name.to_string(), table, client);
                // table_data.remove(table_name);
            }
        }
    }

    // add function call to change host and command values to their database IDs.
    let cmd_id = get_id("commands".to_string(), format!("cmd = {}", cmd), client);
    let mut new_table_datas: SQLTableDatas = Vec::new();
    for table_data in table_datas {
        let mut new_table_data = table_data.clone();
        // println!("table_data => {:#?}", table_data);
        for (key, value) in table_data {
            if pre_add_tables.contains(&key.as_str()) {
                continue;
            }
            let host_i = new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "host");
            let cmd_i = &mut new_table_data
                .get(&key)
                .unwrap()
                .0
                .iter()
                .position(|r| r == "command");
            if let Some(i) = host_i {
                let old_val = value.1[i].clone();
                println!("old_val => {}", old_val);
                new_table_data.get_mut(&key).unwrap().1[i] = get_id(
                    "hosts".to_string(),
                    format!(
                        "ip = {} OR dns_name = {} OR local_host_name = {} OR ipv6 = {}",
                        old_val, old_val, old_val, old_val
                    ),
                    client,
                );
            }
            match cmd_i {
                Some(i) => {
                    new_table_data.get_mut(&key).unwrap().1[*i] = cmd_id.clone();
                }
                None => {
                    println!("cmd index not found adding manually");
                    new_table_data
                        .get_mut(&key)
                        .unwrap()
                        .0
                        .push("command".to_string());
                    new_table_data.get_mut(&key).unwrap().1.push(cmd_id.clone());
                }
            }
        }
        new_table_datas.push(new_table_data);
    }

    for table_data in new_table_datas {
        for (table, value) in &table_data {
            if !pre_add_tables.contains(&table.as_str()) {
                insert_to(table, value, client);
            }
        }
        // println!("{:#?}", table_data);
    }
}

fn get_id(table: String, condition: String, client: &mut Client) -> String {
    // let select = "SELECT $2 FROM $1 WHERE ($2) = ($3)";
    let query = format!("SELECT id FROM {} WHERE {}", table, condition);
    println!("query => {}", query);
    let res = match client.query(&query, &[]) {
        Ok(responce) => responce,
        Err(e) => panic!("could not query server. got error => {}", e),
    };

    if !res.is_empty() {
        // println!("{:#?}", res);
        let n: i32 = res.last().unwrap().get(0);
        format!("'{}'", n)
    } else if res.is_empty() {
        // println!("{:#?}", res);
        panic!("database returned no id line")
    } else {
        // println!("{:#?}", res);
        panic!("database returned more than one id line")
    }
}

fn insert_to(table: &String, value: &(Vec<String>, Vec<String>), client: &mut Client) {
    // println!(
    //     "sql cmd: {}\n",
    //     &format!(
    //         "INSERT INTO {}({}) VALUES({})",
    //         &table,
    //         &value.0.join(", "),
    //         &value.1.join(", ")
    //     )
    // );
    let res = client.query(
        &format!(
            "INSERT INTO {}({}) VALUES({})",
            &table,
            &value.0.join(", "),
            &value.1.join(", ")
        ),
        &[],
    );
    match res {
        Ok(_) => {}
        Err(e) => println!("got sql error => {}", e),
    }
    // println!("{:?}", res);
}

fn connect(
    host: String,
    user: String,
    port: String,
    db_name: String,
    use_ssl: Option<bool>,
) -> Client {
    let ssl = use_ssl.unwrap_or(false);
    // this would look REALLY flipping ugly on one line.
    let con = if ssl {
        Client::connect(
            &format!(
                "host={} user={} port={} dbname={} sslmode=require",
                host, user, port, db_name
            ),
            get_ssl("/tmp/ca.cert"),
        )
    } else {
        Client::connect(
            &format!(
                "host={} user={} port={} dbname={}",
                host, user, port, db_name
            ),
            NoTls,
        )
    };

    match con {
        Ok(conection) => conection,
        Err(e) => {
            println!("server connection error => {}", e);
            panic!("could not connect to sql database. :(");
            // panic!("failed to create tls postgres connection. :(")
        }
    }
}

fn get_ssl(ca_file: &str) -> MakeTlsConnector {
    let mut builder =
        SslConnector::builder(SslMethod::tls()).expect("unable to create sslconnector builder");
    builder
        .set_ca_file(ca_file)
        .expect("unable to load ca.cert");
    builder.set_verify(SslVerifyMode::NONE);
    MakeTlsConnector::new(builder.build())
}

fn read_log(stream: &mut UnixStream) -> String {
    let mut log_data = String::new();
    // stream.set_nonblocking(false);
    stream.read_to_string(&mut log_data).unwrap();
    let _ = stream.shutdown(std::net::Shutdown::Read);
    // let cmd = get_cmd(&mut log_data);
    // println!("log_data =>\n{}", log_data);
    log_data
}

fn get_cmd(log_data: &String) -> (Vec<String>, String) {
    let mut cmd_names = vec![];
    let mut tmp_log = log_data.to_owned();
    for _ in 0..3 {
        tmp_log = match tmp_log.split_once('\n') {
            Some(dat) => {
                cmd_names.push(dat.0.trim().to_string());
                dat.1.to_owned()
            }
            None => panic!("only one line found. {:?}", log_data),
        }
    }

   (cmd_names, tmp_log)
}
