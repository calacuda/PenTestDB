#![warn(clippy::all)]
// use std::ascii::AsciiExt;
use std::io::Read;
use std::io::Write;
use std::net::Shutdown;
use std::os::unix::fs::symlink;
use std::os::unix::net::UnixStream;
use std::path::Path;
use std::process::exit;
use std::collections::HashMap;
use clap::parser::ValuesRef;
use clap::{Command, ArgMatches, Arg, ArgAction};
use shellexpand::tilde;
use toml;
use std::fs::{File, remove_file};
use std::io::Error;
use strip_ansi_escapes;
use prettytable::{Table, Row, format};
use std::fs;
use std::collections::{HashSet, hash_set::IntoIter};
use ptdb_lib;
use postgres::Row as PgrsRow;

// mod ptdb_lib;

fn main() {
    let configs = config_loading::get_config();
    let engagement = config_loading::get_engagement(ptdb_lib::ENGAGEMENT_ADR);

    // if engagement.complete {
    //     println!("the engagement is complete! quiting.");
    //     exit(0);
    // }

    let matches = get_args();

    match matches.subcommand() {
        Some(("server", _)) if !engagement.complete && configs.active => server_mode(),
        Some(("client", _)) if !engagement.complete && configs.active => client_mode(&configs.server_mode.socket_adr),
        Some(("parse", m)) if !engagement.complete && configs.active => manual_mode(m.clone(), configs, engagement),
        Some(("engagement", m)) => engage_mode(m),
        Some(("query", m)) => query_mode(m, configs, &engagement),
        Some(("pause", _)) => pause(),
        Some(("resume", _)) => resume(),
        Some(("config", m)) => config(m),
        Some(("info", _)) => info_dump(configs, engagement),
        // None => manual_mode(matches),
        // None => test_mode(matches),
        Some(("server", _)) | Some(("client", _)) | Some(("parse", _)) if engagement.complete => {
            println!("the engagement is complete! quitting.");
            exit(0);
        }
        Some((_, _)) => {},
        None => {},
    }
}

fn info_dump(config: config_loading::Config, engagement: config_loading::EngageConf) {
    // (engagement sql database name, host of current database, if engagement is complete)
    // println!("db name   =>  {}", engagement.name);
    // println!("db host   =>  {}", config.sql.host);
    // println!("complete  =>  {}", engagement.complete);
    // println!("parsing   =>  {}", config.active);
    println!("database name    =>  {}", engagement.name);
    println!("database host    =>  {}", config.sql.host);
    println!("engage complete  =>  {}", engagement.complete);
    println!("active status    =>  {}", if config.active {"active"} else {"paused"});
}

fn config(matches: &ArgMatches) {
    if let Some(sql_server) = matches.get_one::<String>("switch-sql") {
        // activate_server(sql_server);
        change_config("db_conf", &format!("\"{}\"", sql_server), ptdb_lib::ENGAGEMENT_ADR);        
        println!("switched server to \"{}\".", sql_server);
    }

    if let Some(enagement) = matches.get_one::<String>("switch-engagement") {
        activate_engagement(None, enagement);
        println!("the engagement, \"{}\", is now active.", enagement);
    }
}

fn pause() {
    change_config("active", "false", config_loading::USR_CONFIG_ADR);
    println!("paused parsing of commands. run the command \"ptdb resume\" to resume parsing.");
}

fn resume() {
    change_config("active", "true", config_loading::USR_CONFIG_ADR);
    println!("parsing of commands has been resumed.");
}

fn client_mode(serv_soc: &String) {
    println!("sending data to server...");
    let buf = get_std_in();

    // send to server
    send_data(&buf, serv_soc);  // configs.server.socket);
}

fn send_data(data: &[u8], server_soc: &String) {
    let mut stream = match UnixStream::connect(&server_soc) {
        Ok(stream) => stream,
        Err(_) => {
            println!("[PTDB ERROR] couldn't connect to socket at \"{}\"", server_soc);
            println!("Hints:");
            println!(" - Do you have the socket configured corectly?");
            println!(" - Is the server runing?");
            exit(1);
        }
    };

    match stream.write_all(data) {
        Ok(_) => {}
        Err(e) => {
            println!("could not send data to server.");
            println!("[DEBUG] :  {}", e);
            exit(1);
        }
    };

    match stream.shutdown(Shutdown::Write) {
        Ok(_) => {}
        Err(e) => {
            println!("failed to shutdown write access to socket file.");
            // println!("program will now hang.");
            println!("[DEBUG] :  {}", e);
        }
    };
}

fn get_std_in() -> Vec<u8> {
    let mut log_data = std::io::stdin();
    let mut buf = vec![];
    match log_data.read_to_end(&mut buf) {
        Ok(_) => {}
        Err(_) => {
            println!("could not read stdin!");
            exit(1);
        }
    };
    // println!("returning buf");
    buf
}

fn server_mode() {
    println!("starting server...");
    let configs = config_loading::get_config();
    let socket_adr = configs.server_mode.socket_adr;
    let _ = ptdb_lib::recv_loop(&socket_adr);
}

fn get_args() -> ArgMatches {
    Command::new("PenTestDB")
        .version("0.3.10")
        .about("Parses the output of pen-testing commands and stores them in a database.")
        .subcommand_required(true)
        .subcommand(
        Command::new("server")
            .about("Runs in server mode")
        )
        .subcommand(
        Command::new("client")
            .about("Runs in client mode (requires another instance running in server mode.)")
        )
        .subcommand(
        Command::new("parse")
            .about("Runs in stand alone mode. (ie. all commands are parsed and sent to the database from the current process. NOTE: that this is blocking.)")
            .arg(
                Arg::new("quiet")
                .long("quiet")
                .short('q')
                .required(false)
                .action(ArgAction::SetTrue)
                .help("Suppresses all output. (will not suppress fatal errors, like sql errors.)")
            )
            .arg(
                Arg::new("command-name")
                .long("command")
                .short('c')
                .value_name("EXECUTABLE-NAME")
                .required(false)
                .num_args(1)
                .help("Sets the command. helpful for when you need to pipe the output of a command directly into ptdb.")
            )
            .arg(
                Arg::new("exit-status")
                .long("exit-status")
                .short('e')
                .value_name("EXIT_STATUS")
                .required(false)
                .num_args(1)
                .help("the exit status of the command being parsed.")
            )
        )
        .subcommand(
        Command::new("engagement")
            .about("get info about an engagement or make new ones. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("new")
                .long("new")
                .short('n')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("makes a new engagement and switches to it.")
            )
            .arg(
                Arg::new("engage")
                .long("engagement")
                .short('e')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["complete", "new", "remove", "activate"])
                .help("get info on a specific engagement")
            )
            .arg(
                Arg::new("complete")
                .long("is-complete")
                .short('c')
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "new", "remove", "activate"])
                .help("returns if the given engagement is completed. if no engagement is provided it will use the current engagement from the config file.")
            )
            .arg(
                Arg::new("remove")
                .long("delete")
                .short('d')
                .value_name("ENGAGEMENT-NAME")
                .num_args(1)
                .conflicts_with_all(["engage", "new", "complete", "activate"])
                .help("removes an engagement data-base from the sql server.")
            )
            .arg(
                Arg::new("activate")
                .long("activate")
                .short('a')
                .visible_alias("switch-to")
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .conflicts_with_all(["engage", "complete", "remove"])
                .help("activates an engagement in the config file. aliases include ['--switch-to', '-s'].")
            )
            .arg(
                Arg::new("sql-server")
                .long("server")
                .short('s')
                .value_name("DB-SERVER-CONF-FILE")
                .num_args(1)
                .conflicts_with_all(["engage", "complete"])
                .help("the sql server config file to use. \"default\" is assumed if this argument is not provided.")
            )
        )
        .subcommand(
        Command::new("query")
            .about("Used to query the engagement data-bases. if no engagement is specified, the current engagement is used by default.")
            .arg(
                Arg::new("get")
                .long("get")
                .short('g')
                .visible_alias("select")
                .visible_short_alias('s')
                .value_name("PREDICATES-TO-RETRIEVE")
                .num_args(1..)
                .required(true)
                .help("the information to print to the console. (ie. what columns to SELECT from the database). aliases include ['--select', '-s'].")
            )
            .arg(
                Arg::new("engagement")
                .long("engagement")
                .value_name("ENGAGEMENT-NAME")
                .num_args(0..=1)
                .help("the engagement database to query.")
            )
            .arg(
                // TODO: rewrite this to be db agnostic
                Arg::new("graphql_query")
                .long("query")
                .short('q')
                .value_name("QUERY")
                .num_args(1)
                .conflicts_with_all(["get", "equal", "require", "get-predicates"])
                .help("manually specify the SQL or GraphQL, query.")
            )
            .arg(
                // TODO: rewrite this to be db agnostic
                Arg::new("equal")
                .long("equal")
                .short('e')
                // .value_delimiter(',')
                .action(ArgAction::Append)
                .visible_alias("eq")
                .value_name("EQUIVALENCE")
                .num_args(2..)
                .help("specify an \"eq\" function call inside a filter derivative. aliases include ['--eq'].")
            )
            .arg(
                // TODO: rewrite this to be db agnostic
                Arg::new("require")
                .long("require")
                .short('r')
                .num_args(0..)
                // .action(ArgAction::SetFalse)
                .value_name("REQUIRED-PREDICATES")
                .help("require that all predicates must be present in return value.")
            )
            // .arg(
            //     Arg::new("target")
            //     .long("from")
            //     .short('f')
            //     .alias("target")
            //     .short_alias('t')
            //     .value_name("TARGET") // parse as an Option<String>
            //     .num_args(1)
            //     .required(true)
            //     .help("the target to select from. targets are defined in the config file. aliases include ['--target', '-t']. targets are tables that are joined with other tables using the \"JOIN\" keyword. (or when using the '--list-columns' flag)")
            // )
            .arg( // make this get the schema
                Arg::new("get-predicates")
                .long("list-columns")
                .short('l')
                .alias("columns")
                .alias("get-columns")
                .alias("list")
                .short_alias('c')
                .num_args(0)
                .action(ArgAction::SetTrue)
                .help("lists the columns that can be selected from the target. aliases include ['--get-columns', '--columns', '--list', 'c']. (targets are designated with the '--from' or '--target').")
            )
        )
        .subcommand(
            Command::new("pause")
                .about("Pauses the interpretation of commands until the resume command is received.")
        )
        .subcommand(
            Command::new("resume")
                .about("Resumes the interpretation of commands from a paused state.")
        )
        .subcommand(
        Command::new("config")
            .about("Used to change configurations.")
            .arg(
                Arg::new("switch-engagement")
                .long("s-eng")
                .short('e')
                .alias("switch-engagement")
                .value_name("ENGAGEMENT-CONF")
                .num_args(1)
                .help("switches to the selected engagement config.")
            )
            .arg(
                Arg::new("switch-sql")
                .long("s-sql")
                .short('s')
                .alias("switch-sql")
                .value_name("SQL-SERVER-CONF")
                .num_args(1)
                .help("switches to the selected SQL server config.")
            )
        )
        .subcommand(
            Command::new("info")
                .about("Prints information about the current state.")
        )
        .get_matches()
}

fn parse_arg_bool(matches: ArgMatches, option: &str, default: bool) -> bool {
    match matches.get_one::<bool>(option) {
        Some(value) => *value,
        None => default,
    }
}

fn parse_str_now(
    log: String,
    exit_status: i32,
    matches: ArgMatches, 
    configs: config_loading::Config,
    engage_conf: config_loading::EngageConf
) {
    match ptdb_lib::process_raw_input(format!("{}\n{}", exit_status, log), true, matches.get_one::<String>("command-name"), configs, engage_conf) {
        Ok(mesg) =>  ptdb_lib::console_log(&mesg, parse_arg_bool(matches, "quiet", false)),
        Err(mesg) =>  ptdb_lib::console_log(&mesg, false),
    };
}

/// entry point when running in manual mode.
fn manual_mode(
    matches: ArgMatches, 
    configs: config_loading::Config, 
    engage_conf: config_loading::EngageConf
) {
    let buf = get_std_in();
    let es = match matches.get_one::<String>("exit-status") {
        Some(es) => match es.parse::<i32>() {
            Ok(num) => num,
            Err(_mess) => {
                ptdb_lib::console_log("exit status must be parsable as an i32.", false);
                exit(1);
            }
        },
        None => 0,
    };

    match strip_ansi_escapes::strip(&buf) {  // strips tab characters (sometimes)
        Ok(raw_text) => {
            match std::str::from_utf8(&raw_text) {
                Ok(log_d) => {
                    parse_str_now(log_d.to_string(), es, matches, configs, engage_conf);
                }
                Err(e) => {
                    eprintln!("[PTDB ERROR] could not interpret text on stdin as UTF-8. Are you sure is was ONLY text?");
                    eprintln!("got error message:");
                    eprintln!("{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("[PTDB ERROR] failed to strip ansi control codes from input.\ngot error message:\n{}", e);
            exit(1);
        }
    }
    // parse_str_now(String::from_utf8(buf).unwrap(), es, matches, configs, engage_conf)
}

fn make_fname(dir: &str, name: Option<String>, alt: &str) -> String {
    let name = match name {
        Some(file) => config_loading::make_toml(&file),
        None => config_loading::make_toml(&alt),
    };
    tilde(&if name.starts_with("~/") || name.starts_with("/") {name} else {format!("{}/{}", dir, name)}).to_string()
}

fn complete() {
    // let fname = make_fname(dir, name, ptdb_lib::ENGAGEMENT_ADR);
    let engage = config_loading::get_engagement(ptdb_lib::ENGAGEMENT_ADR);

    println!("The '{}' engagement is {}!", engage.name, if engage.complete {"complete"} else {"incomplete"});
}

fn info(name: Option<String>, dir: &str, current: &str) {
    let fname = make_fname(dir, name, &current);
    let engage = config_loading::get_engagement(&fname);

    println!("info on '{}':\n{:#?}", engage.name, engage);
}

fn new_engage(name: String, engagement_dir: &str, matches: &ArgMatches) -> Result<(), Error> {
    let path = make_fname(engagement_dir, None, &name);
    let conf = config_loading::EngageConfRaw {
        name: name.clone(),
        complete: false,
        db_conf: matches.get_one::<String>("sql-server").cloned(),
    }.defaultify();

    println!("making file at location: '{}'.", path);

    if !Path::new(&path).exists() {
        // println!("conf file already exsists at location: '{}' .", path);
        // exit(1);
        let mut output = File::create(path)?;

        write!(output, "{}", match toml::to_string(&conf) {
            Ok(s) => s,
            Err(_) => {
                println!("could not serialize engagement configuration.");
                exit(1);
            }
        })?;
        println!("file created!");
    }

    if matches.contains_id("activate") {
        // change_config("engagement_conf", &format!("\"{}\"", &make_toml(&name)), ptdb_lib::CONFIG_ADR);
        activate_engagement(matches.get_one::<String>("activate").cloned(), &config_loading::make_toml(&name));
        println!("the engagement, \"{}\", is now active.", name);
    }

    match make_sql_db(&name, config_loading::get_config()) {
        Ok(_) => {}
        Err(m) => {
            eprintln!("{}", m);
            exit(1);
        }
    };

    Ok(())
}

fn activate_engagement(engagement_1: Option<String>, engagement_2: &str) {
    let fname = make_fname(ptdb_lib::ENGAGEMENTS_DIR, engagement_1, engagement_2);
    // println!("{}", &fname); // debug
    // if new engagement exists:
    if Path::new(&fname).exists() {
        // remove sym link,
        match remove_file(tilde(ptdb_lib::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {},
            Err(e) => {
                println!("could not remove file. got error: {}", e);
                exit(1);
            },
        }
        // replace sym link
        match symlink(&fname, tilde(ptdb_lib::ENGAGEMENT_ADR).to_string()) {
            Ok(_) => {},
            Err(e) => {
                println!("could not add symlink. got error: {}", e);
                exit(1);
            }
        }
    } else { 
        // else print error
        eprintln!("could not create symlink to the engagement file located at <{}>", fname);
        exit(1);
    }
}

fn make_sql_db(name: &str, configs: config_loading::Config) -> Result<(), String> {
    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &None,
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    )?;

    let create_db = format!("CREATE DATABASE \"{}\";", name);
    match client.execute(&create_db, &[]) {
        Ok(_) => {}
        Err(mesg) => return Err(format!("could not create an sql database called \"{}\". got error:\n{}", name, mesg)),
    }
    let _ = client.close();

    let mut client = ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &Some(String::from(name)),
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    )?;
    let format_db = match std::fs::read_to_string(ptdb_lib::MAKE_SQL_DB) {
        Ok(contents) => contents,
        Err(mesg) => return Err(format!("could not read the sql database, template file. got error:\n{}", mesg)),
    };

    let res = client.batch_execute(&format_db);
    let _ = client.close();
    
    match res {
        Ok(_) => {
            println!("db created!");
            Ok(())
        }
        Err(mesg) => Err(format!("could not set up the sql database with the required tables. got error:\n{}", mesg))
    }
}

fn change_config(val_name: &str, new_val: &str, config_file: &str) {
    match fs::read_to_string(format!("{}", tilde(config_file))) {
        Ok(text) => {
            match mod_conf(&text, val_name, new_val, config_file) {
                Ok(_) => {},
                Err(e) => {
                    eprintln!("could not read/write from/to config file. got error:\n{}", e);
                    exit(1);
                }
            }
        }
        Err(e) => {
            eprintln!("could not read config file. got error:\n{}", e);
            exit(1);
        }
    };
}

fn mod_conf(text: &str, val_name: &str, new_val: &str, config_file: &str) -> Result<(), Error> {
    let mut file = File::create(format!("{}", tilde(config_file)))?;
    let mut changed = false;

    for line in text.lines() {
        if line.starts_with(&format!("{}=", val_name)) || line.starts_with(&format!("{} =", val_name)) {
            file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
            changed = true;
        } else {
            file.write(format!("{}\n", line).as_bytes())?;
        };
    };

    if !changed {
        file.write(format!("{} = {}\n", val_name, new_val).as_bytes())?;
    }

    Ok(())
}

fn engage_mode(matches: &ArgMatches) {
    // println!("engage mode");
    if matches.contains_id("new") {
        // TODO: make this an if let Some(...) ...
        match matches.get_one::<String>("new") {
            Some(name) => {
                let _ = new_engage(name.to_string(), ptdb_lib::ENGAGEMENTS_DIR, matches);
            },
            None => {
                // unreachable but necessary to unwrap the Option<String> returned by .get_one(...)
                eprintln!("--new requires the name of the engagement you want to make.");
                exit(1);
            }
        }
    }
    else if matches.contains_id("engage") {
        info(matches.get_one::<String>("engage").cloned(), ptdb_lib::CONFIG_DIR, ptdb_lib::ENGAGEMENT_ADR)
    }
    else if matches.contains_id("complete") {
        complete()
    } else if matches.contains_id("activate") {
        match matches.get_one::<String>("activate") {
            Some(engagement) => {
                // change_config("engagement_conf", &format!("\"{}\"", make_toml(engagement)), ptdb_lib::CONFIG_ADR);
                activate_engagement(None, &engagement);
                println!("the engagement, \"{}\", is now active.", engagement);
            }
            None => {
                eprintln!("--activate requires the name of the engagement you want to activate.");
                exit(1);
            }
        }
    }
}

/// this shoudl really be renamed bc its NOT ONLY for usr defined sql queries. its for making
/// any sql query that it a full query defined in a string. (provided you know the engagement that is. 
/// but the template database can be used as a default.) 
fn usr_sql_query(
    // prepare: &Option<String>,
    query: &String, 
    // cleanup: &Option<String>,
    engagement: Option<String>, 
    configs: &config_loading::Config
) -> Result<(), String> {
    // println!("{:?}", engagement);
    let mut client = match ptdb_lib::connect(
        &configs.sql.host,
        &configs.sql.user,
        &configs.sql.passwd,
        &configs.sql.port,
        &engagement,
        &configs.sql.ssl_cert,
        configs.sql.require_ssl,
    ) {
        Ok(c) => c,
        Err(mesg) => {
            ptdb_lib::console_log(&mesg, false);
            exit(1);
        }
    };

    let mut titles = Vec::new();
    let tmp_query = query.clone();
    let mut tokens = tmp_query.split(' ').into_iter();
    while let Some(token) = tokens.next() {
        if token.to_lowercase() == "select" || token.to_lowercase() == "distinct" {
            continue;
        } else if token.to_lowercase() == "from" {
            break;
        } else if token.to_lowercase() == "top"{
            tokens.next();
            continue;
        } else {
            titles.push(String::from(token));
        }
    }

    match &configs.targets.prepare {
        Some(cmds) => {let _ = client.batch_execute(cmds);},
        None => {},
    };

    let res = match client.query(query, &[]) {
        Ok(dat) => dat,
        Err(mesg) => return Err(format!("could not execute sql command. got error:\n{}", mesg)),
    };

    match &configs.targets.cleanup {
        Some(cmds) => {let _ = client.batch_execute(cmds);},
        None => {},
    };

    let _ = client.close();

    if !res.is_empty() && !titles.is_empty() {
        print_table(res);
        Ok(())
    } else if !res.is_empty() && titles.is_empty() {
        println!("{:?}", res);
        Ok(())
    } else {
        Err(String::from("sql query returned no results :("))
    }
}

fn generic_query(
    get_arg: Vec<String>, 
    engagement_arg: Option<String>, 
    condition_arg: String, 
    target_arg: String,
    configs: config_loading::Config,
    engage_conf: &config_loading::EngageConf
)  -> Result<(), String> {
    let select_clause = format!("SELECT DISTINCT {}", get_arg.join(", "));  // makes select clause in the form of "SELECT get[0], get[1], ... ,get[n]"
    let engagement = match engagement_arg {
        Some(engagement) if engagement.is_empty() => None,
        Some(engagement) => Some(engagement),
        None => Some(engage_conf.name.clone()),
    };
    let query = match configs.targets.targets.get(&target_arg) {
        Some(target) => target,
        None => return Err(format!("target \"{}\" is not in the config file.", target_arg)),
    };
    let where_clause = if condition_arg.is_empty() {
        condition_arg
    } else {
        format!("WHERE {}", condition_arg)
    };

    let cmd = format!("{} {} {};", select_clause, query, where_clause); 
    // target.query.replace("QUERY", &get_arg.join(", ")).replace("WHERE", &where_clause); // SELECT {select_clause}
    // println!("{}", cmd);
    usr_sql_query(&cmd, engagement, &configs)
}

fn get_tables(target: &str) -> IntoIter<&str> {
    let mut table_names: HashSet<&str> = HashSet::new();
    let tokens = target.split(' ');
    let mut last_token = "";

    for token in tokens {
        if last_token == "FROM" || last_token == "JOIN" {
            let _ = table_names.insert(token.clone());
        }
        last_token = token;
    }

    table_names.into_iter()
}

fn get_column_names(target_name: &str, engagement_arg: Option<String>, configs: &config_loading::Config, engage_conf: &config_loading::EngageConf) {
    let engagement = match engagement_arg {
        Some(engage) => Some(engage),
        // None => &configs.sql.template_db,
        None => Some(engage_conf.name.clone()),
    };
    let target = match configs.targets.targets.get(target_name) {
        Some(target) => target,
        None => {
            println!("target \"{}\" is not in the config file.", target_name);
            return
        }
    };
    
    let columns = get_tables(&target);
    // println!("columns : {:?}", &columns);
    let where_clause = columns
                            .map(|x| format!("table_name = '{}'", x))
                            .collect::<Vec<String>>()
                            .join(" OR ");

    // println!("where_clause: {}", where_clause);

    let query = format!(
        "SELECT table_name, column_name FROM information_schema.columns WHERE {} ORDER BY table_name;",
        where_clause
    );
    // println!("sql query: {}", query);

    match usr_sql_query(&query, engagement, configs) {
        Ok(_) => {},
        Err(e) => {
            eprintln!("get_column_names() | could not get the columns for the tables from in the target: {}. got error:\n{}", query, e);
            exit(1);
        }
    };
}

fn query_mode(matches: &ArgMatches, configs: config_loading::Config, engage_conf: &config_loading::EngageConf) {
    // println!("query mode");
    let engagement = get_engagement_as_str(matches, &engage_conf.name);

    if Some(&true) == matches.get_one::<bool>("get-predicates") {
        println!("under construction!");
        // get_column_names(&get_as_str(matches, "", None), engagement, &configs, engage_conf);
        // return;
    } else if let Some(query) = matches.get_one::<String>("graphql_query") {
        println!("under construction!");
        // match usr_sql_query(query, engagement, &configs) {
        //     Ok(_) => {}
        //     Err(m) => ptdb_lib::console_log(&m, false),
        // }
        // return;
    } else {
        let get_args = match matches.get_many::<String>("get") {
            Some(columns) => columns.cloned().map(|x| if x.ends_with(",") {x.replace(",", "")} else {x.to_string()}).collect::<Vec<String>>(),
            None => { // unreachable
                eprintln!("a get argument is required.");
                exit(1);
            },
        };

        let eq_args = match matches.grouped_values_of("equal") {
            Some(columns) => {
                let mut args = Vec::new();
                for eq in columns { args.push(eq) }
                args
            }
            None => Vec::new(),
        };
        
        let req_args = match matches.get_many::<String>("require") {
            Some(required) if required.len() > 0 => Some(required.cloned().map(|x| if x.ends_with(",") {x.replace(",", "")} else {x.to_string()}).collect::<Vec<String>>()),
            Some(required) if required.len() == 0 => Some(get_args.clone()),
            _ => None,
        };

        // println!("get_args: {:?}", get_args);
        // println!("eq_args: {:?}", eq_args);
        // eprintln!("req_args: {:#?}", req_args);
        
        let query = match make_query(&get_args, &eq_args, req_args, &engagement, &configs) {
            Ok(q) => q,
            Err(mes) => {
                ptdb_lib::console_log(&format!("could not generate query. got_error:\n{}", mes), false);
                exit(1);
            },
        };
        eprintln!("query :  \n{}", query);

        let res = send_query(&query, &configs);

        match res {
            Ok(_) => {}
            Err(message) => {
                eprintln!("[PTDB ERROR] could not query database. got error:\n{}", message);
                exit(1);
            }
        }
    }
}

fn send_query(query: &str, configs: &config_loading::Config) -> Result<(), String> {
    let res = ptdb_lib::com_with_db(query, "/query", "application/dql", configs)?;
    // println!("{:?}", res);
    Ok(())
}

fn make_query(
    get_args: &[String],
    eq_args: &[Vec<&str>],
    req_arg: Option<Vec<String>>,
    engagement: &str,
    configs: &config_loading::Config, 
) -> Result<String, String> {
    let target_type = "machine";
    let mut d_types = HashMap::new();
    // let mut pred_to_par = HashMap::new();

    let mut query = match configs.templates.queries.get(target_type) {
        Some(query) => {
            let mut fin_query: Vec<String> = Vec::new();
            let mut types = HashSet::new();
            // let mut parent = target_type;

            for raw_line in query {
                let line = raw_line.trim();
                match line.split_once(":") {
                    Some((id, pred)) => {
                        d_types.insert(id, pred.trim());
                        let is_selected = get_args.contains(&id.to_string());
                        if is_selected {
                            // println!("type => {}", pred.trim().split_once(".").unwrap().0);
                            match pred.trim().split_once(".") {
                                Some(t) => {types.insert(t.0);},
                                None => {},
                            }
                        }
                    },
                    _ => {},
                };
            }
            let mut n_curly = 0;
            for raw_line in query {
                let line = raw_line.trim();
                let is_get_line = match line.split_once(":") {
                    Some((id, _pred)) => {
                        let is_selected = get_args.contains(&id.to_string());
                        is_selected
                    },
                    _ => false,
                };
                let mut is_sub_root = false;
                for t in &types {
                    is_sub_root = is_sub_root || (line.contains(&format!(": ~{}.", t)) && !line.starts_with(&format!("{}.", t)));
                } 

                if is_sub_root || is_get_line || line.starts_with("query") || (line == "}" && n_curly == 0) || line.contains("func:") {
                    fin_query.push(raw_line.to_owned());
                } else if line.ends_with("{") {
                    // println!("+1 => {} => {}", raw_line, n_curly);
                    n_curly += 1;
                } else if line == "}" && n_curly > 0 {
                    n_curly -= 1;
                } else {
                }
            }

            fin_query.join("\n")
        },
        None => return Err("that type is not available to query. try querying based on something else.".to_string()),
    };

    let require = match req_arg {
        Some(_) => true,
        None => false,
    };
    
    let (mach_f, 
        port_f,
        web_d_f, 
        dns_f,
        mach_c, 
        port_c,
        web_d_c, 
        dns_c,
        ) = make_filters(get_args, eq_args, req_arg, d_types, engagement)?;

    query = query
            .replace("<MACHINE_FILTER>", &mach_f)
            .replace("<PORT_FILTER>", &port_f)
            .replace("<DNS_FILTER>", &dns_f)
            .replace("<WEB_DIR_FILTER>", &web_d_f)
            // .replace("<MACHINE_CASCADE>", if require && target_type.to_lowercase() == "machine" {"@cascade"} else {&mach_c})
            // .replace("<PORT_CASCADE>", if require && target_type.to_lowercase() == "port" {"@cascade"} else {&port_c})
            // .replace("<DNS_CASCADE>", if require && target_type.to_lowercase() == "dns_name" {"@cascade"} else {&dns_c})
            // .replace("<WEB_DIR_CASCADE>", if require && target_type.to_lowercase() == "web_dir" {"@cascade"} else {&web_d_c});
            .replace("<MACHINE_CASCADE>", &mach_c)
            .replace("<PORT_CASCADE>", &port_c)
            .replace("<DNS_CASCADE>", &dns_c)
            .replace("<WEB_DIR_CASCADE>", &web_d_c);
    return Ok(query)
}

fn make_filters(
    get_args: &[String],
    eq_args: &[Vec<&str>], 
    req_args: Option<Vec<String>>,
    d_types: HashMap<&str, &str>,
    // pred_to_par: HashMap<&str, &str>,
    engagement: &str, 
) -> Result<(String, String, String, String, String, String, String, String), String> {
    let mut mach_f: Vec<String> = vec![format!("eq(Machine.engagement, \"{}\")", engagement)];
    let mut port_f: Vec<String> = vec![format!("eq(Port.engagement, \"{}\")", engagement)];
    let mut web_d_f: Vec<String> = vec![format!("eq(WebDir.engagement, \"{}\")", engagement)];
    let mut dns_f: Vec<String> = vec![format!("eq(DNSName.engagement, \"{}\")", engagement)];
    let mut creds_f: Vec<String> = vec![format!("eq(DNSName.engagement, \"{}\")", engagement)];
    // println!("d_types => {:#?}", d_types);
    // make the filter list
    for safe_eq in eq_args {
        let mut eq = safe_eq.clone();
        eq.reverse(); 
        let predicate = match eq.pop() {
            Some(pred) => {
                match d_types.get(pred.to_lowercase().as_str()) {
                    Some(p) => *p,
                    None => return Err(format!("i don't know the predicate '{}' that you requested.", pred))
                }
            }
            None => continue,
        };
    
        // println!("predicate => {:#?}", predicate);


        let values = if eq.len() > 1 {
            format!("[\"{}\"]", eq.join("\", \""))
        } else {
            format!("\"{}\"", eq[0])
        };

        let eq_check = format!("eq({}, {})", predicate, values);

        let tmp_v: &mut Vec<String> = if predicate.starts_with("Machine.") {
            &mut mach_f
        } else if predicate.starts_with("Port.") {
            &mut port_f
        } else if predicate.starts_with("WebDir.") {
            &mut web_d_f
        } else if predicate.starts_with("DNSName.") {
            &mut dns_f
        } else if predicate.starts_with("Credential.") {
            &mut creds_f
        } else {
            return Err(format!("don't know how to process the predicate: '{}'", predicate))
        };

        tmp_v.push(eq_check);
    }

    // make the cascade strings
    let (mach_c, port_c, web_d_c, dns_c) = match req_args {
        Some(data) if (data.len() == 1 && data[0] == "*") || data.len() == 0 => {
            ("@cascade".to_string(), "@cascade".to_string(), "@cascade".to_string(), "@cascade".to_string())        
        }
        Some(data) => {
            let mut mach_c: Vec<&str> = Vec::new();
            let mut port_c: Vec<&str> = Vec::new();
            let mut web_d_c: Vec<&str> = Vec::new();
            let mut dns_c: Vec<&str> = Vec::new();
            let mut creds_c: Vec<&str> = Vec::new();

            for required in data {
                let data_t = match d_types.get(required.as_str()) {
                    Some(d_t) => *d_t,
                    None => return Err(format!("unknown data type for requirement, '{}'.", required)),
                };
                let tmp_v: &mut Vec<&str> = if data_t.starts_with("Machine") {
                    &mut mach_c
                } else if data_t.starts_with("Port.") {
                    &mut port_c
                } else if data_t.starts_with("WebDir.") {
                    &mut web_d_c
                } else if data_t.starts_with("DNSName.") {
                    &mut dns_c
                } else if data_t.starts_with("Credential.") {
                    &mut creds_c
                } else {
                    return Err(format!("could not get data type for requirement, '{}'.", required));
                };
                tmp_v.push(data_t);
            }

            (if mach_c.len() > 0 {format!("@cascade({})", mach_c.join(", "))} else { String::from("") }, 
            if port_c.len() > 0 {format!("@cascade({})", port_c.join(", "))} else { String::from("") }, 
            if web_d_c.len() > 0 {format!("@cascade({})", web_d_c.join(", "))} else { String::from("") }, 
            if dns_c.len() > 0 {format!("@cascade({})", dns_c.join(", "))} else { String::from("") })
        }
        None => {
            (String::new(), String::new(), String::new(), String::new())
        }
    };

    Ok(
        (
            format!("@filter({})", mach_f.join(" and ")), 
            format!("@filter({})", port_f.join(" and ")), 
            format!("@filter({})", web_d_f.join(" and ")), 
            format!("@filter({})", dns_f.join(" and ")),
            mach_c, 
            port_c, 
            web_d_c, 
            dns_c
        )
    )
}

fn get_engagement_as_str(matches: &ArgMatches, alt: &str) -> String {
    match matches.get_one::<String>("engagement") {
        Some(name) => name.to_owned(),
        None => alt.to_string(),
    }
}

fn get_engagement_as_opt(matches: &ArgMatches, alt: &str) -> Option<String> {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>("engagement").cloned() {
        Some(engagement) => {
            // if the user says `-e ""`
            if !engagement.is_empty() {
                Some(engagement.clone())
            } else {
                None
            }
        }
        None => {
            // if the user includes the -e flag but provides no option
            if !matches.contains_id("engagement") {
                Some(String::from(alt))
            } else {
                None
            }
        }
    }
}

fn get_as_str(matches: &ArgMatches, option: &str, alt: Option<&str>) -> String {
    // matches.get_one::<String>(option).cloned()
    match matches.get_one::<String>(option) {
        Some(columns) => columns.clone(),
        None => match alt {
            Some(alt_text) => alt_text.to_string(),
            None => {
                eprintln!("The argument, \"{}\", is required in this context but was not present. please try again.", option);
                exit(1);
            }
        }
    }
}

fn print_table(sql_rows: Vec<PgrsRow>) {
    let mut table = Table::new();
    table.set_format(*format::consts::FORMAT_NO_BORDER_LINE_SEPARATOR);
    // table.set_format(*format::consts::FORMAT_NO_LINESEP_WITH_TITLE);
    // let mut titles = input_titles;
    let n_rows = sql_rows.len();
    let titles = make_title(&sql_rows[0]);
    table.set_titles(Row::from(titles));

    for sql_row in sql_rows {
        // let r= make;
        table.add_row(Row::from(make_printable_row(sql_row)));
    }
    // println!("titles : {:?}", titles);

    // Print the table to stdout
    table.printstd();
    println!("({} rows of data)", n_rows);
    // or print in csv format if being piped or redirected into something else.
    /*
    let writer = /* create a writer */;
    table.to_csv_writer(writer)?; 
    */
}

fn make_printable_row(sql_row: PgrsRow) -> Vec<String> {
    let mut printable: Vec<String> = Vec::new();
    
    for (i, cell) in sql_row.columns().into_iter().enumerate() {
        let cell_type = cell.type_().name();
        // println!("{}", cell_type);

        let value = if cell_type.starts_with("varchar") {
            format!("{}", sql_row.get::<usize, String>(i))
        } else if cell_type.starts_with("int") {
            format!("{}", sql_row.get::<usize, i32>(i))
        } else if cell_type.starts_with("float") {
            format!("{}", sql_row.get::<usize, f64>(i))
        } else {
            format!("{}", sql_row.get::<usize, String>(i))
        };
        
        printable.push(value);
    }

    printable
}

fn make_title(sql_row: &PgrsRow) -> Vec<&str> {
    let mut titles: Vec<&str> = Vec::new();

    for cell in sql_row.columns() {
        titles.push(cell.name());
    }

    titles
}