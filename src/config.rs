#![warn(clippy::all)]
use anyhow::{self, bail, Result};
use figment::{
    providers::{Format, Toml},
    Figment,
};
use log::{error, info};
use serde::Deserialize;
use serde::Serialize;
use shellexpand::tilde;
use std::{
    collections::HashMap,
    env,
    path::{Path, PathBuf},
    process::exit,
};

#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub enum DBType {
    GraphQL,
    SQL,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct EngageConfRaw {
    pub name: String,
    pub complete: bool,
    pub db_conf: Option<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct EngageConf {
    pub name: String,
    pub complete: bool,
    pub db_conf: String,
}

/// user configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct UsrConfRaw {
    pub active: bool,
    pub server_mode: Option<ServerModeConfRaw>,
    pub targets_prepare: Option<String>,
    pub targets_cleanup: Option<String>,
    pub targets: HashMap<String, String>,
    pub parsers: HashMap<String, Vec<ParserConfRaw>>,
}

/// user server mode configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ServerModeConfRaw {
    pub socket_adr: Option<String>,
    pub quiet_logs: Option<bool>,
}

/// user parser configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ParserConfRaw {
    pub args: Option<Vec<Vec<String>>>,
    pub parser: String,
    pub help: Option<Vec<String>>,
    pub parse_on_error: Option<bool>,
}

/// user database server configurations from the file.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct DBServerRaw {
    pub host: String,
    pub user: String,
    pub passwd: Option<String>,
    pub port: Option<String>,
    pub ssl_cert: Option<String>,
    pub require_ssl: Option<bool>,
    pub db_type: DBType,
}

/// global program configurations.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct GlobalConfRaw {
    pub host_id: Vec<String>,
    pub port_id: Vec<String>,
    pub sql_nul_val: Option<String>,
    pub sql_tables: HashMap<String, String>,
    pub overlap: HashMap<String, String>,
}

/// user database server configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct UsrConf {
    pub active: bool,
    pub server_mode: ServerModeConf,
    pub targets_prepare: Option<String>,
    pub targets_cleanup: Option<String>,
    pub targets: HashMap<String, String>,
    pub parsers: HashMap<String, Vec<ParserConf>>,
}

/// user server mode configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ServerModeConf {
    pub socket_adr: String,
    pub quiet_logs: bool,
}

/// user parser configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ParserConf {
    pub args: Option<Vec<Vec<String>>>,
    pub parser: String,
    pub help: Vec<String>,
    pub parse_on_error: bool,
}

/// user database server configurations w/ defaults applied.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct DBServer {
    pub host: String,
    pub user: String,
    pub passwd: Option<String>,
    pub port: String,
    pub ssl_cert: Option<String>,
    pub require_ssl: bool,
    pub db_type: DBType,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TargetsConf {
    pub targets: HashMap<String, String>,
    pub prepare: Option<String>,
    pub cleanup: Option<String>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct RDFTypes {
    pub integer: String,
    pub boolean: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TemplateConf {
    pub query: String,
    pub add_mutate: String,
    pub mod_mutate: String,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct TemplatesConf {
    pub rdf_add_line: String,
    pub rdf_update_line: String,
    pub rdf_types: RDFTypes,
    pub queries: HashMap<String, Vec<String>>,
    pub mutations: HashMap<String, TemplateConf>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct Config {
    pub active: bool,
    pub db_server: DBServer,
    pub server_mode: ServerModeConf,
    pub parsers: HashMap<String, Vec<ParserConf>>,
    pub targets: TargetsConf, // HashMap<String, String>,
    pub templates: TemplatesConf,
}

impl EngageConfRaw {
    pub fn defaultify(&self) -> EngageConf {
        let sql_server = match &self.db_conf {
            Some(server) => server.clone(),
            None => String::from("default"),
        };

        EngageConf {
            name: self.name.clone(),
            complete: self.complete,
            db_conf: sql_server,
        }
    }
}

trait Defaultify {
    type FullConf;

    fn defaultify(&self) -> Self::FullConf;
}

impl Defaultify for ServerModeConfRaw {
    type FullConf = ServerModeConf;

    fn defaultify(&self) -> Self::FullConf {
        let default = ServerModeConf::new(); // this way i only need to change the defaults in one place.

        ServerModeConf {
            socket_adr: match &self.socket_adr {
                Some(adr) => adr.clone(),
                None => default.socket_adr,
            },
            quiet_logs: match self.quiet_logs {
                Some(suppress_logs) => suppress_logs,
                None => default.quiet_logs,
            },
        }
    }
}

impl ServerModeConf {
    /// default for ServerModeConf.
    fn new() -> Self {
        ServerModeConf {
            socket_adr: String::from("/tmp/ptdb/server"),
            quiet_logs: false,
        }
    }
}

impl Defaultify for ParserConfRaw {
    type FullConf = ParserConf;

    fn defaultify(&self) -> Self::FullConf {
        ParserConf {
            args: self.args.clone(),
            parser: self.parser.clone(),
            help: match &self.help {
                Some(flags) => flags.clone(),
                None => vec![String::from("-h"), String::from("--help")],
            },
            parse_on_error: match self.parse_on_error {
                Some(opt) => opt,
                None => true,
            },
        }
    }
}

impl UsrConfRaw {
    fn defaultify_parsers(&self) -> HashMap<String, Vec<ParserConf>> {
        // TODO: this function is nonsensical. fix that.
        let mut parsers = HashMap::new();

        for (exec, confs) in &self.parsers {
            let mut new_confs = Vec::new();
            for conf in confs {
                new_confs.push(conf.defaultify());
            }
            parsers.insert(exec.clone(), new_confs);
        }

        parsers
    }
}

impl Defaultify for UsrConfRaw {
    type FullConf = UsrConf;

    fn defaultify(&self) -> Self::FullConf {
        let server_mode = match &self.server_mode {
            Some(mode) => mode.defaultify(),
            None => ServerModeConf::new(),
        };

        UsrConf {
            active: self.active,
            server_mode,
            targets_prepare: self.targets_prepare.clone(),
            targets_cleanup: self.targets_cleanup.clone(),
            targets: self.targets.clone(),
            parsers: self.defaultify_parsers(),
        }
    }
}

impl Defaultify for DBServerRaw {
    type FullConf = DBServer;

    fn defaultify(&self) -> DBServer {
        let require_ssl = if let Some(ssl) = self.require_ssl {
            ssl
        } else {
            false
        };

        DBServer {
            host: self.host.clone(),
            user: self.user.clone(),
            passwd: self.passwd.clone(),
            port: if let Some(port) = &self.port {
                port.clone()
            } else {
                String::from("5432")
            },
            ssl_cert: self.ssl_cert.clone(),
            require_ssl,
            db_type: self.db_type,
        }
    }
}

impl Config {
    fn new(usr_raw: UsrConfRaw, db_server_raw: DBServerRaw, template: TemplatesConf) -> Config {
        let user = usr_raw.defaultify();
        let db = db_server_raw.defaultify();

        Config {
            active: user.active,
            db_server: db,
            server_mode: user.server_mode,
            parsers: user.parsers,
            targets: TargetsConf {
                targets: user.targets,
                prepare: user.targets_prepare,
                cleanup: user.targets_cleanup,
            },
            templates: template,
        }
    }
}

pub const GLOB_CONFIG_ADR: &str = "/etc/ptdb/config.toml";
pub const TEMPLATE_CONF: &str = "/etc/ptdb/templates.toml";
pub const USR_CONFIG_ADR: &str = "~/.config/ptdb/config.toml";
// pub const DB_SERVER_ADR: &str = "~/.config/ptdb/db-server.toml";
pub const DB_CONF_DIR: &str = "~/.config/ptdb/db-servers/";
pub const ENGAGEMENT_ADR: &str = "~/.config/ptdb/engagement.toml";

pub fn make_toml(fname: &str) -> String {
    if fname.ends_with(".toml") || fname.ends_with(".tml") {
        String::from(fname)
    } else {
        format!("{}.toml", fname)
    }
}

fn gen_db_conf(server_name: &str) -> String {
    let name_toml = make_toml(server_name);
    format!("{}{}", DB_CONF_DIR, name_toml)
}

/// print config load error message then siece execution
macro_rules! config_load_error {
    ($toml_name:ident, $e:ident) => {
        error!("could not load user config file at: \"{}\",\n - does the file exist?\n - is it formatted correctly?\ngot error:\n{}", $toml_name, $e);
        exit(1);
    };
}

// TODO: make less jank by using anyhow
fn get_config_helper() -> Result<Config, (String, figment::Error)> {
    let usr_raw = match Figment::new()
        .merge(Toml::file(tilde(&USR_CONFIG_ADR).to_string()))
        .extract()
    {
        Ok(conf) => conf,
        Err(e) => return Err((USR_CONFIG_ADR.to_string(), e)),
    };

    let db_conf_f = gen_db_conf(&get_engagement(&ENGAGEMENT_ADR).db_conf);
    let db_server_raw = match Figment::new()
        .merge(Toml::file(tilde(&db_conf_f).to_string()))
        .extract()
    {
        Ok(conf) => conf,
        Err(e) => return Err((String::from(db_conf_f), e)),
    };

    let template = match Figment::new()
        .merge(Toml::file(tilde(&TEMPLATE_CONF).to_string()))
        .extract()
    {
        Ok(conf) => conf,
        Err(e) => return Err((TEMPLATE_CONF.to_string(), e)),
    };

    Ok(Config::new(usr_raw, db_server_raw, template))
}

/// gathers global and user configs.
pub fn get_config() -> Config {
    match get_config_helper() {
        Ok(conf) => conf,
        Err((file_name, e)) => {
            config_load_error!(file_name, e);
        }
    }
}

pub fn get_engagement(engage_conf: &str) -> EngageConf {
    let raw_engagement: EngageConfRaw = match Figment::new()
        .merge(Toml::file(tilde(engage_conf).to_string()))
        .extract()
    {
        Ok(conf) => conf,
        Err(e) => {
            config_load_error!(engage_conf, e);
        }
    };

    raw_engagement.defaultify()
}

pub fn get_session_dir() -> anyhow::Result<String> {
    Ok(env::var("log_dir")?)
}

pub fn get_pause_f() -> anyhow::Result<PathBuf> {
    let Ok(log_dir) = get_session_dir() else {
        info!("could not find \"log_dir\" in environment variables.");
        bail!("could not find \"log_dir\" in environment variables.");
    };
    let p = Path::new(log_dir.as_str());

    Ok(p.join("paused"))
}
