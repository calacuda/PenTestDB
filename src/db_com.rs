use crate::config::{Config, EngageConf};
use anyhow::Result;
use clap::ArgMatches;
use log::error;
use std::process::exit;
use tabled::{builder::Builder, Style};

pub const CONFIG_DIR: &str = "~/.config/ptdb/";
pub const ENGAGEMENTS_DIR: &str = "~/.config/ptdb/engagements";
pub const ENGAGEMENT_ADR: &str = "~/.config/ptdb/engagement.toml";
pub const PARSERS_DIR: &str = "/etc/ptdb/parsers/";
pub const MAKE_SQL_DB: &str = "/etc/ptdb/make-db.sql";

pub trait DatabaseConnection {
    fn get_data_names(matches: &ArgMatches, configs: Config, engage_conf: EngageConf) -> String;

    /// sends a query to the data base and returns the responce.
    fn send_query(query: &str, configs: &Config, engage_conf: &EngageConf) -> String;

    /// generates a query. used in conjuction with send_query to query the db. is a seperate
    /// function to allow for dry runs.
    fn gen_query(
        matches: &ArgMatches,
        _engagement: &str,
        configs: Config,
        engage_conf: EngageConf,
    ) -> String;

    /// merges some parser output data into the database
    fn merge_to_db(
        parser_data: &String,
        cmd: String,
        configs: Config,
        engage_conf: EngageConf,
    ) -> Result<u16>;

    /// used when making a new database (ex: when starting a new engagement.)
    fn make_new_db(name: &str, configs: Config) -> Result<()>;
}

pub fn get_as_str(matches: &ArgMatches, option: &str, alt: Option<&str>) -> String {
    match matches.get_one::<String>(option) {
        Some(columns) => columns.clone(),
        None => match alt {
            Some(alt_text) => alt_text.to_string(),
            None => {
                error!("The argument, \"{}\", is required in this context but was not present. please try again.", option);
                exit(1);
            }
        },
    }
}

pub fn print_table(table: Builder) -> String {
    let mut data = table.build();
    format!(
        "{}\n({} rows of data)",
        data.with(Style::psql()).to_string(),
        data.count_rows() - 1
    )
}
