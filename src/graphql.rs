#![warn(clippy::all)]
use crate::config;
use chrono::prelude::*;
use clap::ArgMatches;
use prettytable::Table;
use std::process::exit;
// use prettytable::{Table, Row, format};
use crate::db_com;
use std::collections::{HashMap, HashSet};

type GraphNames = Vec<String>;
type GraphValues = Vec<String>;
type GraphAssociaions = (GraphNames, GraphValues);

#[derive(Debug)]

enum DGType {
    Machine(GraphAssociaions),
    WebDir(GraphAssociaions),
    Credential(GraphAssociaions),
    DSNName(GraphAssociaions),
    // Command(GraphAssociaions),
    Port(GraphAssociaions),
}

pub fn send_query(payload: &str, configs: &config::Config) -> Result<Table, String> {
    // TODO: take server response and turn it into a table then return it.
    let _server_res = com_with_db(payload, "/query", "application/dql", configs)?;
    // let table = make_table(server_res)?:
    Ok(Table::new())
}

/// entry point. used to merge data to the dgraph server.
pub fn merge_to_db(
    output: &String,
    cmd: String,
    configs: config::Config,
    engage_conf: config::EngageConf,
) -> Result<u16, String> {
    let res = store_data(output, cmd, &configs, engage_conf);

    return match res {
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!(
            "merge_to_db() | storing data failed with error:\n{}",
            mesg
        )),
    };
}

pub fn gen_query(
    matches: &ArgMatches,
    engagement: &str,
    configs: config::Config,
) -> Result<(), String> {
    let get_args = match matches.get_many::<String>("get") {
        Some(columns) => columns
            .cloned()
            .map(|x| {
                if x.ends_with(",") {
                    x.replace(",", "")
                } else {
                    x.to_string()
                }
            })
            .collect::<Vec<String>>(),
        None => {
            // unreachable
            eprintln!("a get argument is required.");
            exit(1);
        }
    };

    #[allow(deprecated)]
    let eq_args = match matches.grouped_values_of("equal") {
        Some(columns) => {
            let mut args = Vec::new();
            for eq in columns {
                args.push(eq)
            }
            args
        }
        None => Vec::new(),
    };

    let req_args = match matches.get_many::<String>("require") {
        Some(required) if required.len() > 0 => Some(
            required
                .cloned()
                .map(|x| {
                    if x.ends_with(",") {
                        x.replace(",", "")
                    } else {
                        x.to_string()
                    }
                })
                .collect::<Vec<String>>(),
        ),
        Some(required) if required.len() == 0 => Some(get_args.clone()),
        _ => None,
    };

    // println!("get_args: {:?}", get_args);
    // println!("eq_args: {:?}", eq_args);
    // eprintln!("req_args: {:#?}", req_args);

    let query = match make_query(&get_args, &eq_args, req_args, &engagement, &configs) {
        Ok(q) => q,
        Err(mes) => {
            db_com::console_log(
                &format!("could not generate query. got_error:\n{}", mes),
                false,
            );
            exit(1);
        }
    };
    eprintln!("query :  \n{}", query);

    let res = send_query(&query, &configs);

    match res {
        Ok(_table) => Ok(()), // TODO: add printing of table.
        Err(message) => Err(format!(
            "[PTDB ERROR] could not query database. got error:\n{}",
            message
        )),
    }
}

fn parse_output(line: String, engage_name: &str) -> Result<DGType, String> {
    // let tmp_line = line.clone();
    let mut params: GraphAssociaions = (Vec::new(), Vec::new());
    let tokens = line.split(0 as char).into_iter().collect::<Vec<&str>>();
    let mut dg_type = "";
    // println!("tokens:\n{:#?}", tokens);
    if tokens.len() % 2 != 0 {
        // println!("tokens {:?}", &tokens);
        return Err("[PTDB ERROR] every key needs a value!".to_string());
    }
    for i in (0..tokens.len()).step_by(2) {
        let key = tokens[i];
        let value = tokens[i + 1];
        // println!("{}: {}", key, value);
        params.0.push(key.to_string());
        params.1.push(value.to_string());
        if key == "dgraph.type" {
            dg_type = value;
        }
    }

    params.0.push("command".to_string());
    params.1.push("_:command_0".to_string());
    params.0.push("engagement".to_string());
    params.1.push(engage_name.to_string());

    Ok(match dg_type {
        "Machine" => DGType::Machine(params),
        "Port" => DGType::Port(params),
        "WebDir" => DGType::WebDir(params),
        "DNSName" => DGType::DSNName(params),
        "Credential" => DGType::Credential(params),
        _ => return Err(String::from("no type was specified byt the parser.")),
    })
}

fn add_command_engagement(
    cmd: &str,
    _queries: &mut Vec<String>,
    mutations: &mut Vec<String>,
    engage_conf: config::EngageConf,
) {
    let time: DateTime<Local> = Local::now();

    let command_add = "\tmutation {
        set {
            _:command_0 <Command.command> \"<CMD>\" . 
            _:command_0 <Command.local_time> \"<TIME>\" . 
            _:command_0 <dgraph.type> \"Command\" .  
            _:command_0 <Command.engagement> \"<ENGAGEMENT>\" .  
        }
    }
    "
    .replace("<ENGAGEMENT>", &engage_conf.name)
    .replace("<CMD>", &cmd)
    .replace(
        "<TIME>",
        &format!("{}", time).replacen(" ", "T", 1).replace(" ", ""),
    )
    .to_string();
    mutations.push(command_add);
}

fn store_data(
    output: &String,
    cmd: String,
    configs: &config::Config,
    engage_conf: config::EngageConf,
) -> Result<u16, String> {
    let tmp_output = output.split('\n').into_iter().collect::<Vec<&str>>();
    let engage_name = engage_conf.name.clone();
    // println!("line => ^{:?}?", tmp_output);
    let mut predicates: Vec<DGType> = Vec::new();
    let mut queries: Vec<String> = Vec::new();
    let mut mutations: Vec<String> = Vec::new();

    add_command_engagement(&cmd, &mut queries, &mut mutations, engage_conf);

    for line in tmp_output {
        if line.is_empty() {
            continue;
        }
        // key is the table, value is (column_names, column_value)
        // let mut predicate: HashMap<String, (Vec<String>, Vec<String>)> = HashMap::new();

        let params = match parse_output(line.to_string(), &engage_name) {
            Ok(types) => types,
            Err(e) => return Err(format!("store_data() | could not understand the output of the parser. error on key: '{}'. got error:\n{}",
            line, e))
        };
        // let mut data = HashMap::new();
        predicates.push(params);
        // predicates.push(data);
    }
    // println!("predicates => {:?}", predicates);

    make_query_mut(
        &engage_name,
        predicates,
        &mut queries,
        &mut mutations,
        configs,
    );

    let mut update_text = String::from("\nquery {");
    for line in queries {
        update_text = format!("{}\n{}", update_text, line);
    }
    update_text = format!("{}\n}}", update_text);
    for line in mutations {
        update_text = format!("{}\n{}", update_text, line);
    }
    // println!("UPDATE TEXT:\n{}\n\n", update_text);
    update_text = format!("upsert {{{}}}", update_text);

    return match send_to_db(&update_text, configs) {
        Ok(n) => Ok(n),
        Err(mesg) => Err(format!(
            "store_data() | sending data to db failed with error:\n{}",
            mesg
        )),
    };
}

fn get_machine_id(data: &GraphAssociaions) -> Option<String> {
    for id_name in ["ip", "ipv6", "local_name"] {
        match get_item(id_name, &data) {
            Some(id) => return Some(id),
            None => {}
        }
    }
    return None;
}

fn get_item(name: &str, data: &GraphAssociaions) -> Option<String> {
    let id_i = data.0.iter().position(|x| x == &name)?;
    return Some(data.1[id_i].clone());
}

fn add_query_mutations(
    d_type: &str,
    engage_name: &str,
    data: &GraphAssociaions,
    compare_value: Option<String>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>,
    configs: &config::Config,
) -> Option<()> {
    let machine_name = match get_item("machine", data) {
        Some(dat) => dat.replace("_:", ""),
        None => "".to_string(),
    };
    let host_name = match get_item("host", data) {
        Some(dat) => dat,
        None => "".to_string(),
    };
    let add_name = get_item("uid", data)?.replace("_:", "");

    // if d_type == "Port" {
    //     println!("port uid => {}", add_name);
    // } // debug

    let templates = configs.templates.mutations.get(d_type)?;

    let mut query = templates
        .query
        .replace("<MACHINE_NAME>", &machine_name)
        .replace("<HOST_NAME>", &host_name)
        .replace("<ENGAGEMENT>", &format!("\"{}\"", engage_name))
        .replace("<ADD_NAME>", &add_name);
    query = match compare_value {
        Some(comp_val) => query.replace(
            "<COMP_VAL>",
            &if d_type != "Port" {
                comp_val
            } else {
                format!("\"{}\"", comp_val)
            },
        ),
        None => query,
    };
    query = format!("q{}{}", queries.len(), query);
    // println!("query: {:?}\n", query); // debug
    queries.push(query);
    // println!("queries: {:?}\n", queries); // debug

    let rdf_add = configs.templates.rdf_add_line.clone();
    let rdf_update = configs.templates.rdf_update_line.clone();
    let rdf_types = configs.templates.rdf_types.clone();
    let mut rdf_lines_add = String::new();
    let mut rdf_lines_update = String::new();

    for i in 0..data.0.len() {
        let (name, value) = (data.0[i].clone(), data.1[i].clone());
        if name == "uid" {
            continue;
        }
        let var_name = if !name.starts_with("dgraph") {
            format!("{}.{}", d_type, name)
        } else {
            name
        };
        let var_type = if vec!["is_cname"].contains(&var_name.as_str()) {
            rdf_types.boolean.clone()
        } else if vec!["res_code", "port"].contains(&var_name.as_str()) {
            rdf_types.integer.clone()
        } else {
            "".to_string()
        };

        let tmp_value = if value.starts_with("_:") {
            value
        } else {
            format!("\"{}\"", value)
        };

        let add_line = rdf_add
            .replace("<ADD_NAME>", &add_name)
            .replace("<VAR_NAME>", &var_name)
            .replace("<VALUE>", &tmp_value)
            .replace("<VAR_TYPE>", &var_type);

        let update_line = rdf_update
            .replace("<ADD_NAME>", &add_name)
            .replace("<VAR_NAME>", &var_name)
            .replace("<VALUE>", &tmp_value)
            .replace("<VAR_TYPE>", &var_type);

        rdf_lines_update = format!("{}\n\t{}", rdf_lines_update, update_line);

        rdf_lines_add = format!("{}\n\t{}", rdf_lines_add, add_line);
    }

    let add_mutate = templates
        .add_mutate
        .replace("<MACHINE_NAME>", &machine_name)
        .replace("<HOST_NAME>", &host_name)
        .replace("<ADD_NAME>", &add_name)
        .replace("<ADD_RDF>", &rdf_lines_add)
        .replace("<UPDATE_RDF>", &rdf_lines_update);
    let mod_mutate = templates
        .mod_mutate
        .replace("<MACHINE_NAME>", &machine_name)
        .replace("<HOST_NAME>", &host_name)
        .replace("<ADD_NAME>", &add_name);
    mutations.push(add_mutate);
    mutations.push(mod_mutate);

    Some(())
}

fn make_query_mut(
    engage_name: &str,
    predicates: Vec<DGType>,
    queries: &mut Vec<String>,
    mutations: &mut Vec<String>,
    configs: &config::Config,
) {
    // println!("{:?}", predicates);
    for graph_data in &predicates {
        match &graph_data {
            &DGType::Machine(dat) => {
                add_query_mutations(
                    "Machine",
                    engage_name,
                    &dat,
                    get_machine_id(dat),
                    queries,
                    mutations,
                    configs,
                );
            }
            &DGType::Port(dat) => {
                add_query_mutations(
                    "Port",
                    engage_name,
                    &dat,
                    get_item("port", dat),
                    queries,
                    mutations,
                    configs,
                );
            }
            &DGType::WebDir(dat) => {
                add_query_mutations(
                    "WebDir",
                    engage_name,
                    &dat,
                    get_item("dir", dat),
                    queries,
                    mutations,
                    configs,
                );
            }
            &DGType::DSNName(dat) => {
                add_query_mutations(
                    "DNSName",
                    engage_name,
                    &dat,
                    get_item("name", dat),
                    queries,
                    mutations,
                    configs,
                );
            }
            &DGType::Credential(dat) => {
                // TODO: make a custom way to query for credentials.
                add_query_mutations(
                    "Credential",
                    engage_name,
                    &dat,
                    get_item("", dat),
                    queries,
                    mutations,
                    configs,
                );
            }
        };
    }
    // println!("query => {:?}", queries);
}

fn com_with_db(
    payload: &str,
    folder: &str,
    content_type: &str,
    configs: &config::Config,
) -> Result<serde_json::Value, String> {
    // eprintln!("update_text => {}", update_text);

    let client = reqwest::blocking::Client::new();
    let url = format!("{}{}", configs.db_server.host, folder);
    // println!("url => {}", url);
    let raw_res = client
        .post(url)
        .header(reqwest::header::CONTENT_TYPE, content_type)
        .body(payload.to_owned())
        .send()
        .expect("could not communicate with the servers")
        .text();
    // println!("raw_res => {}", raw_res);
    // println!("{}", raw_res);
    match raw_res {
        Ok(res) => {
            println!("{}", res);
            match serde_json::from_str(&res) {
                Ok(res) => Ok(res),
                Err(m) => Err(format!(
                    "could not parse json from the server. got error\n{}",
                    m
                )),
            }
        }
        Err(m) => Err(format!(
            "could not comunicate with the server. got error\n{}",
            m
        )),
    }
}

fn send_to_db(update_text: &str, configs: &config::Config) -> Result<u16, String> {
    let mut n_changes = 0;
    let res = com_with_db(
        update_text,
        "/mutate?commitNow=true",
        "application/rdf",
        configs,
    )?;
    // println!("{}", res);
    match res
        .get("data")
        .expect("no data")
        .get("uids")
        .expect("no uids")
    {
        serde_json::Value::Object(dat) => n_changes += dat.len() - 1,
        _ => {}
    };
    // println!("number of changes :  {:?}", n_changes);
    Ok(n_changes as u16)
}

fn make_query(
    get_args: &[String],
    eq_args: &[Vec<&str>],
    req_arg: Option<Vec<String>>,
    engagement: &str,
    configs: &config::Config,
) -> Result<String, String> {
    let target_type = "machine";
    let mut d_types = HashMap::new();
    // let mut pred_to_par = HashMap::new();

    let mut query = match configs.templates.queries.get(target_type) {
        Some(query) => {
            let mut fin_query: Vec<String> = Vec::new();
            let mut types = HashSet::new();
            // let mut parent = target_type;

            for raw_line in query {
                let line = raw_line.trim();
                match line.split_once(":") {
                    Some((id, pred)) => {
                        d_types.insert(id, pred.trim());
                        let is_selected = get_args.contains(&id.to_string());
                        if is_selected {
                            // println!("type => {}", pred.trim().split_once(".").unwrap().0);
                            match pred.trim().split_once(".") {
                                Some(t) => {
                                    types.insert(t.0);
                                }
                                None => {}
                            }
                        }
                    }
                    _ => {}
                };
            }
            let mut n_curly = 0;
            for raw_line in query {
                let line = raw_line.trim();
                let is_get_line = match line.split_once(":") {
                    Some((id, _pred)) => {
                        let is_selected = get_args.contains(&id.to_string());
                        is_selected
                    }
                    _ => false,
                };
                let mut is_sub_root = false;
                for t in &types {
                    is_sub_root = is_sub_root
                        || (line.contains(&format!(": ~{}.", t))
                            && !line.starts_with(&format!("{}.", t)));
                }

                if is_sub_root
                    || is_get_line
                    || line.starts_with("query")
                    || (line == "}" && n_curly == 0)
                    || line.contains("func:")
                {
                    fin_query.push(raw_line.to_owned());
                } else if line.ends_with("{") {
                    // println!("+1 => {} => {}", raw_line, n_curly);
                    n_curly += 1;
                } else if line == "}" && n_curly > 0 {
                    n_curly -= 1;
                } else {
                }
            }

            fin_query.join("\n")
        }
        None => {
            return Err(
                "that type is not available to query. try querying based on something else."
                    .to_string(),
            )
        }
    };

    // let require = match req_arg {
    //     Some(_) => true,
    //     None => false,
    // };

    let (mach_f, port_f, web_d_f, dns_f, mach_c, port_c, web_d_c, dns_c) =
        make_filters(get_args, eq_args, req_arg, d_types, engagement)?;

    query = query
        .replace("<MACHINE_FILTER>", &mach_f)
        .replace("<PORT_FILTER>", &port_f)
        .replace("<DNS_FILTER>", &dns_f)
        .replace("<WEB_DIR_FILTER>", &web_d_f)
        // .replace("<MACHINE_CASCADE>", if require && target_type.to_lowercase() == "machine" {"@cascade"} else {&mach_c})
        // .replace("<PORT_CASCADE>", if require && target_type.to_lowercase() == "port" {"@cascade"} else {&port_c})
        // .replace("<DNS_CASCADE>", if require && target_type.to_lowercase() == "dns_name" {"@cascade"} else {&dns_c})
        // .replace("<WEB_DIR_CASCADE>", if require && target_type.to_lowercase() == "web_dir" {"@cascade"} else {&web_d_c});
        .replace("<MACHINE_CASCADE>", &mach_c)
        .replace("<PORT_CASCADE>", &port_c)
        .replace("<DNS_CASCADE>", &dns_c)
        .replace("<WEB_DIR_CASCADE>", &web_d_c);
    return Ok(query);
}

fn make_filters(
    _get_args: &[String],
    eq_args: &[Vec<&str>],
    req_args: Option<Vec<String>>,
    d_types: HashMap<&str, &str>,
    // pred_to_par: HashMap<&str, &str>,
    engagement: &str,
) -> Result<
    (
        String,
        String,
        String,
        String,
        String,
        String,
        String,
        String,
    ),
    String,
> {
    let mut mach_f: Vec<String> = vec![format!("eq(Machine.engagement, \"{}\")", engagement)];
    let mut port_f: Vec<String> = vec![format!("eq(Port.engagement, \"{}\")", engagement)];
    let mut web_d_f: Vec<String> = vec![format!("eq(WebDir.engagement, \"{}\")", engagement)];
    let mut dns_f: Vec<String> = vec![format!("eq(DNSName.engagement, \"{}\")", engagement)];
    let mut creds_f: Vec<String> = vec![format!("eq(DNSName.engagement, \"{}\")", engagement)];
    // println!("d_types => {:#?}", d_types);
    // make the filter list
    for safe_eq in eq_args {
        let mut eq = safe_eq.clone();
        eq.reverse();
        let predicate = match eq.pop() {
            Some(pred) => match d_types.get(pred.to_lowercase().as_str()) {
                Some(p) => *p,
                None => {
                    return Err(format!(
                        "i don't know the predicate '{}' that you requested.",
                        pred
                    ))
                }
            },
            None => continue,
        };

        // println!("predicate => {:#?}", predicate);

        let values = if eq.len() > 1 {
            format!("[\"{}\"]", eq.join("\", \""))
        } else {
            format!("\"{}\"", eq[0])
        };

        let eq_check = format!("eq({}, {})", predicate, values);

        let tmp_v: &mut Vec<String> = if predicate.starts_with("Machine.") {
            &mut mach_f
        } else if predicate.starts_with("Port.") {
            &mut port_f
        } else if predicate.starts_with("WebDir.") {
            &mut web_d_f
        } else if predicate.starts_with("DNSName.") {
            &mut dns_f
        } else if predicate.starts_with("Credential.") {
            &mut creds_f
        } else {
            return Err(format!(
                "don't know how to process the predicate: '{}'",
                predicate
            ));
        };

        tmp_v.push(eq_check);
    }

    // make the cascade strings
    let (mach_c, port_c, web_d_c, dns_c) = match req_args {
        Some(data) if (data.len() == 1 && data[0] == "*") || data.len() == 0 => (
            "@cascade".to_string(),
            "@cascade".to_string(),
            "@cascade".to_string(),
            "@cascade".to_string(),
        ),
        Some(data) => {
            let mut mach_c: Vec<&str> = Vec::new();
            let mut port_c: Vec<&str> = Vec::new();
            let mut web_d_c: Vec<&str> = Vec::new();
            let mut dns_c: Vec<&str> = Vec::new();
            let mut creds_c: Vec<&str> = Vec::new();

            for required in data {
                let data_t = match d_types.get(required.as_str()) {
                    Some(d_t) => *d_t,
                    None => {
                        return Err(format!(
                            "unknown data type for requirement, '{}'.",
                            required
                        ))
                    }
                };
                let tmp_v: &mut Vec<&str> = if data_t.starts_with("Machine") {
                    &mut mach_c
                } else if data_t.starts_with("Port.") {
                    &mut port_c
                } else if data_t.starts_with("WebDir.") {
                    &mut web_d_c
                } else if data_t.starts_with("DNSName.") {
                    &mut dns_c
                } else if data_t.starts_with("Credential.") {
                    &mut creds_c
                } else {
                    return Err(format!(
                        "could not get data type for requirement, '{}'.",
                        required
                    ));
                };
                tmp_v.push(data_t);
            }

            (
                if mach_c.len() > 0 {
                    format!("@cascade({})", mach_c.join(", "))
                } else {
                    String::from("")
                },
                if port_c.len() > 0 {
                    format!("@cascade({})", port_c.join(", "))
                } else {
                    String::from("")
                },
                if web_d_c.len() > 0 {
                    format!("@cascade({})", web_d_c.join(", "))
                } else {
                    String::from("")
                },
                if dns_c.len() > 0 {
                    format!("@cascade({})", dns_c.join(", "))
                } else {
                    String::from("")
                },
            )
        }
        None => (String::new(), String::new(), String::new(), String::new()),
    };

    Ok((
        format!("@filter({})", mach_f.join(" and ")),
        format!("@filter({})", port_f.join(" and ")),
        format!("@filter({})", web_d_f.join(" and ")),
        format!("@filter({})", dns_f.join(" and ")),
        mach_c,
        port_c,
        web_d_c,
        dns_c,
    ))
}
